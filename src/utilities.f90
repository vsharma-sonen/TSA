!+ Source module for utility routines
!==============================================================================

MODULE  utilities

!==============================================================================
!
! Description:
!   This module provides service utilities for the model. All routines are
!   written in a manner that also other models can use it. That means:
!     - no routine uses other modules, except the declarations for the
!       KIND-type parameter; the data access is by parameter list only
!     - no routine allocates dynamic memory; work space needed is
!       provided via the parameter list
!     - no derived data types are used
!   This module is shared between COSMO / INT2LM and DACE program packages !
!
!   Note : Some OpenACC kernels in this module are asynchronous. When
!          modifying or adding kernels, we have to make sure the correct
!          async queue is used.
!
!   Routines (module procedures) currently contained:
!
!     - convert_month:
!       Converts a 3-character string abbreviation of a month into the number
!       of the month or vice versa.
!
!     - check_field_NaNs
!       generic routine which might be called to check if NaNs are existing
!
!     - dfilt4:
!       Digital filter of length 4
!
!     - dfilt8:
!       Digital filter of length 8
!
!     - diff_minutes:
!       Calculates the diffence in minutes between 2 dates/times
!
!     - diff_seconds:
!       Calculates the diffence in seconds between 2 dates/times
!
!     - dolph:
!       Calculates the Dolph-Chebyshev window for the initialization
!
!     - elapsed_time:
!       Returns the elapsed wall-clock time in seconds since the last call.
!       On the first call the variables are only initialized. If no system
!       clock is present, an error-value will be returned
!
!     - get_utc_date:
!       Calculates the actual date using the date of the forecast-start and
!       the number of timesteps performed.
!
!     - horizontal_filtering
!       horizontal filtering (at the moment especially for the pressure deviation)
!
!     - message
!       to print a message depending on debug level and MPI task
!
!     - phirot2phi:
!       Converts phi from the rotated system to phi in the real
!       geographical system.
!
!     - phi2phirot:
!       Converts phi from the real geographical system to phi
!       in the rotated system.
!
!     - rlarot2rla:
!       Converts lambda from the rotated system to lambda in the real
!       geographical system.
!
!     - rla2rlarot:
!       Converts lambda from the real geographical system to lambda
!       in the rotated system.
!
!     - sleve_split_oro
!       Decomposes a given topography field in a large-scale and a small-scale
!       part according to the definition of the SLEVE coordinate
!
!     - smoother:
!       Smoothes a 2-D field by applying digital filters
!
!     - tautsp:
!       Computes tension splines
!
!     - tautsp2D, tautsp3D:
!       Computes tension splines for several columns
!
!     - to_upper:
!       Converts alphabetic characters from lower to upper case.
!
!     - sortrx:
!       Returns the permutation vector generated by sorting a given array
!       (using a hybrid quicksort - insertion sort algorithm)
!
!     - uvrot2uv:
!       Converts the wind components u and v from the rotated system
!       to the real geographical system.
!
!     - uvrot2uv_vec:
!       the same as above, but for a whole 2D field (in vectorized form).
!
!     - uv2uvrot:
!       Converts the wind components u and v from the real geographical
!       system to the rotated system.
!
!     - uv2uvrot_vec:
!       the same as above, but for a whole 2D field (in vectorized form).
!
!     - uv2df:
!       Converts the wind components u and v to wind direction and speed.
!
!     - uv2df_vec:
!       the same as above, but for a whole 2D field (in vectorized form).
!
!     - linear_interpol:
!       linear interpolation of a vector of x-y-pairs to intermediate
!       x-locations.
!
!     - linear_interpol_vec:
!       the same as above, but in vectorizable form (vectorization over the
!       vector of interpolation points).
!
!     - lininterp2D_xinter1D_vec:
!       the same as above, but the input field is a 2D matrix, and interpolation
!       is done along the second dimension. Vectorization is done over the
!       first dimension of the input matrix.
!
!     - lininterp3D_xinter2D_vec
!        same as linear_interpol_vec but with 3d input field. Interpolation along
!        3rd dimension
!
!     - mittel_integral:
!       alternative to linear interpolation: computes integral averages over
!       averaging intervals (neighbouring, but not overlapping) given in a
!       vector of interval borders. Hereby, the vector of input data is
!       interpreted as a linear spline, which leads to the trapezoidal
!       quadrature rule. Can be used, e.g., for averaging (regridding) high resolution
!       radiosonde data onto a coarser vertical model grid.
!
!     - mittel_integral_vec:
!       the same as above, but in vectorizable form.
!
! Current Code Owner (for COSMO / INT2LM and for DACE):
!  DWD, Ulrich Schaettler
!  phone:  +49  69  8062 2739
!  fax:    +49  69  8062 3721
!  email:  ulrich.schaettler@dwd.de
!
! History:
! Version    Date       Name
! ---------- ---------- ----
! 1.1        1998/03/11 Ulrich Schaettler
!  Initial release
! 1.2        1998/03/30 Ulrich Schaettler
!  Introduction of subroutine dolph used during the initialization
! 1.9        1998/09/16 Guenther Doms
!  Introduction of a smoothing routine 'smoother' which uses digital
!  filters 'dfilt4' and 'dfilt8'.
! 1.10       1998/09/29 Ulrich Schaettler
!  Routine remark eliminated and put to parallel_utilities.
!  Routines uv2uvrot and uv2df introduced
! 1.16       1998/11/02 Guenther Doms
!  Correction of filter processing in routine 'smoother'.
! 1.29       1999/05/11 Ulrich Schaettler
!  Adaptations to use this module also in GME2LM
! 1.32       1999/08/24 Guenther Doms
!  some _ireals declarations added.
! 2.8        2001/07/06 Ulrich Schaettler
!  Added new subroutines tautsp2D, uv2uvrot_vec and uvrot2uv_vec for
!  vectorization
! 2.14       2002/02/15 Ulrich Schaettler
!  Correction and adaptations in tautsp2D (analogous to GME2LM)
!  Added new subroutine dc_topo for the SLEVE coordinate
! 2.17       2002/05/08 Ulrich Schaettler
!  Modifications for performing the filtering in irealgrib-format
! 2.18       2002/07/16 Guenther Doms
!  Corrections for the rotation of the wind components from or to the
!  geographical coordinate system.
! 3.3        2003/04/22 Christoph Schraff
!  Introduction of subroutines 'convert_month' and 'to_upper' (for GPS data).
! 3.6        2003/12/11 Ulrich Schaettler
!  Eliminated Subroutine istringlen (use F90 intrinsic LEN_TRIM instead)
! 3.13       2004/12/03 Ulrich Schaettler
!  Eliminated dependency on data_io (put irealgrib to data_parameters)
!  New SR horizontal_filtering (from INT2LM);
!  Renamed SR dc_topo to sleve_split_oro
! 3.14       2005/01/25 Ulrich Schaettler
!  New filter routine smooth9 for new type of Rayleigh damping (Lucio Torrisi)
!  Changes in horizontal_filtering (Jochen Foerstner)
! 3.15       2005/03/03 Ulrich Schaettler
!  Replaced FLOAT by REAL
! 3.16       2005/07/22 Ulrich Schaettler
!  Bug correction in the call to intrinsic function REAL
! 3.18       2006/03/03 Ulrich Schaettler
!  Introduced idouble/isingle as KIND parameters instead of ireals/irealgrib
!  in the generic formulation of some routines (dfilt4, dfilt8, smoother)
!  Changed get_utc_date to include also a climatological year with 360 days
! 3.21       2006/12/04 Burkhardt Rockel, Lucio Torrisi, Jochen Foerstner
!  Added polgam in transformation function rla2rlarot
!  polgam is not used as optional parameter any more
!  Some adaptations in smooth9 for itype_spubc=2
!  Some modifications in horizontal_filtering
!  Function uv2df_vec introduced. (C. Schraff)
! V3_23        2007/03/30 Ulrich Schaettler
!  Declared some constant variables as parameters to allow inlining on
!  some platforms
!  Changed computation of acthour in get_utc_date
! V3_24        2007/04/26 Ulrich Schaettler
!  Bug correction in computation of acthour in get_utc_date
! V4_1         2007/12/04 Ulrich Schaettler
!  Introduced parameter myid to sleve_split_oro (is called from all PEs in INT2LM)
! V4_4         2008/07/16 Ulrich Schaettler
!  Adapted a debug printout in SR tautsp2D
!  Changed NL parameter lyear_360 to itype_calendar, to have several options
!  Vectorized SR horizontal_filtering by changing some loops
!  Treatment of very small values for spline interpolation in tautsp2D
! V4_8         2009/02/16 Ulrich Schaettler (Andy Dobler)
!  Corrected leap year calculation for centuries in Gregorian calendar
! V4_13        2010/05/11 Michael Gertz
!  Adaptions to SVN
! V4_17        2011/02/24 Ulrich Blahak
!  Added PARAMETER keyword to all declarations of zrpi18, zpir18 and zsmall
!   where this was missing up to now. This enables inlining and vectorization
!   of the concerning routines (uvrot2uv, ...);
!  Added new SRs  linear_interpol(),
!   linear_interpol_vec(), lininterp2D_xinter1D_vec()
!   for linear interpolation and
!   mittel_integral(), mittel_integral_vec() for regridding by
!   means of integral averaging.
! V4_22        2012-01-31 Christoph Schraff
!  Index (quick-)sorting routine 'sortrx' introduced, slightly refined, and
!   translated from (goto-style) F77 into free format F90.
!  New routine 'diff_minutes' to get difference in minutes betw. 2 dates/times.
! V4_23        2012/05/10 Ulrich Schaettler
!  Modifications of diff_minutes to allow for different calendars
!  Added support for climatological year with 365 days in SR get_utc_date
!  Update to latest INT2LM version 1.19
! V4_24        2012/06/22 Hendrik Reich
!  Changes in get_utc_date to account for start dates that are not full hours
! V4_25        2012/09/28 Ulrich Schaettler
!  Editorial changes to adapt to INT2LM Version 1.20
! V4_26        2012/12/06 Denis Blinov, Gdaly Rivin
!  Corrected comments for arguments in rotation routines, where latitude and
!  longitude were mixed up
! V4_28        2013/07/12 Ulrich Schaettler
!  Use kind parameter int_dp from data_parameters
! V5_1         2014-11-28 Ulrich Blahak, Oliver Fuhrer, Ulrich Schaettler
!  Added subroutine diff_seconds
!  Replaced ireals by wp (working precision) (OF)
!  Added generic subroutine check_field_NaNs (OF)
!  Added subroutine message (similar to ICON, to be called in COSMO-ICON physics) (US)
! V5_4         2016-03-10 Ulrich Schaettler
!  Replaced data_parameters by kind_parameters and int_dp by i8
! V5_4c        2016-10-06 Ulrich Schaettler, Lucio Torrisi, Michael Bender
!  Introduced ifdef ISNAN to check NaN values with non-standard intrinsic
!    function isnan  (LT, US)
!  Implemented the interface and a 8-byte integer version of procedure sortrx  (MB)
! V5_4e        2017-03-23 Oliver Fuhrer, Ulrich Schaettler
!  Implemented PURE functions is_nan and is_inf to check for nan and inf
! V5_4f        2017-09-01 Ulrich Blahak
!  Implemented additional subroutine trapz_integral
! V5_5         2018-02-23 Valentin Clement
!  ACC statement to mark subroutine uv2df as sequential
! V5_5a        2018-06-22 Philippe Marti
!  Ported utility routines to GPU with OpenACC.
!  Changed tautsp2D to tautsp3D for optimization reasons
!  Introduced lininterp3D_xinter1D_vec
! V5_6b        2019-10-16 Ulrich Schaettler, Christoph Schraff
!  Added a dimension to the x-axis in subroutine lininterp3D_xinter1D_vec
!    because of introducing interpolation to heights above ground.
!    Therefore renamed that subroutine to lininterp3D_xinter2D_vec
!  Ported uvrot2uv_vec to GPUs
!  Unification with DACE:
!  - Set subroutines and functions used by other modules explicitly to public
!    (required by ICON Compiler directives when modules are ported to ICON).
!  - Trailing blanks at eol removed.
!  - Use IEEE_IS_NAN for modern compilers for (from DACE, Harald Anlauf).
! V5_7         2020-02-21 Ulrich Schaettler, Yannick Boetzel
!  Unification with INT2LM version (US)
!  Made some OpenACC kernels asynchronous (YB)
!
! ==============================================================================
! DACE history:
! ------------
!  1_22        2013-02-13 Andreas Rhodin : taken from COSMO V4_22
!  1_23        2013-03-26 Andreas Rhodin : move module to directory basic
!                                         (used by routines from dir. feedback)
!  1_35        2014-11-07 Harald Anlauf  : Cleanup (constants)
!  1_42        2015-06-08 Andreas Rhodin : minor cleanup
!  1_44        2015-09-30 Andreas Rhodin : update to COSMO 5.03-beta
!  1_51        2017-02-24 Andreas Rhodin : update shared modules from COSMO 5_4d
! ==============================================================================
! CAUTION: This module is used by both the DACE and COSMO / INT2LM codes.    !!!
!!!        Therefore, anybody wanting to introduce a modification to this    !!!
!!!        module in the context of either of these programs must consult    !!!
!!!        the 'current code owner' of this module for the other program,    !!!
!!!        in order to allow for checking that the modification will comply  !!!
!!!        with both program packages. This must be done before the          !!!
!!!        modification is put into the Version Control System (VCS).        !!!
!
! Code Description:
! Language: Fortran 90.
! Software Standards: "European Standards for Writing and
! Documenting Exchangeable Fortran 90 Code".
!==============================================================================
!
! Declarations:
!
! Modules used:
USE kind_parameters , ONLY :   &
    wp,        & ! KIND-type parameter for real variables
    sp,        & ! KIND-type parameter for real variables (single precision)
    dp,        & ! KIND-type parameter for real variables (double precision)
    i4,        & ! KIND-type parameter for 4 byte integer
    i8           ! KIND-type parameter for long int

#ifdef __INT2LM__
USE data_int2lm_constants  , ONLY :   &
    repsilon,&
    t0,      & ! 0 degree Celsius                              [Kelvin]
    r_d,     & ! gas constant for dry air                      [J/K*kg]
    r_v,     & ! gas constant for water vapor                  [J/K*kg]
    rdv,     & ! = R_d/R_v, 
    rvd_m_o, & ! = R_v/R_d - 1.0,  
    o_m_rdv, & ! = 1. - Rdv
    cp_d,    & ! specific heat of dry air at constant pressure [J/K*kg]
    rcpv,    & ! cp_d / cp_v - 1
    rcpl,    & ! cp_d / cp_l - 1
    lh_v,    & ! Latent heat of vaporization                   [J/kg]
    lh_f,    & ! Latent heat of fusion                         [J/kg]
    lh_s,    & ! Latent heat of sublimation                    [J/kg]
    pt00,    & ! Base pressure for computing potential temperature [Pa]
    g,       & ! gravity at sea level                          [ms-2]
    r_earth, & ! mean radius of the earth                      [m]
    Day_len, & ! sidereal day (Sterntag)                       [s]
    cf_snow, & ! parameter for the calculation of the fractional snow coverage
    b1,      & !  a
    b2w => b2_w,    & !  b
    b2i => b2_i,    & !
    b3,      & !  c/b (0 degree Celsius [Kelvin])
    b4i => b4_i,    & !
    b4w => b4_w,    & !  d 
    pi,      & ! circle constant
    raddeg,  & !
    degrad
#else
USE data_constants  , ONLY :   &
    repsilon
#endif

USE, INTRINSIC :: iso_c_binding, ONLY :   &
    c_int        ! KIND-type for C-interoperable integer type

#if ( defined (_CRAYFTN) || defined (__INTEL_COMPILER) || \
      defined (__PGI) || defined (__FLANG) )
USE, INTRINSIC :: ieee_arithmetic, ONLY : &
    ieee_is_nan  ! Check for NaN

#define ISNAN(x) IEEE_IS_NAN(x)
#endif

!==============================================================================

IMPLICIT NONE

PRIVATE
PUBLIC :: diff_minutes, sleve_split_oro, to_upper, sortrx,                    &
          uvrot2uv, uv2uvrot_vec, phi2phirot, rla2rlarot, uv2df, fill_array

          ! public subroutines and functions used in the COSMO / INT2LM
PUBLIC :: convert_month, dolph, elapsed_time, get_utc_date,                   &
          horizontal_filtering, message, phirot2phi, rlarot2rla,              &
          smoother, smooth9, tautsp3D, mittel_integral_vec, trapz_integral,   &
          linear_interpol, linear_interpol_vec, lininterp2D_xinter1D_vec,     &
          lininterp3D_xinter2D_vec, check_field_NaNs, dfilt4, dfilt8,         &
          lm_sleep

#ifdef __INT2LM__
          ! public subroutines and functions used in the INT2LM
PUBLIC :: tautsp2D, check_mem_avail, maxrss,                                  &
          calc_p_hydrostat_psts, calc_p_hydrostat_ana_qv, rh_Tpqv
#endif

          ! routines currently not used, but made available for future use
PUBLIC :: uvrot2uv_vec, uv2uvrot, uv2df_vec
          ! routines currently not used (not even in INT2LM):
!PRIVATE :: diff_seconds, mittel_integral, is_nan, is_inf

!==============================================================================

! Interface Blocks
INTERFACE smoother
  MODULE PROCEDURE                        &
    smoother_double,                      &
    smoother_single
END INTERFACE

INTERFACE dfilt4
  MODULE PROCEDURE                        &
    dfilt4_double,                        &
    dfilt4_single
END INTERFACE

INTERFACE dfilt8
  MODULE PROCEDURE                        &
    dfilt8_double,                        &
    dfilt8_single
END INTERFACE

INTERFACE
  SUBROUTINE check_mem_avail(maxrss) BIND(C,NAME='util_get_maxrss')
!!UB: does not work not on NEC    IMPORT :: C_INT
    USE, INTRINSIC :: iso_c_binding, ONLY :   c_int
    INTEGER(C_INT), INTENT(out) :: maxrss
  END SUBROUTINE check_mem_avail
END INTERFACE

INTERFACE check_field_NaNs
  MODULE PROCEDURE                        &
    check_field_NaNs_4d_double,           &
    check_field_NaNs_4d_single,           &
    check_field_NaNs_3d_double,           &
    check_field_NaNs_3d_single,           &
    check_field_NaNs_2d_double,           &
    check_field_NaNs_2d_single,           &
    check_field_NaNs_1d_double,           &
    check_field_NaNs_1d_single
END INTERFACE

INTERFACE is_nan
  MODULE PROCEDURE                        &
    is_nan_double,                        &
    is_nan_single 
END INTERFACE

INTERFACE is_inf
  MODULE PROCEDURE                        &
    is_inf_double,                        &
    is_inf_single 
END INTERFACE

INTERFACE sortrx
  MODULE PROCEDURE                        &
    sortrx4,                              &
    sortrx8
END INTERFACE

INTERFACE fill_array
  MODULE PROCEDURE                        &
    fill_array_3d,                        &
    fill_array_2d,                        &
    fill_array_1d
END INTERFACE

INTEGER :: maxrss

!==============================================================================

CONTAINS

!==============================================================================

SUBROUTINE convert_month ( MonthString, MonthNumber, ind )

!-------------------------------------------------------------------------------
!
! Description:
!   Convert 3-chr Month string to number (ind > 0) or vice-versa (ind <= 0).
!     If ind > 0 and input string not valid, MonthNumber will be 0.
!     If ind <=0 and input month number invalid, MonthString will be 'XXX'.
! Method:
!     Uses subroutine 'to_upper'.
!-------------------------------------------------------------------------------

  IMPLICIT NONE

! Subroutine arguments:
! --------------------
  CHARACTER (LEN=3), INTENT(INOUT) :: MonthString  ! 3-chr Month name
  INTEGER          , INTENT(INOUT) :: MonthNumber  ! Month number (1-12)
  INTEGER          , INTENT(IN)    :: ind          ! > 0 : chr --> no.
                                                          ! <=0 : no  --> chr

! Local parameters:
! ----------------
  CHARACTER (LEN=36), PARAMETER ::  &
    MonthNames = "JANFEBMARAPRMAYJUNJULAUGSEPOCTNOVDEC"

! Local variables
! ---------------
  CHARACTER (LEN=3)  :: Month
  INTEGER            :: idx
!
!------------ End of header ----------------------------------------------------

  IF ( ind > 0 ) THEN

! ----- String to number -----

    Month = MonthString
    CALL to_upper ( Month )
    idx = INDEX ( MonthNames, Month )
    IF ( MOD ( idx-1, 3 ) == 0 ) THEN
      MonthNumber = ( idx + 2 ) / 3
    ELSE
      MonthNumber = 0
    END IF

  ELSE

! ----- Number to string -----

    IF ( MonthNumber >= 1 .AND. &
         MonthNumber <= 12 ) THEN
      idx = MonthNumber * 3 - 2
      MonthString = MonthNames(idx:idx+2)
    ELSE
      MonthString = "XXX"
    END IF

  END IF

END SUBROUTINE convert_month

!------------------------------------------------------------------------------

!==============================================================================
!==============================================================================
!+ Defines all subroutines for the generic routine dfilt4
!------------------------------------------------------------------------------
!
!  SUBROUTINE dfilt4 (fin, idim, fhelp, fout, nfilt)
!
!------------------------------------------------------------------------------
!
! Description:
!   This routine smoothes an arbitrary field (fin) of length idim by applying
!   a digital filters of length nlength 4 nfilt times. The filterd field
!   is written on fout.
!
! Method:
!   Digital filter according to Shapiro
!
!------------------------------------------------------------------------------
!+ Implementation for double precision
!------------------------------------------------------------------------------

SUBROUTINE dfilt4_double (fin, idim, fhelp, fout, nfilt)

!------------------------------------------------------------------------------

! Parameter list:
INTEGER       , INTENT (IN)          ::    &
  idim,           & ! Dimension of the field
  nfilt             ! Number of iterative filerings
REAL (KIND=dp), INTENT (IN)          ::    &
  fin (idim)        ! input field (unfilterd)
REAL (KIND=dp), INTENT (OUT)         ::    &
  fout (idim)       ! smoothed output field (filtered)
REAL (KIND=dp), INTENT (INOUT)       ::    &
  fhelp(idim)       ! additional storage supplied by the calling routine

! Local variables
INTEGER        :: &
  i,m,            & ! loop indicees
  nf_o2             ! nfilt/2

REAL (KIND=dp) :: &
  fw(5)             ! filter weights

!------------------------------------------------------------------------------
  DATA fw / -0.00390625_dp, 0.03125_dp, -0.109375_dp, 0.21875_dp, 0.7265625_dp/

! begin subroutine dfilt4_double

  nf_o2 = (nfilt+1)/2

  fout (:) = fin(:)
  fhelp(:) = fin(:)

  DO i = 2, idim-1
    fhelp(i) =   0.15_dp*fout (i-1) + 0.7_dp*fout (i)    &
               + 0.15_dp*fout (i+1)
  ENDDO
  DO i = 2, idim-1
    fout (i) =   0.15_dp*fhelp(i-1) + 0.7_dp*fhelp(i)    &
               + 0.15_dp*fhelp(i+1)
  ENDDO

  DO m = 1, nf_o2
    DO i = 5, idim-4
      fhelp(i) =  fw(5)*fout(i) &
                + fw(4)*(fout(i-1)+fout(i+1)) + fw(3)*(fout(i-2)+fout(i+2)) &
                + fw(2)*(fout(i-3)+fout(i+3)) + fw(1)*(fout(i-4)+fout(i+4))
    ENDDO
    DO i = 5, idim-4
      fout(i) = fw(5)*fhelp(i) &
              + fw(4)*(fhelp(i-1)+fhelp(i+1)) + fw(3)*(fhelp(i-2)+fhelp(i+2)) &
              + fw(2)*(fhelp(i-3)+fhelp(i+3)) + fw(1)*(fhelp(i-4)+fhelp(i+4))
    ENDDO
  ENDDO

  DO i = 2, idim-1
    fhelp(i) =   0.15_dp*fout (i-1) + 0.7_dp*fout (i)   &
               + 0.15_dp*fout (i+1)
  ENDDO
  DO i = 2, idim-1
    fout (i) =   0.15_dp*fhelp(i-1) + 0.7_dp*fhelp(i)   &
               + 0.15_dp*fhelp(i+1)
  ENDDO

END SUBROUTINE dfilt4_double

!------------------------------------------------------------------------------
!+ Implementation for single precision
!------------------------------------------------------------------------------

SUBROUTINE dfilt4_single (fin, idim, fhelp, fout, nfilt)

!------------------------------------------------------------------------------

! Parameter list:
INTEGER       , INTENT (IN)          ::    &
  idim,           & ! Dimension of the field
  nfilt             ! Number of iterative filerings
REAL (KIND=sp), INTENT (IN)          ::    &
  fin (idim)        ! input field (unfilterd)
REAL (KIND=sp), INTENT (OUT)         ::    &
  fout (idim)       ! smoothed output field (filtered)
REAL (KIND=sp), INTENT (INOUT)       ::    &
  fhelp(idim)       ! additional storage supplied by the calling routine

! Local variables
INTEGER        :: &
  i,m,            & ! loop indicees
  nf_o2             ! nfilt/2

REAL (KIND=sp) :: &
  fw(5)             ! filter weights

!------------------------------------------------------------------------------
  DATA fw / -0.00390625_sp, 0.03125_sp, -0.109375_sp, 0.21875_sp, 0.7265625_sp /


! begin subroutine dfilt4_single

  nf_o2 = (nfilt+1)/2

  fout (:) = fin(:)
  fhelp(:) = fin(:)

  DO i = 2, idim-1
    fhelp(i) =   0.15_sp*fout (i-1) + 0.7_sp*fout (i)    &
               + 0.15_sp*fout (i+1)
  ENDDO
  DO i = 2, idim-1
    fout (i) =   0.15_sp*fhelp(i-1) + 0.7_sp*fhelp(i)    &
               + 0.15_sp*fhelp(i+1)
  ENDDO

  DO m = 1, nf_o2
    DO i = 5, idim-4
      fhelp(i) =  fw(5)*fout(i) &
                + fw(4)*(fout(i-1)+fout(i+1)) + fw(3)*(fout(i-2)+fout(i+2)) &
                + fw(2)*(fout(i-3)+fout(i+3)) + fw(1)*(fout(i-4)+fout(i+4))
    ENDDO
    DO i = 5, idim-4
      fout(i) = fw(5)*fhelp(i) &
              + fw(4)*(fhelp(i-1)+fhelp(i+1)) + fw(3)*(fhelp(i-2)+fhelp(i+2)) &
              + fw(2)*(fhelp(i-3)+fhelp(i+3)) + fw(1)*(fhelp(i-4)+fhelp(i+4))
    ENDDO
  ENDDO

  DO i = 2, idim-1
    fhelp(i) =   0.15_sp*fout (i-1) + 0.7_sp*fout (i)   &
               + 0.15_sp*fout (i+1)
  ENDDO
  DO i = 2, idim-1
    fout (i) =   0.15_sp*fhelp(i-1) + 0.7_sp*fhelp(i)   &
               + 0.15_sp*fhelp(i+1)
  ENDDO

END SUBROUTINE dfilt4_single

!------------------------------------------------------------------------------

!==============================================================================
!==============================================================================
!+ Defines all subroutines for the generic routine dfilt8
!------------------------------------------------------------------------------
!
! SUBROUTINE dfilt8 (fin, idim, fhelp, fout, nfilt)
!
!------------------------------------------------------------------------------
!
! Description:
!   This routine smoothes an arbitrary field (fin) of length idim by applying
!   a digital filters of length nlength 8 nfilt times. The filterd field
!   is written on fout.
!
! Method:
!   Digital filter according to Shapiro
!
!------------------------------------------------------------------------------
!+ Implementation for double precision
!------------------------------------------------------------------------------

SUBROUTINE dfilt8_double (fin, idim, fhelp, fout, nfilt)

!------------------------------------------------------------------------------

! Parameter list:
INTEGER       , INTENT (IN)          ::    &
  idim,           & ! Dimension of the field
  nfilt             ! Number of iterative filerings
REAL (KIND=dp), INTENT (IN)          ::    &
  fin (idim)        ! input field (unfilterd)
REAL (KIND=dp), INTENT (OUT)         ::    &
  fout (idim)       ! smoothed output field (filtered)
REAL (KIND=dp), INTENT (INOUT)       ::    &
  fhelp(idim)       ! additional storage supplied by the calling routine

! Local variables
INTEGER        :: &
  i,m,            & ! loop indicees
  nf_o2             ! nfilt/2

REAL (KIND=dp) :: &
  fw(9)  ! filter weights

!------------------------------------------------------------------------------
DATA fw /-0.0000152590_dp,  0.0002441406_dp, -0.0018310546_dp, &
          0.0085449218_dp, -0.0277709960_dp,  0.0666503906_dp, &
         -0.1221923828_dp,  0.1745605469_dp,  0.8036193848_dp /

! begin subroutine dfilt8_double

  nf_o2 = (nfilt+1)/2

  fout (:) = fin(:)
  fhelp(:) = fin(:)

  DO i = 2, idim-1
    fhelp(i) =   0.25_dp*fout (i-1) + 0.5_dp*fout (i)     &
               + 0.25_dp*fout (i+1)
  ENDDO
  DO i = 2, idim-1
    fout (i) =   0.25_dp*fhelp(i-1) + 0.5_dp*fhelp(i)     &
               + 0.25_dp*fhelp(i+1)
  ENDDO

  DO m = 1, nf_o2
    DO i = 9, idim-8
      fhelp(i) = fw(9)*fout(i) &
               + fw(8)*(fout(i-1)+fout(i+1)) + fw(7)*(fout(i-2)+fout(i+2)) &
               + fw(6)*(fout(i-3)+fout(i+3)) + fw(5)*(fout(i-4)+fout(i+4)) &
               + fw(4)*(fout(i-5)+fout(i+5)) + fw(3)*(fout(i-6)+fout(i+6)) &
               + fw(2)*(fout(i-7)+fout(i+7)) + fw(1)*(fout(i-8)+fout(i+8))
    ENDDO
    DO i = 9, idim-8
      fout(i) = fw(9)*fhelp(i) &
              + fw(8)*(fhelp(i-1)+fhelp(i+1)) + fw(7)*(fhelp(i-2)+fhelp(i+2)) &
              + fw(6)*(fhelp(i-3)+fhelp(i+3)) + fw(5)*(fhelp(i-4)+fhelp(i+4)) &
              + fw(4)*(fhelp(i-5)+fhelp(i+5)) + fw(3)*(fhelp(i-6)+fhelp(i+6)) &
              + fw(2)*(fhelp(i-7)+fhelp(i+7)) + fw(1)*(fhelp(i-8)+fhelp(i+8))
    ENDDO
  ENDDO

  DO i = 2, idim-1
    fhelp(i) =   0.25_dp*fout (i-1) + 0.5_dp*fout (i)    &
               + 0.25_dp*fout (i+1)
  ENDDO
  DO i = 2, idim-1
    fout (i) =   0.25_dp*fhelp(i-1) + 0.5_dp*fhelp(i)    &
               + 0.25_dp*fhelp(i+1)
  ENDDO

END SUBROUTINE dfilt8_double

!------------------------------------------------------------------------------
!+ Implementation for single precision
!------------------------------------------------------------------------------

SUBROUTINE dfilt8_single (fin, idim, fhelp, fout, nfilt)

!------------------------------------------------------------------------------

! Parameter list:
INTEGER       , INTENT (IN)          ::    &
  idim,           & ! Dimension of the field
  nfilt             ! Number of iterative filerings
REAL (KIND=sp), INTENT (IN)          ::    &
  fin (idim)        ! input field (unfilterd)
REAL (KIND=sp), INTENT (OUT)         ::    &
  fout (idim)       ! smoothed output field (filtered)
REAL (KIND=sp), INTENT (INOUT)       ::    &
  fhelp(idim)       ! additional storage supplied by the calling routine

! Local variables
INTEGER        :: &
  i,m,            & ! loop indicees
  nf_o2             ! nfilt/2

REAL (KIND=sp) :: &
  fw(9)  ! filter weights

!------------------------------------------------------------------------------
DATA fw /-0.0000152590_sp,  0.0002441406_sp, -0.0018310546_sp, &
          0.0085449218_sp, -0.0277709960_sp,  0.0666503906_sp, &
         -0.1221923828_sp,  0.1745605469_sp,  0.8036193848_sp /

! begin subroutine dfilt8_single

  nf_o2 = (nfilt+1)/2

  fout (:) = fin(:)
  fhelp(:) = fin(:)

  DO i = 2, idim-1
    fhelp(i) =   0.25_sp*fout (i-1) + 0.5_sp*fout (i)     &
               + 0.25_sp*fout (i+1)
  ENDDO
  DO i = 2, idim-1
    fout (i) =   0.25_sp*fhelp(i-1) + 0.5_sp*fhelp(i)     &
               + 0.25_sp*fhelp(i+1)
  ENDDO

  DO m = 1, nf_o2
    DO i = 9, idim-8
      fhelp(i) = fw(9)*fout(i) &
               + fw(8)*(fout(i-1)+fout(i+1)) + fw(7)*(fout(i-2)+fout(i+2)) &
               + fw(6)*(fout(i-3)+fout(i+3)) + fw(5)*(fout(i-4)+fout(i+4)) &
               + fw(4)*(fout(i-5)+fout(i+5)) + fw(3)*(fout(i-6)+fout(i+6)) &
               + fw(2)*(fout(i-7)+fout(i+7)) + fw(1)*(fout(i-8)+fout(i+8))
    ENDDO
    DO i = 9, idim-8
      fout(i) = fw(9)*fhelp(i) &
              + fw(8)*(fhelp(i-1)+fhelp(i+1)) + fw(7)*(fhelp(i-2)+fhelp(i+2)) &
              + fw(6)*(fhelp(i-3)+fhelp(i+3)) + fw(5)*(fhelp(i-4)+fhelp(i+4)) &
              + fw(4)*(fhelp(i-5)+fhelp(i+5)) + fw(3)*(fhelp(i-6)+fhelp(i+6)) &
              + fw(2)*(fhelp(i-7)+fhelp(i+7)) + fw(1)*(fhelp(i-8)+fhelp(i+8))
    ENDDO
  ENDDO

  DO i = 2, idim-1
    fhelp(i) =   0.25_sp*fout (i-1) + 0.5_sp*fout (i)    &
               + 0.25_sp*fout (i+1)
  ENDDO
  DO i = 2, idim-1
    fout (i) =   0.25_sp*fhelp(i-1) + 0.5_sp*fhelp(i)    &
               + 0.25_sp*fhelp(i+1)
  ENDDO

END SUBROUTINE dfilt8_single

!==============================================================================
!==============================================================================
!------------------------------------------------------------------------------

SUBROUTINE dolph (deltat, taus, m, window, t, time, time2, w, w2)

!------------------------------------------------------------------------------
!
! Description:
!  Calculation of Dolph-Chebyshev window or, for short, Dolph Window, using
!  the expression in the reference:
!    Antoniou, Andreas, 1993: Digital Filters: Analysis,
!    Design and Applications. McGraw-Hill, Inc., 689pp.
!
!  The Dolph window is optimal in the following sense:
!  For a given main-lobe width, the stop-band attenuation is minimal;
!  for a given stop-band level, the main-lobe width is minimal.
!
! Method:
!
! Modules used:    NONE
!
!------------------------------------------------------------------------------

! Parameter List:
! ---------------

INTEGER        , INTENT (IN)             ::  &
  m                   ! for dimensioning the work arrays

REAL  (KIND=wp), INTENT (IN)             ::  &
  deltat, taus        ! time step and cutoff period for filtering

REAL  (KIND=wp), INTENT (OUT)            ::  &
  window(0:2*m)       ! result

! The following variables are only used for work space
REAL  (KIND=wp), INTENT (OUT)            ::  &
  t(0:2*m), time(0:2*m), time2(0:2*m), w(0:2*m), w2(0:2*m)

! Local Variables:
! ----------------

INTEGER           :: nt, i, n, nm1, nn
REAL    (KIND=wp) :: zpi, zthetas, zx0, zarg, zterm1, zterm2, zrr,   &
                     zr, zdb, zsum, zsumw

!------------ End of header ---------------------------------------------------

! Begin subroutine dolph

  zpi = 4.0_wp * ATAN(1.0_wp)

  n = 2*m+1
  nm1 = n-1
  zthetas = 2.0_wp*zpi*deltat/taus
  zx0 = 1.0_wp / COS(zthetas/2.0_wp)
  zterm1 = (zx0 + SQRT(zx0**2-1))**(REAL (N-1, wp))
  zterm2 = (zx0 - SQRT(zx0**2-1))**(REAL (N-1, wp))
  zrr = 0.5_wp*(zterm1 + zterm2)
  zr = 1.0_wp/zrr
  zdb = 20.0_wp * LOG10(zr)

!------------------------------------------------------------

  DO nt = 0, M
    zsum = 1.0_wp
    DO i = 1, M
      zarg = zx0 * cos(i*zpi/N)
      ! Calculate the Chebyshev polynomials
      ! Reference: Numerical Recipes, Page 184, recurrence
      !   T_n(x) = 2xT_{n-1}(x) - T_{n-2}(x) ,  n>=2.
      T(0) = 1.0_wp
      T(1) = zarg
      DO nn=2,nm1
        T(nn) = 2.0_wp*zarg*T(nn-1) - T(nn-2)
      ENDDO
      zterm1 = T(nm1)
      zterm2 = cos(2.0_wp*nt*zpi*i/n)
      zsum   = zsum + zr*2.0_wp * zterm1 * zterm2
    ENDDO
    w(nt) = zsum / n
    TIME(nt) = REAL(nt,wp)
  ENDDO

  ! Fill in the negative-time values by symmetry.
  DO nt = 0, m
    w2(m+nt) = w(nt)
    w2(m-nt) = w(nt)
    time2(m+nt) =  time(nT)
    time2(m-nt) = -time(nT)
  ENDDO

  ! Fill up the array for return
  zsumw = 0.0_wp
  DO nt = 0, 2*m
    zsumw = zsumw + w2(nt)
  ENDDO

  DO nt=0,2*m
    WINDOW(nt) = w2(nt)
  ENDDO
!
!
!----------------------------------------------------------
!       PRINT *, (w2(nT),    nT=0,2*M)
!----------------------------------------------------------
!

END SUBROUTINE dolph

!==============================================================================
!==============================================================================

!------------------------------------------------------------------------------

SUBROUTINE elapsed_time    (realtimedif, istat)

!------------------------------------------------------------------------------
!
! Description:
!   Returns the elapsed wall-clock time in seconds since the last call. On
!   the first call the variables are only initialized. If no system clock is
!   present, an error value of istat=1 will be returned, if the optional
!   argument istat was passed from the calling routine.
!   realtimedif is set to 0 then.
!
! Method:
!   The intrinsic function SYSTEM_CLOCK is used, that returns the number of
!   clock counts since some system dependent event in the past (e.g. midnight
!   for a 24-hour system clock). The difference of clock counts since the last
!   call is determined and converted into seconds. The variables "lfirst"
!   and "icountsold" (see below) have to be SAVEd for the next call.
!
! Modules used:    NONE
!
!------------------------------------------------------------------------------
!
! Parameter List:
! ---------------

REAL(KIND=wp), INTENT (OUT)            ::  &
      realtimedif     ! wall-clock time since the last call in seconds
                      ! (0 if no system-clock is available)

INTEGER      , INTENT (OUT), OPTIONAL  ::  &
      istat           ! optional argument for error value


! Local Variables:
! ----------------

LOGICAL, SAVE      :: lfirst = .TRUE.   ! determine whether first call or not

INTEGER, SAVE      :: icountsold        ! number of counts in the last call

INTEGER            :: icountsnew,     & ! number of counts in this call
                      ir, im            ! other arguments to SYSTEM_CLOCK

LOGICAL            :: lpres             ! if optional argument is present

!------------ End of header ---------------------------------------------------

! Begin subroutine elapsed_time

  lpres = PRESENT (istat)

  CALL SYSTEM_CLOCK ( COUNT=icountsnew, COUNT_RATE=ir, COUNT_MAX=im )

  IF ( ir /= 0 ) THEN
    ! system clock is present
    IF (lpres) THEN
      istat = 0
    ENDIF

    IF (lfirst) THEN
      ! first call: store value for the number of clock counts
      icountsold = icountsnew
      lfirst     = .FALSE.
    ELSE
      ! convert the clock counts to seconds
      IF ( icountsnew >= icountsold ) THEN
        realtimedif = ( REAL (icountsnew - icountsold, wp) )      &
                      / REAL (ir,wp)
      ELSE
        realtimedif = REAL (im- (icountsold-icountsnew ), wp)     &
                      / REAL (ir, wp)
      ENDIF
      icountsold = icountsnew
    ENDIF
  ELSE
    ! no system clock present: set error value
    realtimedif = 0.0_wp
    IF ( lpres ) THEN
      istat = 1
    ENDIF
  ENDIF

END SUBROUTINE elapsed_time

!==============================================================================
!==============================================================================

!------------------------------------------------------------------------------

SUBROUTINE get_utc_date (ntsteps, ystartdate, dt, itype_calendar,           &
                         yactdate1, yactdate2, nactday, acthour)

!------------------------------------------------------------------------------
!
! Description:
!   This routine determines the actual date of this forecast step.
!
! Method:
!   Using the date of the forecast-start, the number of time steps
!   already performed and the length of the time steps, the actual
!   date is calculated taking leap-years into consideration.
!   The date is given in three different formats.
!
! Modules used:    NONE
!
!------------------------------------------------------------------------------
!
! Input Parameter list:
! ---------------------

INTEGER         ,   INTENT(IN)   ::                           &
  itype_calendar,   & ! for specifying the calendar used
  ntsteps             ! number of actual performed time-steps

REAL   (KIND=wp),   INTENT(IN)   ::                           &
  dt         ! time step in seconds

CHARACTER (LEN=14), INTENT(IN)   ::                           &
  ystartdate ! start date of the forecast

! Output Parameter list:
! ----------------------

CHARACTER (LEN=14), INTENT(OUT)  ::                           &
  yactdate1  ! actual date in the form   yyyymmddhhmmss

CHARACTER (LEN=28), INTENT(OUT)  ::                           &
  yactdate2  ! actual date in the form   wd   dd.mm.yy  hh mm ss UTC


INTEGER         , INTENT(OUT)    ::                           &
  nactday    ! day of the year

REAL   (KIND=wp), INTENT(OUT)    ::                           &
  acthour    ! actual hour of the day

! Local variables:
INTEGER                          ::                                   &
  month(12), monthsum(13), ileap, iweek, iy, m,                       &
  idd, imm, iyy, ihh, imi, iss,                                       &
  iday, imonth, iyear, ihour, imin, isec,                             &
  immhours, iyyhours, iyear_hours, inhour, irsec

CHARACTER (LEN=3)                :: yweek(7)

! And for computing the amount of seconds of the whole forecast time,
! an 8-Byte INTEGER has to be used. Otherwise the computation fails after
! approx. 68 years!!

INTEGER (KIND=i8) :: insec

!------------ End of header ---------------------------------------------------

! Begin subroutine get_utc_date

DATA         month  / 31 ,  28 ,  31 ,  30 ,  31 ,  30 ,       &
                      31 ,  31 ,  30 ,  31 ,  30 ,  31 /
DATA         yweek  /'MON', 'TUE', 'WED', 'THU', 'FRI', 'SAT', 'SUN' /


! Statementfunction: ileap(yy) = 0:  no leap year,
!                    ileap(yy) = 1:  leap year
! corrected version for Gregorian / Proleptic calendar
! by A. Dobler, CLM Community
  ileap (iy) = IABS( MOD(iy,  4) -   4) /   4  & ! every       4 years is a leapyear
              -IABS( MOD(iy,100) - 100) / 100  & ! every     100 years is no leapyear
              +IABS( MOD(iy,400) - 400) / 400    ! but every 400 years is a leapyear

! Divide ystartdate in day, month, year and hour
! and since version 4.24: also in minutes and seconds
! and calculate the sums of days from the beginning of the year to the
! end of the months
  READ ( ystartdate, '(I4,5I2)' ) iyy, imm, idd, ihh, imi, iss

  IF     (itype_calendar == 0) THEN
    month (2)    = 28 + ileap (iyy)
    monthsum(1) =  0
    DO m =  2 , 13
      monthsum(m) =  monthsum(m-1) + month(m-1)
    enddo
  ELSEIF (itype_calendar == 1) THEN
    monthsum(1) =  0
    DO m =  2 , 13
      monthsum(m) =  monthsum(m-1) + 30
    enddo
  ELSEIF (itype_calendar == 2) THEN
    monthsum(1) =  0
    DO m =  2 , 13
      monthsum(m) =  monthsum(m-1) + month(m-1)
    enddo
  ENDIF

! Determine how many hours have passed in this year
! iyyhours counts to the start of the forecast (if it is a full hour)
! or to the full hour before start of the forecast
  iyyhours = (idd*24) + monthsum(imm)*24 + (ihh-24)

! insec adds the seconds between full hour before start of the forecast and the
! start of the forecast (if any) + the forecast length in seconds
  insec = NINT(ntsteps*dt, i8) + INT(imi, i8) * 60_i8                 &
                                   + INT(iss, i8) *  1_i8
! inhour is the same in (full) hours
  IF (insec >= 0_i8) THEN
     inhour = INT(insec/3600_i8)
  ELSE
     inhour = INT(FLOOR(REAL(insec,wp)/3600.0_wp))
  ENDIF
  iyyhours = iyyhours + inhour

! Take turning of the year into account
  IF     (itype_calendar == 0) THEN
    iyear_hours = 8760 + ileap(iyy)*24
  ELSEIF (itype_calendar == 1) THEN
    iyear_hours = 8640
  ELSEIF (itype_calendar == 2) THEN
    iyear_hours = 8760
  ENDIF

  IF (iyyhours < 0) THEN
    iyear    = iyy-1
    IF     (itype_calendar == 0) THEN
      iyyhours = 8760 + ileap(iyear)*24 + iyyhours
    ELSEIF (itype_calendar == 1) THEN
      iyyhours = 8640                   + iyyhours
    ELSEIF (itype_calendar == 2) THEN
      iyyhours = 8760                   + iyyhours
    ENDIF
  ELSE IF (iyyhours >= iyear_hours) THEN
    ! Take also into account if the run lasts for several years
    iyear    = iyy
    IF     (itype_calendar == 0) THEN
      iyear_hours = 8760 + ileap(iyear)*24
    ELSEIF (itype_calendar == 1) THEN
      iyear_hours = 8640
    ELSEIF (itype_calendar == 2) THEN
      iyear_hours = 8760
    ENDIF

    DO WHILE (iyyhours >= iyear_hours)
      iyyhours = iyyhours - iyear_hours
      iyear=iyear+1
      IF     (itype_calendar == 0) THEN
        iyear_hours = 8760 + ileap(iyear)*24
      ELSEIF (itype_calendar == 1) THEN
        iyear_hours = 8640
      ELSEIF (itype_calendar == 2) THEN
        iyear_hours = 8760
      ENDIF
    ENDDO
  ELSE
    iyear    =   iyy
  ENDIF

  ! calculate monthsum for actual year
  IF     (itype_calendar == 0) THEN
    month (2)    = 28 + ileap (iyear)
    monthsum(1) =  0
    DO m =  2 , 13
      monthsum(m) =  monthsum(m-1) + month(m-1)
    enddo
  ELSEIF (itype_calendar == 1) THEN
    monthsum(1) =  0
    DO m =  2 , 13
      monthsum(m) =  monthsum(m-1) + 30
    enddo
  ELSEIF (itype_calendar == 2) THEN
    monthsum(1) =  0
    DO m =  2 , 13
      monthsum(m) =  monthsum(m-1) + month(m-1)
    enddo
  ENDIF

! Determine the actual date from iyyhours
  m        = 1
  immhours = iyyhours
  DO WHILE (immhours >= 0)
    m        = m+1
    immhours = iyyhours - monthsum(m) * 24
  ENDDO
  imonth   = m-1

  immhours = iyyhours - monthsum(imonth)*24
  iday     = immhours/24 + 1
  ihour    = MOD(immhours,24)

! irsec are the seconds left between the last full hour and the actual time
  irsec    = INT(MODULO(insec,  3600_i8))
  imin     = INT(irsec/60)
  isec     = MODULO(irsec,  60)
! add the time between the last full hour and the actual time
  acthour  = REAL (ihour, wp) +  REAL (irsec, wp) / 3600.0_wp
  nactday  = monthsum(imonth) + iday + INT(acthour/24.0_wp + 0.0001)
  iweek    = MOD(monthsum(imonth) + iday + (iyear-1901) + (iyear-1901)/4, 7)+1

  ihour    = INT(acthour)

  WRITE ( yactdate1(1:4)  , '(I4.4)' ) iyear
  WRITE ( yactdate1(5:6)  , '(I2.2)' ) imonth
  WRITE ( yactdate1(7:8)  , '(I2.2)' ) iday
  WRITE ( yactdate1(9:10) , '(I2.2)' ) ihour
  WRITE ( yactdate1(11:12), '(I2.2)' ) imin
  WRITE ( yactdate1(13:14), '(I2.2)' ) isec

  IF     (itype_calendar == 0 .OR. itype_calendar == 2) THEN
    yactdate2 = yweek(iweek)//' '//yactdate1(7:8)//'.'// yactdate1(5:6)//'.' &
                      //yactdate1(1:4)//'  '//yactdate1(9:10)//':' &
                      //yactdate1(11:12)//':'//yactdate1(13:14)//' UTC'
  ELSEIF (itype_calendar == 1) THEN
    yactdate2 = '    '//yactdate1(7:8)//'.'// yactdate1(5:6)//'.' &
                      //yactdate1(1:4)//'  '//yactdate1(9:10)//':' &
                      //yactdate1(11:12)//':'//yactdate1(13:14)//' UTC'
  ENDIF

END SUBROUTINE get_utc_date

!===============================================================================
!===============================================================================

!-------------------------------------------------------------------------------

SUBROUTINE diff_minutes ( iyr_sta, imm_sta, idd_sta, ihh_sta, imin_sta,        &
                          iyr_end, imm_end, idd_end, ihh_end, imin_end,        &
                          icalendar, imindif, irm )

!-------------------------------------------------------------------------------
!
! Description:
!   This routine computes the difference of an 'end' date/time minus a 'start'
!   date/time in minutes.
!
! Method:
!   First checks validity of input parameters (for invalid ranges, see defintion
!   of error status variable 'irm' below). Then straightforward computation of
!   time difference taking into account the special calendar "icalendar":
!      0: gregorian calendar with usual leap years.
!      1: climatological year with 360 days (every month has 30 days)
!      2: climatological year with 365 days (as gregorian but without leap years)
!
! Written by:  C. Schraff,    14.08.2009
! Modified by: U. Schaettler, 24.04.2012
!
!-------------------------------------------------------------------------------
! Declarations:
!-------------------------------------------------------------------------------
!
! Subroutine arguments:
! ---------------------

  INTEGER , INTENT (IN)    ::       &
    iyr_sta  , iyr_end  ,& ! year   of start date / end date  [yy] or [yyyy]
    imm_sta  , imm_end  ,& ! month  of start date / end date  [mm]
    idd_sta  , idd_end  ,& ! day    of start date / end date  [dd]
    ihh_sta  , ihh_end  ,& ! hour   of start time / end time  [hh]
    imin_sta , imin_end ,& ! minute of start time / end time  [min]
    icalendar              ! for the chosen calendar (see above)

  INTEGER , INTENT (OUT)   ::       &
    imindif     ,& ! difference of end date/time minus start date/time [minute]
    irm            ! error status = 0 : no error
                   !              = 1 : invalid year   ( < 100 )
                   !              = 2 : invalid month  ( < 1 .or. > 12 )
                   !              = 3 : invalid day    ( < 1 .or. > days of mm )
                   !              = 4 : invalid hour   ( < 0 .or. > 23 )
                   !              = 5 : invalid minute ( < 0 .or. > 59 )

! Local parameters:
! ----------------

  INTEGER , PARAMETER  :: &
    mdd      (12) = (/31, 28, 31, 30,  31,  30,  31,  31,  30,  31,  30,  31/),&
    mdd_offs (13) = (/ 0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365/)

! Local variables:
! ----------------

  INTEGER               ::       &
    iddmax1  , iddmax2  ,& ! number of days           in start / end month
    iddjul1  , iddjul2  ,& ! Julian day (within year) of start / end date
    idddif              ,& ! difference in days between  start / end date
    isign               ,& ! = -1 if end year < start year , = 1 otherwise
    iysta    , iyend    ,& ! range of loop over years
    iys                 ,& ! loop index (over years)
    ileap               ,& ! statement function for leap year
    iy                     ! dummy variable for statement function
!
!------------ End of header ----------------------------------------------------

! Statement function for leap year:  ileap(iy) = 0:  no leap year,
! --------------------------------   ileap(iy) = 1:  leap year
  ileap (iy) = IABS( MOD(iy,  4) -  4) /  4 & ! every     4 years is a leapyear
              -IABS( MOD(iy,100) -100) /100 & ! but every 100 ys. is no leapyear
              +IABS( MOD(iy,400) -400) /400   ! but every 400 ys. is a leapyear

!-------------------------------------------------------------------------------
! Begin Subroutine diff_minutes
!-------------------------------------------------------------------------------

  irm     = 0
  imindif = 0

! check input values
! ------------------

  ! check year and month values
  ! check that the year is not given with 2 digits only
  IF ( (iyr_sta < 100) .OR. (iyr_end < 100) )                       irm = 1
  IF (irm == 0) THEN
    IF ( (imm_sta <   1) .OR. (imm_sta >  12) )                     irm = 2
    IF ( (imm_end <   1) .OR. (imm_end >  12) )                     irm = 2
  ENDIF

  ! if century is missing in years, then add it (to end up in range 1960 - 2059)
  !US that is very doubtful for climate simulations and should never happen
  !   in the COSMO-Model, so we set an error code above

  IF (irm == 0) THEN
    ! check days
    SELECT CASE (icalendar)
    CASE (0)   ! gregorian calendar
      iddmax1  =  mdd(imm_sta)
      iddmax2  =  mdd(imm_end)
      IF (imm_sta == 2)  iddmax1  =  iddmax1 + ileap(iyr_sta)
      IF (imm_end == 2)  iddmax2  =  iddmax2 + ileap(iyr_end)
      IF (     (idd_sta < 1) .OR. (idd_sta > iddmax1)                       &
          .OR. (idd_end < 1) .OR. (idd_end > iddmax2))              irm = 3
    CASE (1)   ! climatological year with 360 days
      IF (     (idd_sta < 1) .OR. (idd_sta > 30)                            &
          .OR. (idd_end < 1) .OR. (idd_end > 30))                   irm = 3
    CASE (2)   ! climatological year with 365 days (no leap year)
      iddmax1  =  mdd(imm_sta)
      iddmax2  =  mdd(imm_end)
      IF (     (idd_sta < 1) .OR. (idd_sta > iddmax1)                       &
          .OR. (idd_end < 1) .OR. (idd_end > iddmax2))              irm = 3
    END SELECT
  ENDIF

  ! check hour and minutes values
  IF (irm == 0) THEN
    IF ( (ihh_sta < 0) .OR. (ihh_sta > 23) )                        irm = 4
    IF ( (ihh_end < 0) .OR. (ihh_end > 23) )                        irm = 4
    IF ( (imm_sta < 0) .OR. (imm_sta > 59) )                        irm = 5
    IF ( (imm_end < 0) .OR. (imm_end > 59) )                        irm = 5
  ENDIF

! compute time difference in minutes
! ----------------------------------

  IF (irm == 0) THEN
    ! get Julian days (i.e. days since the beginning of the years)

    SELECT CASE (icalendar)
    CASE (0)   ! gregorian calendar
      iddjul1  =  mdd_offs(imm_sta) + idd_sta
      iddjul2  =  mdd_offs(imm_end) + idd_end
      IF (imm_sta > 2)  iddjul1  =  iddjul1 + ileap(iyr_sta)
      IF (imm_end > 2)  iddjul2  =  iddjul2 + ileap(iyr_end)
    CASE (1)   ! climatological year with 360 days
      iddjul1  =  (imm_sta-1) * 30 + idd_sta
      iddjul2  =  (imm_end-1) * 30 + idd_end
    CASE (2)   ! climatological year with 365 days
      iddjul1  =  mdd_offs(imm_sta) + idd_sta
      iddjul2  =  mdd_offs(imm_end) + idd_end
    END SELECT

    ! difference of days irrespective of years
    idddif  =  iddjul2 - iddjul1

    ! difference of days in case of different years
    IF (iyr_end /= iyr_sta) THEN
      iysta = MIN( iyr_sta , iyr_end )
      iyend = MAX( iyr_sta , iyr_end ) - 1
      isign  = 1
      IF (iyr_end < iyr_sta) THEN
        idddif = - idddif
        isign  = - 1
      ENDIF

      ! loop over years: add days from each year
      SELECT CASE (icalendar)
      CASE (0)   ! gregorian calendar
        DO iys = iysta , iyend
          idddif = idddif + 365 + ileap(iys)
        ENDDO
      CASE (1)   ! climatological year with 360 days
        idddif = idddif + (iyend - iysta + 1) * 360
      CASE (2)   ! climatological year with 365 days
        DO iys = iysta , iyend
          idddif = idddif + 365
        ENDDO
      END SELECT
      idddif = idddif *isign
    ENDIF

    ! difference in minutes
    imindif  =  60* (24*idddif + (ihh_end - ihh_sta))  +  (imin_end - imin_sta)
  ENDIF

END SUBROUTINE diff_minutes

!-------------------------------------------------------------------------------

!===============================================================================
!===============================================================================

!-------------------------------------------------------------------------------

SUBROUTINE diff_seconds ( cdate1         &
                        , cdate2         &
                        , isecdif, irm )

!-------------------------------------------------------------------------------
!
! Description:
!   This routine computes the time difference of two dates/times in seconds,
!   given the dates/times as strings 'cdate1' and 'cdate2'
!   in the character format 'YYYYMMDDhhmmss'.
!   Computed is the time in seconds from 'cdate1' to 'cdate2' taking
!   into account the correct sign of the difference.
!   So far this is only implemented for the Gregorian calendar (itype_calendar = 0).
!
! Note:
!   If there is no century in the date (the year is a 2-digit number),
!   then the date/time format on input should be '00YYMMDDhhmmss'!
!
! Method:
!   First checks validity of input parameters (for invalid ranges, see defintion
!   of error status variable 'irm' below). Then straightforward computation of
!   time difference taking into account leap years.
!
! Original routine diff_minutes:   C. Schraff, 14.08.2009
! Modified and renamed :           U. Blahak,  10.01.2012
!
!-------------------------------------------------------------------------------
! Declarations:
!-------------------------------------------------------------------------------
!
! Subroutine arguments:
! ---------------------

  CHARACTER (len=14) , INTENT (IN)    ::       &
       cdate1, cdate2        ! Input dates in the format 'YYYYMMDDhhmmss'

  INTEGER , INTENT (OUT)   ::       &
    isecdif     ,& ! difference of date/time 2 minus date/time 1 [seconds]
    irm(2,6)       ! error status = 0/1 : no error / error
                   !       irm(1,1) = 1 : invalid year 1  ( < 0 )
                   !       irm(1,2) = 1 : invalid month 1  ( < 1 .or. > 12 )
                   !       irm(1,3) = 1 : invalid day 1    ( < 1 .or. > days of mm )
                   !       irm(1,4) = 1 : invalid hour 1   ( < 0 .or. > 23 )
                   !       irm(1,5) = 1 : invalid minute 1 ( < 0 .or. > 59 )
                   !       irm(1,6) = 1 : invalid second 1 ( < 0 .or. > 59 )
                   !       irm(2,1) = 1 : invalid year 2  ( < 0 )
                   !       irm(2,2) = 1 : invalid month 2  ( < 1 .or. > 12 )
                   !       irm(2,3) = 1 : invalid day 2    ( < 1 .or. > days of mm )
                   !       irm(2,4) = 1 : invalid hour 2   ( < 0 .or. > 23 )
                   !       irm(2,5) = 1 : invalid minute 2 ( < 0 .or. > 59 )
                   !       irm(2,6) = 1 : invalid second 2 ( < 0 .or. > 59 )

! Local parameters:
! ----------------

  INTEGER  ::       &
    iyr_sta  , iyr_end  ,& ! year   of start date / end date  [yy] or [yyyy]
    imm_sta  , imm_end  ,& ! month  of start date / end date  [mm]
    idd_sta  , idd_end  ,& ! day    of start date / end date  [dd]
    ihh_sta  , ihh_end  ,& ! hour   of start time / end time  [hh]
    imin_sta , imin_end ,& ! minute of start time / end time  [min]
    isec_sta , isec_end    ! second of start time / end time  [sec]

  INTEGER , PARAMETER  :: &
    mdd      (12) = (/31, 28, 31, 30,  31,  30,  31,  31,  30,  31,  30,  31/),&
    mdd_offs (13) = (/ 0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334   &
                                                                       , 365/)

! Local variables:
! ---------------

  INTEGER       ::       &
    iyyyy_sta, iyyyy_end,& ! start / end year including century [yyyy]
    iddmax1  , iddmax2  ,& ! number of days           in start / end month
    iddjul1  , iddjul2  ,& ! Julian day (within year) of start / end date
    idddif              ,& ! difference in days between  start / end date
    isign               ,& ! = -1 if end year < start year , = 1 otherwise
    iysta    , iyend    ,& ! range of loop over years
    iys                 ,& ! loop index (over years)
    ileap               ,& ! statement function for leap year
    iy                     ! dummy variable for statement function
!
!------------ End of header ----------------------------------------------------

! Statement function for leap year:  ileap(iy) = 0:  no leap year,
! --------------------------------   ileap(iy) = 1:  leap year
  ileap (iy) = IABS( MOD(iy,  4) -  4) /  4 & ! every     4 years is a leapyear
              -IABS( MOD(iy,100) -100) /100 & ! but every 100 ys. is no leapyear
              +IABS( MOD(iy,400) -400) /400   ! but every 400 ys. is a leapyear

!-------------------------------------------------------------------------------
! Begin Subroutine diff_seconds
!-------------------------------------------------------------------------------

  irm     = 0
  isecdif = 0

! get integer date/time parts from input strings:
! -----------------------------------------------

  READ(cdate1, '(I4,5I2)')  iyr_sta, imm_sta, idd_sta, ihh_sta, imin_sta, isec_sta
  READ(cdate2, '(I4,5I2)')  iyr_end, imm_end, idd_end, ihh_end, imin_end, isec_end

! check input values
! ------------------

  ! check year and month values
  ! as well as hours, minutes and seconds values
  IF  ( iyr_sta  < 0 )                     irm(1,1) = 1
  IF  ( imm_sta  < 1 .OR. imm_sta  > 12 )  irm(1,2) = 1
  IF  ( idd_sta  < 1 .OR. idd_sta  > 31 )  irm(1,3) = 1
  IF  ( ihh_sta  < 0 .OR. ihh_sta  > 23 )  irm(1,4) = 1
  IF  ( imin_sta < 0 .OR. imin_sta > 59 )  irm(1,5) = 1
  IF  ( isec_sta < 0 .OR. isec_sta > 59 )  irm(1,6) = 1
  IF  ( iyr_end  < 0 )                     irm(2,1) = 1
  IF  ( imm_end  < 1 .OR. imm_end  > 12 )  irm(2,2) = 1
  IF  ( idd_end  < 1 .OR. idd_end  > 31 )  irm(2,3) = 1
  IF  ( ihh_end  < 0 .OR. ihh_end  > 23 )  irm(2,4) = 1
  IF  ( imin_end < 0 .OR. imin_end > 59 )  irm(2,5) = 1
  IF  ( isec_end < 0 .OR. isec_end > 59 )  irm(2,6) = 1

  ! if century is missing in years, then add it (to end up in range 1960 - 2059)
  IF ( MAXVAL(irm) == 0 ) THEN
    iyyyy_end  =  iyr_end
    iyyyy_sta  =  iyr_sta
    IF (iyyyy_end <  60)  iyyyy_end = 2000 + iyyyy_end
    IF (iyyyy_sta <  60)  iyyyy_sta = 2000 + iyyyy_sta
    IF (iyyyy_end < 100)  iyyyy_end = 1900 + iyyyy_end
    IF (iyyyy_sta < 100)  iyyyy_sta = 1900 + iyyyy_sta

    ! check days again, but closer:
    iddmax1  =  mdd(imm_sta)
    iddmax2  =  mdd(imm_end)
    IF (imm_sta == 2)  iddmax1  =  iddmax1 + ileap(iyyyy_sta)
    IF (imm_end == 2)  iddmax2  =  iddmax2 + ileap(iyyyy_end)
    IF ( idd_sta < 1 .OR. idd_sta > iddmax1 )  irm(1,3) = 1
    IF ( idd_end < 1 .OR. idd_end > iddmax2 )  irm(2,3) = 1
  ENDIF

  IF ( MAXVAL(irm) == 0)  THEN

! compute time difference in seconds
! ----------------------------------

    ! get Julian days (i.e. days since the beginning of the years)
    iddjul1  =  mdd_offs(imm_sta) + idd_sta
    iddjul2  =  mdd_offs(imm_end) + idd_end
    IF (imm_sta > 2)  iddjul1  =  iddjul1 + ileap(iyyyy_sta)
    IF (imm_end > 2)  iddjul2  =  iddjul2 + ileap(iyyyy_end)

    ! difference of days irrespective of years
    idddif  =  iddjul2 - iddjul1

    ! difference of days in case of different years
    IF (iyyyy_end /= iyyyy_sta) THEN
      iysta = MIN( iyyyy_sta , iyyyy_end )
      iyend = MAX( iyyyy_sta , iyyyy_end ) - 1
      isign  = 1
      IF (iyyyy_end < iyyyy_sta) THEN
        idddif = - idddif
        isign  = - 1
      ENDIF

      ! loop over years: add days from each year
      DO iys = iysta , iyend
        idddif = idddif + 365 + ileap(iys)
      ENDDO
      idddif = idddif *isign
    ENDIF

    ! difference in seconds
    isecdif  =  60 * ( 60 * ( 24*idddif + (ihh_end  - ihh_sta ) )    &
                                        + (imin_end - imin_sta) )  &
                                        + (isec_end - isec_sta)

  ELSE

    ! give detailed error message(s):

    IF ( irm(1,1) > 0 ) THEN
      WRITE (*,*) 'ERROR diff_seconds: wrong year    in cdate1 = '//cdate1
    END IF
    IF ( irm(1,2) > 0 ) THEN
      WRITE (*,*) 'ERROR diff_seconds: wrong month   in cdate1 = '//cdate1
    END IF
    IF ( irm(1,3) > 0 ) THEN
      WRITE (*,*) 'ERROR diff_seconds: wrong day     in cdate1 = '//cdate1
    END IF
    IF ( irm(1,4) > 0 ) THEN
      WRITE (*,*) 'ERROR diff_seconds: wrong hour    in cdate1 = '//cdate1
    END IF
    IF ( irm(1,5) > 0 ) THEN
      WRITE (*,*) 'ERROR diff_seconds: wrong minutes in cdate1 = '//cdate1
    END IF
    IF ( irm(1,6) > 0 ) THEN
      WRITE (*,*) 'ERROR diff_seconds: wrong seconds in cdate1 = '//cdate1
    END IF

    IF ( irm(2,1) > 0 ) THEN
      WRITE (*,*) 'ERROR diff_seconds: wrong year    in cdate2 = '//cdate2
    END IF
    IF ( irm(2,2) > 0 ) THEN
      WRITE (*,*) 'ERROR diff_seconds: wrong month   in cdate2 = '//cdate2
    END IF
    IF ( irm(2,3) > 0 ) THEN
      WRITE (*,*) 'ERROR diff_seconds: wrong day     in cdate2 = '//cdate2
    END IF
    IF ( irm(2,4) > 0 ) THEN
      WRITE (*,*) 'ERROR diff_seconds: wrong hour    in cdate2 = '//cdate2
    END IF
    IF ( irm(2,5) > 0 ) THEN
      WRITE (*,*) 'ERROR diff_seconds: wrong minutes in cdate2 = '//cdate2
    END IF
    IF ( irm(2,6) > 0 ) THEN
      WRITE (*,*) 'ERROR diff_seconds: wrong seconds in cdate2 = '//cdate2
    END IF

  ENDIF

!-------------------------------------------------------------------------------
END SUBROUTINE diff_seconds

!===============================================================================
!===============================================================================
!+ filter routines with 17-, 13-, 9- and 3-points stencil, resp.
!-------------------------------------------------------------------------------

SUBROUTINE horizontal_filtering( field_flt, ie_in, je_in, kedim,          &
                                 nbdlines, nflt_width, ncutoff,           &
                                 neighbors, hfx_mask, hfy_mask )

!-------------------------------------------------------------------------------
!
! Description:
!
! Method:
!
!-------------------------------------------------------------------------------

! Subroutine arguments:
! ---------------------
INTEGER          , INTENT(IN)    ::  &
  ie_in, je_in, kedim,  & ! Dimensions of the field to be filtered
  nbdlines,             & ! number of boundary lines from decomposition
  nflt_width,           & ! width of field extension for filtering
  ncutoff,              & ! filter-value for cutoff
  neighbors(4)            ! process-id's of the neighbors in the grid


REAL    (KIND=wp), INTENT(INOUT) ::  &
  field_flt(ie_in, je_in, kedim)

LOGICAL, INTENT(IN), OPTIONAL ::  &
  hfx_mask(ie_in, je_in), hfy_mask(ie_in, je_in)

! Local scalars:
! -------------
INTEGER ::  &
  ilow, iup,           & !
  jlow, jup,           & !
  i, j, k, l             !  Loop indices

INTEGER ::  &
  istart, iend, jstart, jend, nfw_m_nb

! Local (automatic) arrays:
! -------------------------
REAL    (KIND=wp) ::  &
  field_tmp (ie_in, je_in, kedim), &
  zfwnp(-nflt_width:nflt_width),   & ! filter weights for n-point filter
  zfw3p(-1:1)                        ! filter weights for 3-point filter

!------------------------------------------------------------------------------

  nfw_m_nb = nflt_width - nbdlines
  istart = 1 + nbdlines
  iend   = ie_in - 2*nfw_m_nb - nbdlines
  jstart = 1 + nbdlines
  jend   = je_in - 2*nfw_m_nb - nbdlines

  ! filter weights for n-point filter
  IF (ncutoff == 3 .AND. nflt_width == 4) THEN
    ! --> dfilt4
    ! filter weights for 9-point filter (approx. cutoff = 3)
    zfwnp = (/ -0.390625E-02_wp,     &
               +0.3125E-01_wp,       &
               -0.109375_wp,         &
               +0.21875_wp,          &
               +0.7265625_wp,        &
               +0.21875_wp,          &
               -0.109375_wp,         &
               +0.3125E-01_wp,       &
               -0.390625E-02_wp /)
  ELSEIF (ncutoff == 3 .AND. nflt_width == 8) THEN
    ! --> dfilt8
    ! filter weights for 17-point filter (approx. cutoff = 3)
    zfwnp = (/ -0.15259E-04_wp,      &
               +0.2441406E-03_wp,    &
               -0.18310546E-02_wp,   &
               +0.85449218E-02_wp,   &
               -0.27770996E-01_wp,   &
               +0.666503906E-01_wp,  &
               -0.1221923828_wp,     &
               +0.1745605469_wp,     &
               +0.8036193848_wp,     &
               +0.1745605469_wp,     &
               -0.1221923828_wp,     &
               +0.666503906E-01_wp,  &
               -0.27770996E-01_wp,   &
               +0.85449218E-02_wp,   &
               -0.18310546E-02_wp,   &
               +0.2441406E-03_wp,    &
               -0.15259E-04_wp /)
  ELSEIF (ncutoff == 4 .AND. nflt_width == 4) THEN
    ! filter weights for 9-point filter (approx. cutoff = 4)
    zfwnp = (/ +0.1171875E-01_wp,    &
               -0.3125E-01_wp,       &
               -0.46875E-01_wp,      &
               +0.28125_wp,          &
               +0.5703125_wp,        &
               +0.28125_wp,          &
               -0.46875E-01_wp,      &
               -0.3125E-01_wp,       &
               +0.1171875E-01_wp /)
  ELSEIF (ncutoff == 5 .AND. nflt_width == 6) THEN
    ! filter weights for 13-point filter (approx. cutoff = 5)
    zfwnp = (/ +0.44023278E-02_wp,   &
               +0.13175894E-01_wp,   &
               -0.477203075E-01_wp,  &
               -0.435555245E-01_wp,  &
               +0.94700467E-01_wp,   &
               +0.2888298641_wp,     &
               +0.3803345582_wp,     &
               +0.2888298641_wp,     &
               +0.94700467E-01_wp,   &
               -0.435555245E-01_wp,  &
               -0.477203075E-01_wp,  &
               +0.13175894E-01_wp,   &
               +0.44023278E-02_wp /)
  ELSEIF (ncutoff == 6 .AND. nflt_width == 4) THEN
    ! filter weights for 9-point filter (approx. cutoff = 6)
    zfwnp = (/ -0.4694126E-01_wp,    &
               -0.50095541E-02_wp,   &
               +0.13528415_wp,       &
               +0.25500955_wp,       &
               +0.32331423_wp,       &
               +0.25500955_wp,       &
               +0.13528415_wp,       &
               -0.50095541E-02_wp,   &
               -0.4694126E-01_wp /)
  ELSEIF (ncutoff == 8 .AND. nflt_width == 6) THEN
    ! filter weights for 13-point filter (approx. cutoff = 8)
    zfwnp = (/ -0.16638111E-01_wp,   &
               -0.30753028E-01_wp,   &
               -0.17361869E-02_wp,   &
               +0.65428931E-01_wp,   &
               +0.14784805_wp,       &
               +0.2153241_wp,        &
               +0.2410525_wp,        &
               +0.2153241_wp,        &
               +0.14784805_wp,       &
               +0.65428931E-01_wp,   &
               -0.17361869E-02_wp,   &
               -0.30753028E-01_wp,   &
               -0.16638111E-01_wp /)
  ELSE
    PRINT *, ' ERROR *** Wrong cutoff value for filtering        or *** '
    PRINT *, ' ERROR *** wrong value for filter/field extension.    *** '
  ENDIF

  ! filter weights for 3-point filter (approx. cutoff = 4)
  zfw3p = (/ 0.25_wp, 0.5_wp, 0.25_wp /)

  ! west
  IF (neighbors(1) == -1) THEN
    ilow = 1 + 2*nflt_width
  ELSE
    ilow = istart + nfw_m_nb
  END IF
  ! east
  IF (neighbors(3) == -1) THEN
    iup = iend - nbdlines
  ELSE
    iup = iend + nfw_m_nb
  END IF
  ! south
  IF (neighbors(4) == -1) THEN
    jlow = 1 + 2*nflt_width
  ELSE
    jlow = jstart + nfw_m_nb
  END IF
  ! north
  IF (neighbors(2) == -1) THEN
    jup = jend - nbdlines
  ELSE
    jup = jend + nfw_m_nb
  END IF

  ! init working array
  field_tmp (:,:,:) = field_flt(:,:,:)


  IF ( PRESENT( hfx_mask ) ) THEN

    ! apply n-point-filter in x-direction
    DO k = 1, kedim
      DO j = 1, je_in
        DO i = ilow, iup
          IF ( hfx_mask(i,j) ) THEN
            field_tmp(i,j,k) = 0.0_wp
          ENDIF
        ENDDO
        DO l = -nflt_width, nflt_width
          DO i = ilow, iup
            IF ( hfx_mask(i,j) ) THEN
              field_tmp(i,j,k) = field_tmp(i,j,k)               &
                               + zfwnp(l)*field_flt(i+l,j,k)
            END IF
          END DO
        END DO
      END DO
    END DO

    ! apply 3-point-filter in x-direction at west boundary
    IF (neighbors(1) == -1) THEN
      DO k = 1, kedim
        DO j = 1, je_in
          DO i = nfw_m_nb+1, ilow-1
            IF ( hfx_mask(i,j) ) THEN
              field_tmp(i,j,k) = 0.0_wp
            ENDIF
          ENDDO
          DO l = -1, 1
            DO i = nfw_m_nb+1, ilow-1
              IF ( hfx_mask(i,j) ) THEN
                field_tmp(i,j,k) = field_tmp(i,j,k)             &
                                 + zfw3p(l)*field_flt(i+l,j,k)
              END IF
            END DO
          END DO
        END DO
      END DO
    END IF

    ! apply 3-point-filter in x-direction at east boundary
    IF (neighbors(3) == -1) THEN
      DO k = 1, kedim
        DO j = 1, je_in
          DO i = iup+1, ie_in-nfw_m_nb
            IF ( hfx_mask(i,j) ) THEN
              field_tmp(i,j,k) = 0.0_wp
            ENDIF
          ENDDO
          DO l = -1, 1
            DO i = iup+1, ie_in-nfw_m_nb
              IF ( hfx_mask(i,j) ) THEN
                field_tmp(i,j,k) = field_tmp(i,j,k)             &
                                 + zfw3p(l)*field_flt(i+l,j,k)
              END IF
            END DO
          END DO
        END DO
      END DO
    END IF

  ELSE

    !
    ! apply n-point-filter in x-direction
    !
    DO k = 1, kedim
      DO j = 1, je_in
        DO i = ilow, iup
          field_tmp(i,j,k) = 0.0_wp
        END DO
        DO l = -nflt_width, nflt_width
          DO i = ilow, iup
            field_tmp(i,j,k) = field_tmp(i,j,k)                 &
                             + zfwnp(l)*field_flt(i+l,j,k)
          END DO
        END DO
      END DO
    END DO

    ! apply 3-point-filter in x-direction at west boundary
    IF (neighbors(1) == -1) THEN
      DO k = 1, kedim
        DO j = 1, je_in
          DO i = nfw_m_nb+1, ilow-1
            field_tmp(i,j,k) = 0.0_wp
          END DO
          DO l = -1, 1
            DO i = nfw_m_nb+1, ilow-1
              field_tmp(i,j,k) = field_tmp(i,j,k)               &
                               + zfw3p(l)*field_flt(i+l,j,k)
            END DO
          END DO
        END DO
      END DO
    END IF

    ! apply 3-point-filter in x-direction at east boundary
    IF (neighbors(3) == -1) THEN
      DO k = 1, kedim
        DO j = 1, je_in
          DO i = iup+1, ie_in-nfw_m_nb
            field_tmp(i,j,k) = 0.0_wp
          END DO
          DO l = -1, 1
            DO i = iup+1, ie_in-nfw_m_nb
              field_tmp(i,j,k) = field_tmp(i,j,k)               &
                               + zfw3p(l)*field_flt(i+l,j,k)
            END DO
          END DO
        END DO
      END DO
    END IF

  END IF


  IF ( PRESENT( hfy_mask ) ) THEN

    ! apply n-point-filter in y-direction
    DO k = 1, kedim
      DO j = jlow, jup
        DO i = 1, ie_in
          IF ( hfy_mask(i,j) ) THEN
            field_flt(i,j,k) = 0.0_wp
          ELSE
            field_flt(i,j,k) = field_tmp(i,j,k)
          ENDIF
        ENDDO
        DO l = -nflt_width, nflt_width
          DO i = 1, ie_in
            IF ( hfy_mask(i,j) ) THEN
              field_flt(i,j,k) = field_flt(i,j,k) + zfwnp(l)*field_tmp(i,j+l,k)
            END IF
          END DO
        END DO
      END DO
    END DO

    ! apply 3-point-filter in y-direction at south boundary
    IF (neighbors(4) == -1) THEN
      DO k = 1, kedim
        DO j = nfw_m_nb+1, jlow-1
          DO i = 1, ie_in
            IF ( hfy_mask(i,j) ) THEN
              field_flt(i,j,k) = 0.0_wp
            ELSE
              field_flt(i,j,k) = field_tmp(i,j,k)
            ENDIF
          ENDDO
          DO l = -1, 1
            DO i = 1, ie_in
              IF ( hfy_mask(i,j) ) THEN
                field_flt(i,j,k) = field_flt(i,j,k)+zfw3p(l)*field_tmp(i,j+l,k)
              END IF
            END DO
          END DO
        END DO
      END DO
    END IF

    ! apply 3-point-filter in y-direction at north boundary
    IF (neighbors(2) == -1) THEN
      DO k = 1, kedim
        DO j = jup+1, je_in-nfw_m_nb
          DO i = 1, ie_in
            IF ( hfy_mask(i,j) ) THEN
              field_flt(i,j,k) = 0.0_wp
            ELSE
              field_flt(i,j,k) = field_tmp(i,j,k)
            ENDIF
          ENDDO
          DO l = -1, 1
            DO i = 1, ie_in
              IF ( hfy_mask(i,j) ) THEN
                field_flt(i,j,k) = field_flt(i,j,k)+zfw3p(l)*field_tmp(i,j+l,k)
              END IF
            END DO
          END DO
        END DO
      END DO
    END IF

  ELSE

    !
    ! apply n-point-filter in y-direction
    !
    DO k = 1, kedim
      DO j = jlow, jup
        DO i = 1, ie_in
          field_flt(i,j,k) = 0.0_wp
        ENDDO
        DO l = -nflt_width, nflt_width
          DO i = 1, ie_in
            field_flt(i,j,k) = field_flt(i,j,k)+zfwnp(l)*field_tmp(i,j+l,k)
          END DO
        END DO
      END DO
    END DO

    ! apply 3-point-filter in y-direction at south boundary
    IF (neighbors(4) == -1) THEN
      DO k = 1, kedim
        DO j = nfw_m_nb+1, jlow-1
          DO i = 1, ie_in
            field_flt(i,j,k) = 0.0_wp
          ENDDO
          DO l = -1, 1
            DO i = 1, ie_in
              field_flt(i,j,k) = field_flt(i,j,k)+zfw3p(l)*field_tmp(i,j+l,k)
            END DO
          END DO
        END DO
      END DO
    END IF

    ! apply 3-point-filter in y-direction at north boundary
    IF (neighbors(2) == -1) THEN
      DO k = 1, kedim
        DO j = jup+1, je_in-nfw_m_nb
          DO i = 1, ie_in
            field_flt(i,j,k) = 0.0_wp
          ENDDO
          DO l = -1, 1
            DO i = 1, ie_in
              field_flt(i,j,k) = field_flt(i,j,k)+zfw3p(l)*field_tmp(i,j+l,k)
            END DO
          END DO
        END DO
      END DO
    END IF

  END IF

!------------------------------------------------------------------------------

!------------------------------------------------------------------------------
! End of subroutine horizontal_filtering
!------------------------------------------------------------------------------

END SUBROUTINE horizontal_filtering

!==============================================================================
!==============================================================================

SUBROUTINE message (yname, text, all_print)

CHARACTER (LEN=*) :: yname, text
LOGICAL, INTENT(IN), OPTIONAL :: all_print

LOGICAL :: lprint

IF (PRESENT(all_print)) THEN
  lprint = all_print
ELSE
  lprint = .FALSE.
ENDIF

IF (lprint)  WRITE (*,'(A,A,A)') TRIM(yname), ':   ', TRIM(text)

END SUBROUTINE message

!==============================================================================
!==============================================================================
!+ Function for rotation of geographical coordinates
!------------------------------------------------------------------------------

FUNCTION  phirot2phi ( phirot, rlarot, polphi, pollam, polgam )

!------------------------------------------------------------------------------
!
! Description:
!   This function converts phi from one rotated system to phi in another
!   system. If the optional argument polgam is present, the other system
!   can also be a rotated one, where polgam is the angle between the two
!   north poles.
!   If polgam is not present, the other system is the real geographical
!   system.
!
! Method:
!   Transformation formulas for converting between these two systems.
!
!------------------------------------------------------------------------------

!------------------------------------------------------------------------------
!
! Declarations:
!
!------------------------------------------------------------------------------

! Parameter list:
REAL (KIND=wp),     INTENT (IN)      ::        &
  polphi,   & ! latitude of the rotated north pole
  pollam,   & ! longitude of the rotated north pole
  phirot,   & ! latitude in the rotated system
  rlarot      ! longitude in the rotated system

REAL (KIND=wp),     INTENT (IN)      ::        &
  polgam      ! angle between the north poles of the systems

REAL (KIND=wp)                       ::        &
  phirot2phi  ! latitude in the geographical system

! Local variables
REAL (KIND=wp)                       ::        &
  zsinpol, zcospol, zphis, zrlas, zarg, zgam

REAL (KIND=wp),     PARAMETER        ::        &
  zrpi18 = 57.2957795_wp,                      &
  zpir18 = 0.0174532925_wp

!------------------------------------------------------------------------------

! Begin function phirot2phi

  zsinpol     = SIN (zpir18 * polphi)
  zcospol     = COS (zpir18 * polphi)
 
  zphis       = zpir18 * phirot
  IF (rlarot > 180.0_wp) THEN
    zrlas = rlarot - 360.0_wp
  ELSE
    zrlas = rlarot
  ENDIF
  zrlas       = zpir18 * zrlas

  IF (polgam /= 0.0_wp) THEN
    zgam  = zpir18 * polgam
    zarg  = zsinpol*SIN (zphis) +                                           &
        zcospol*COS(zphis) * ( COS(zrlas)*COS(zgam) - SIN(zgam)*SIN(zrlas) )
  ELSE
    zarg  = zcospol * COS (zphis) * COS (zrlas) + zsinpol * SIN (zphis)
  ENDIF
 
  phirot2phi  = zrpi18 * ASIN (zarg)

END FUNCTION phirot2phi

!==============================================================================
!==============================================================================

!------------------------------------------------------------------------------

FUNCTION  phi2phirot ( phi, rla, polphi, pollam )

!------------------------------------------------------------------------------
! Description:
!   This routine converts phi from the real geographical system to phi
!   in the rotated system.
!
! Method:
!   Transformation formulas for converting between these two systems.
!
!------------------------------------------------------------------------------
! Parameter list:
REAL (KIND=wp),     INTENT (IN)      ::        &
  polphi,  & ! latitude of the rotated north pole
  pollam,  & ! longitude of the rotated north pole
  phi,     & ! latitude in the geographical system
  rla        ! longitude in the geographical system

REAL (KIND=wp)                       ::        &
  phi2phirot ! longitude in the rotated system

! Local variables
REAL (KIND=wp)                           ::    &
  zsinpol, zcospol, zlampol, zphi, zrla, zarg1, zarg2, zrla1

REAL (KIND=wp),     PARAMETER            ::    &
  zrpi18 = 57.2957795_wp,                      & !
  zpir18 = 0.0174532925_wp

!------------------------------------------------------------------------------

! Begin function phi2phirot

  zsinpol  = SIN (zpir18 * polphi)
  zcospol  = COS (zpir18 * polphi)
  zlampol  =      zpir18 * pollam
  zphi     =      zpir18 * phi
  IF (rla > 180.0_wp) THEN
    zrla1  = rla - 360.0_wp
  ELSE
    zrla1  = rla
  ENDIF
  zrla     = zpir18 * zrla1

  zarg1    = SIN (zphi) * zsinpol
  zarg2    = COS (zphi) * zcospol * COS (zrla - zlampol)

  phi2phirot = zrpi18 * ASIN (zarg1 + zarg2)

END FUNCTION phi2phirot

!==============================================================================
!==============================================================================

!------------------------------------------------------------------------------

FUNCTION  rlarot2rla (phirot, rlarot, polphi, pollam, polgam)

!------------------------------------------------------------------------------
!
! Description:
!   This function converts lambda from one rotated system to lambda in another
!   system. If the optional argument polgam is present, the other system
!   can also be a rotated one, where polgam is the angle between the two
!   north poles.
!   If polgam is not present, the other system is the real geographical
!   system.
!
! Method:
!   Transformation formulas for converting between these two systems.
!
! Modules used:    NONE
!
!------------------------------------------------------------------------------

!------------------------------------------------------------------------------
!
! Declarations:
!
!------------------------------------------------------------------------------

! Parameter list:
REAL (KIND=wp),     INTENT (IN)      ::        &
  polphi,   & ! latitude of the rotated north pole
  pollam,   & ! longitude of the rotated north pole
  phirot,   & ! latitude in the rotated system
  rlarot      ! longitude in the rotated system

REAL (KIND=wp),     INTENT (IN)      ::        &
  polgam      ! angle between the north poles of the systems

REAL (KIND=wp)                       ::        &
  rlarot2rla  ! longitude in the geographical system

! Local variables
REAL (KIND=wp)                       ::        &
  zsinpol, zcospol, zlampol, zphis, zrlas, zarg1, zarg2, zgam

REAL (KIND=wp),     PARAMETER        ::        &
  zrpi18 = 57.2957795_wp,                      & !
  zpir18 = 0.0174532925_wp

!------------------------------------------------------------------------------

! Begin function rlarot2rla

  zsinpol = SIN (zpir18 * polphi)
  zcospol = COS (zpir18 * polphi)

  zlampol = zpir18 * pollam
  zphis   = zpir18 * phirot
  IF (rlarot > 180.0_wp) THEN
    zrlas = rlarot - 360.0_wp
  ELSE
    zrlas = rlarot
  ENDIF
  zrlas   = zpir18 * zrlas

  IF (polgam /= 0.0_wp) THEN
    zgam    = zpir18 * polgam
    zarg1   = SIN (zlampol) *                                                &
      (- zsinpol*COS(zphis) * (COS(zrlas)*COS(zgam) - SIN(zrlas)*SIN(zgam))  &
       + zcospol * SIN(zphis))                                               &
    - COS (zlampol)*COS(zphis) * (SIN(zrlas)*COS(zgam) + COS(zrlas)*SIN(zgam))

    zarg2   = COS (zlampol) *                                                &
      (- zsinpol*COS(zphis) * (COS(zrlas)*COS(zgam) - SIN(zrlas)*SIN(zgam))  &
       + zcospol * SIN(zphis))                                               &
    + SIN (zlampol)*COS(zphis) * (SIN(zrlas)*COS(zgam) + COS(zrlas)*SIN(zgam))
  ELSE
    zarg1   = SIN (zlampol) * (-zsinpol * COS(zrlas) * COS(zphis)  +    &
                                zcospol *              SIN(zphis)) -    &
              COS (zlampol) *             SIN(zrlas) * COS(zphis)
    zarg2   = COS (zlampol) * (-zsinpol * COS(zrlas) * COS(zphis)  +    &
                                zcospol *              SIN(zphis)) +   &
              SIN (zlampol) *             SIN(zrlas) * COS(zphis)
  ENDIF
 
  IF (zarg2 == 0.0_wp) zarg2 = 1.0E-20_wp
 
  rlarot2rla = zrpi18 * ATAN2(zarg1,zarg2)
 
END FUNCTION rlarot2rla

!==============================================================================
!==============================================================================

!------------------------------------------------------------------------------

FUNCTION  rla2rlarot ( phi, rla, polphi, pollam, polgam )

!------------------------------------------------------------------------------
!
! Description:
!   This routine converts lambda from the real geographical system to lambda
!   in the rotated system.
!
! Method:
!   Transformation formulas for converting between these two systems.
!
!------------------------------------------------------------------------------
!
! Parameter list:
REAL (KIND=wp),     INTENT (IN)      ::        &
  polphi,  & ! latitude of the rotated north pole
  pollam,  & ! longitude of the rotated north pole
  phi,     & ! latitude in geographical system
  rla        ! longitude in geographical system

REAL (KIND=wp),     INTENT (IN)      ::        &
  polgam      ! angle between the north poles of the systems

REAL (KIND=wp)                       ::        &
  rla2rlarot ! longitude in the the rotated system

! Local variables
REAL (KIND=wp)                           ::    &
  zsinpol, zcospol, zlampol, zphi, zrla, zarg1, zarg2, zrla1

REAL (KIND=wp),     PARAMETER            ::    &
  zrpi18 = 57.2957795_wp,                      & !
  zpir18 = 0.0174532925_wp

!------------------------------------------------------------------------------

! Begin function rla2rlarot

  zsinpol  = SIN (zpir18 * polphi)
  zcospol  = COS (zpir18 * polphi)
  zlampol  =      zpir18 * pollam
  zphi     =      zpir18 * phi
  IF (rla > 180.0_wp) THEN
    zrla1  = rla - 360.0_wp
  ELSE
    zrla1  = rla
  ENDIF
  zrla     = zpir18 * zrla1

  zarg1    = - SIN (zrla-zlampol) * COS(zphi)
  zarg2    = - zsinpol * COS(zphi) * COS(zrla-zlampol) + zcospol * SIN(zphi)

  IF (zarg2 == 0.0_wp) zarg2 = 1.0E-20_wp

  rla2rlarot = zrpi18 * ATAN2 (zarg1,zarg2)

  IF (polgam /= 0.0_wp) THEN
    rla2rlarot = polgam + rla2rlarot
    IF (rla2rlarot > 180._wp) rla2rlarot = rla2rlarot -360._wp
  ENDIF

END FUNCTION rla2rlarot

!==============================================================================
!==============================================================================

SUBROUTINE sleve_split_oro (hsurf, hsurfs, idim, jdim, nflt, nextralines,   &
                            svc1, svc2, vcflat, noutunit, myid, ierror, yerror)

!------------------------------------------------------------------------------
!
! Description:
!     decomposes a given topography field hsurf in a
!     large-scale (hsurfs(:,:,1)) and a small-scale (hsurfs(:,:,2)) part, where
!     hsurf(:,:) = hsurfs(:,:,1) + hsurfs(:,:,2)
!
! Method:
!     - a digital filter is applied for the computation of
!       the large scale part hsurfs(:,:,1).
!     - the boundary values are treated seperately to assure, that
!       also these points are smoothed:
!       i.e. at the i=1    boundary: A(1,j)    = A(2,j)      for all j
!                   i=idim boundary: A(idim,j) = A(idim-1,j) for all j
!                   j=1    boundary: A(i,1)    = A(i,2)      for all i
!                   j=jdim boundary: A(i,jdim) = A(i,jdim-1) for all i
!     - nflt determines, how often the filter is applied
!     - Additionally, the maxima of hsurf, hsurfs(:,:,1) and hsurfs(:,:,2) are
!       computed and written to noutunit.
!
!    written by Daniel Leuenberger, 03.10.2001
!------------------------------------------------------------------------------

! Subroutine Arguments:

INTEGER           , INTENT(IN)    :: &
          idim, jdim,                & !  dimensions of hsurf
          nextralines,               & !  number of extra lines around filtered
                                       !  field (for interpolation program)
          nflt                         !  number of filter applications

REAL     (KIND=wp), INTENT(IN)    :: &
          svc1, svc2,                & !  decay rates for large and small scale
          vcflat                       !  vertical coordinate where the
                                       !  terrain following system changes back
                                       !  to an orthogonal z-system
REAL     (KIND=wp), INTENT(IN)    :: &
          hsurf(idim,jdim)             !  height of full topography

INTEGER           , INTENT(IN)    :: &
          noutunit                     !  unitnumber where output is written to

REAL     (KIND=wp), INTENT(OUT)   :: &
          hsurfs(idim,jdim,2)          !  height of splitted topography parts

INTEGER           , INTENT(IN)    :: &
          myid                         !  PE number

INTEGER           , INTENT(OUT)   :: &
          ierror                       !  error value

CHARACTER(LEN=*)                  :: &
          yerror                       !  error message

! Local variables
REAL     (KIND=wp)                :: &
          maxhsurf,                  & !  maximum of hsurf
          maxhsurf1,                 & !  maximum of hsurfs(:,:,1)
          maxhsurf2,                 & !  maximum of hsurfs(:,:,2)
          gammavc                      !  invertibility parameter

INTEGER                           ::    &
          i,j,n,old,new,temp, istart, iend, jstart, jend

!------------------------------------------------------------------------------
!- End of header -
!------------------------------------------------------------------------------

!------------------------------------------------------------------------------
!- Begin SUBROUTINE sleve_split_oro
!------------------------------------------------------------------------------

  ierror    = 0
  yerror    = '        '

  IF (myid == 0) THEN
    WRITE (noutunit,'(A)') '    '
    WRITE (noutunit,'(A)') '   Splitting of Topography for SLEVE coordinate:'
  ENDIF

  IF ( (nextralines < 0) .OR. (nextralines > 1) ) THEN
    ierror = 1
    yerror = 'ERROR:  nextralines outside range: 0 <= nextralines <= 1'
    RETURN
  ENDIF

  ! In order to obtain the same splitting in LM and in INT2LM, only the domain
  ! without the extra boundary lines is splitted. These extra boundary lines
  ! are indicated by nextralines

  ! compute index boundaries of LM-domain
  istart    = 1    + nextralines
  iend      = idim - nextralines
  jstart    = 1    + nextralines
  jend      = jdim - nextralines

  maxhsurf  = 0.0_wp
  maxhsurf1 = 0.0_wp
  maxhsurf2 = 0.0_wp

  old = 1
  new = 2

  hsurfs(:,:,old) = hsurf(:,:)

  ! apply nflt times an ideal 2d filter to compute the
  ! large-scale part hsurfs(:,:,1) of the topography

  DO n = 1, nflt
    ! treat inner points
    DO j=jstart+1, jend-1
      DO i=istart+1, iend-1
        hsurfs(i,j,new) = 0.25_wp * hsurfs(i,j,old)                      &
              + 0.125_wp      * (hsurfs(i-1,j  ,old) + hsurfs(i+1,j  ,old) + &
                                 hsurfs(i  ,j-1,old) + hsurfs(i  ,j+1,old))  &
              + 0.0625_wp     * (hsurfs(i-1,j-1,old) + hsurfs(i+1,j-1,old) + &
                                 hsurfs(i-1,j+1,old) + hsurfs(i+1,j+1,old))
      ENDDO
    ENDDO

    ! treat corner points
    hsurfs(istart,jstart,new) =  0.25_wp *                                   &
            (hsurfs(istart, jstart  ,old) + hsurfs(istart+1, jstart  ,old)   &
           + hsurfs(istart, jstart+1,old) + hsurfs(istart+1, jstart+1,old))

    hsurfs(istart, jend, new) =  0.25_wp *                                   &
                 (hsurfs(istart, jend  ,old) + hsurfs(istart+1, jend  ,old)  &
                + hsurfs(istart, jend-1,old) + hsurfs(istart+1, jend-1,old))

    hsurfs(iend, jstart, new) =  0.25_wp *                                   &
                (hsurfs(iend, jstart  ,old) + hsurfs(iend-1,jstart  ,old)    &
               + hsurfs(iend, jstart+1,old) + hsurfs(iend-1,jstart+1,old))

    hsurfs(iend,jend,new) =  0.25_wp *                                       &
                         (hsurfs(iend,jend  ,old) + hsurfs(iend-1,jend  ,old)&
                        + hsurfs(iend,jend-1,old) + hsurfs(iend-1,jend-1,old))

    ! treat edge points
    DO j = jstart+1,jend-1
      hsurfs(istart,j,new)  =                                                &
        0.25_wp      * (hsurfs(istart  ,j  ,old) + hsurfs(istart+1,j  ,old)) &
     +  0.125_wp     * (hsurfs(istart  ,j-1,old) + hsurfs(istart  ,j+1,old) +&
                        hsurfs(istart+1,j-1,old) + hsurfs(istart+1,j+1,old) )


      hsurfs(iend,j,new) =                                                   &
         0.25_wp      * (hsurfs(iend  ,j  ,old) + hsurfs(iend-1,j  ,old))    &
      +  0.125_wp     * (hsurfs(iend  ,j-1,old) + hsurfs(iend  ,j+1,old) +   &
                         hsurfs(iend-1,j-1,old) + hsurfs(iend-1,j+1,old) )
    ENDDO

    DO i = istart+1,iend-1
      hsurfs(i,jstart,new)  =                                                &
        0.25_wp      * (hsurfs(i  ,jstart  ,old) + hsurfs(i  ,jstart+1,old)) &
     +  0.125_wp     * (hsurfs(i-1,jstart  ,old) + hsurfs(i+1,jstart  ,old) +&
                        hsurfs(i-1,jstart+1,old) + hsurfs(i+1,jstart+1,old) )

      hsurfs(i,jend,new) =                                                   &
         0.25_wp      * (hsurfs(i  ,jend  ,old) + hsurfs(i  ,jend-1,old))    &
      +  0.125_wp     * (hsurfs(i-1,jend  ,old) + hsurfs(i+1,jend  ,old) +   &
                         hsurfs(i-1,jend-1,old) + hsurfs(i+1,jend-1,old) )
    ENDDO

    temp = old
    old  = new
    new  = temp

  ENDDO

  ! compute the large-scale part hsurfs(:,:,1) of the topo
  hsurfs(istart:iend,jstart:jend,1) = hsurfs(istart:iend,jstart:jend,old)

  ! compute the small-scale part hsurfs(:,:,2) of the topo
  hsurfs(istart:iend,jstart:jend,2) = hsurf (istart:iend,jstart:jend) -    &
                                      hsurfs(istart:iend,jstart:jend,1)

  ! compute maxima of topographies
  maxhsurf  = MAXVAL (hsurf (istart:iend,jstart:jend)  )
  maxhsurf1 = MAXVAL (hsurfs(istart:iend,jstart:jend,1))
  maxhsurf2 = MAXVAL (hsurfs(istart:iend,jstart:jend,2))

  IF (myid == 0) THEN
    WRITE(noutunit,'(A,I5,A)' ) '    nflt = ',nflt,' Applications of Filter'
    WRITE(noutunit,'(A)'      ) '    Maxima of Topography Parts:'
    WRITE(noutunit,'(A,F10.5)')                                               &
             '    Max of Full Topography        hsurf          : ',maxhsurf
    WRITE(noutunit,'(A,F10.5)')                                               &
             '    Max of Large-Scale Topography hsurfs(:,:,1)  : ',maxhsurf1
    WRITE(noutunit,'(A,F10.5)')                                               &
             '    Max of Small-Scale Topography hsurfs(:,:,2)  : ',maxhsurf2
  ENDIF

  ! calculate SLEVE invertibility parameter gammavc
  gammavc = 1.0_wp -                                                          &
    ((MAXVAL(hsurfs(istart:iend,jstart:jend,1)) / svc1) / TANH(vcflat/svc1))- &
    ((MAXVAL(hsurfs(istart:iend,jstart:jend,2)) / svc2) / TANH(vcflat/svc2))

  IF (myid == 0) THEN
    WRITE (noutunit,'(A)') '         '
    WRITE (noutunit,'(A,F10.5)')                                      &
       '   Invertibility parameter for SLEVE coordinate: gammavc = ',gammavc
    WRITE (noutunit,'(A)') '         '
  ENDIF

  ! check if invertibility condition is fulfilled
  IF ( gammavc <= 0.0_wp ) THEN
    PRINT *, 'Invertibility parameter for SLEVE coordinate: gammavc = ',&
              gammavc
    PRINT *, 'vcflat = ',vcflat
    PRINT *, 'svc1   = ',svc1
    PRINT *, 'svc2   = ',svc2
    ierror  = 2
    yerror  = 'Invertibility condition of SLEVE coordinate not '// &
              'fulfilled, check values of svc1, svc2 and vcflat'
    RETURN
  ELSEIF ( gammavc < 0.05_wp ) THEN
    PRINT *, 'Invertibility parameter for SLEVE coordinate: gammavc = ',&
              gammavc
    PRINT *, 'vcflat = ',vcflat
    PRINT *, 'svc1   = ',svc1
    PRINT *, 'svc2   = ',svc2
    PRINT *, 'WARNING !!! SLEVE Invertibility parameter close to ',   &
             'zero, check values of svc1, svc2 and vcflat'
  ENDIF

  IF (nextralines > 0) THEN
    ! The values of hsurfs outside the LM-domain are determined as follows:
    ! First, the large-scale topo hsurfs(:,:,1) is linearly extrapolated
    !     (from the point at the boundary of the LM-domain and the
    !      first point inside the LM-domain),
    ! then the small-scale topo hsurfs(:,:,2) is calculated from the
    ! relationship h2 = h - h1

    ! ** Attention:  This extrapolation works only in the case of
    ! ** nextralines = 1 !!!
    ! ** For nextralines > 1 the extrapolation has yet to be implemented !!!

    DO i = istart, iend
      ! extrapolation of south edge
      hsurfs(i,1,1) = 2 * hsurfs(i,2,1) - hsurfs(i,3,1)
      hsurfs(i,1,2) =     hsurf (i,1)   - hsurfs(i,1,1)

      ! extrapolation of north edge
      hsurfs(i,jdim,1) = 2 * hsurfs(i,jdim-1,1) - hsurfs(i,jdim-2,1)
      hsurfs(i,jdim,2) =     hsurf (i,jdim)     - hsurfs(i,jdim  ,1)
    ENDDO

    DO j = jstart, jend
      ! extrapolation of west edge
      hsurfs(1,j,1) = 2 * hsurfs(2,j,1) - hsurfs(3,j,1)
      hsurfs(1,j,2) =     hsurf (1,j)   - hsurfs(1,j,1)

      ! extrapolation of east edge
      hsurfs(idim,j,1) = 2 * hsurfs(idim-1,j,1) - hsurfs(idim-2,j,1)
      hsurfs(idim,j,2) =     hsurf (idim  ,j)   - hsurfs(idim  ,j,1)
    ENDDO

    ! extrapolation of SW point
    hsurfs(1,1,1) = 2 * hsurfs(2,2,1) - hsurfs(3,3,1)
    hsurfs(1,1,2) = hsurf(1,1) - hsurfs(1,1,1)

    ! extrapolation of  SE point
    hsurfs(idim,1,1) = 2 * hsurfs(idim-1,2,1) - hsurfs(idim-2,3,1)
    hsurfs(idim,1,2) =     hsurf (idim  ,1)   - hsurfs(idim  ,1,1)

    ! extrapolation of NW point
    hsurfs(1,jdim,1) = 2 * hsurfs(2,jdim-1,1) - hsurfs(3,jdim-2,1)
    hsurfs(1,jdim,2) =     hsurf (1,jdim  )   - hsurfs(1,jdim  ,1)

    ! extrapolation of NE point
    hsurfs(idim,jdim,1) = 2*hsurfs(idim-1,jdim-1,1)-hsurfs(idim-2,jdim-2,1)
    hsurfs(idim,jdim,2) =   hsurf (idim  ,jdim)    -hsurfs(idim  ,jdim,1)
  ENDIF

!------------------------------------------------------------------------------
!  End of the Subroutine
!------------------------------------------------------------------------------

END SUBROUTINE sleve_split_oro

!==============================================================================
!==============================================================================
!+ Defines all subroutines for the generic routine smoother
!------------------------------------------------------------------------------
!
! SUBROUTINE smoother (finout, ie, je, nlength, nfilt)
!
!------------------------------------------------------------------------------
!
! Description:
!   This routine smoothes an arbitrary two-dimensional field (fin) by applying
!   digital filters of length nlength (4 or 8) nfilt times. The filterd field
!   is written on fout.
!
! Method:
!   Call of digital filters (dfilt4 or dfilt8) in each direction.
!
!------------------------------------------------------------------------------
!+ Subroutine for double precision
!------------------------------------------------------------------------------

SUBROUTINE smoother_double (finout, ie, je, nlength, nfilt)

!------------------------------------------------------------------------------
!
! Parameter list:
INTEGER       , INTENT (IN)      ::    &
  ie, je,         & ! Dimension of the field
  nlength,        & ! Filter lenght
  nfilt             ! Number of iterative filerings

REAL (KIND=dp), INTENT (INOUT)   ::    &
  finout (ie*je)    ! 2-d field: unfiltered at input, filtered at output

! Local variables
INTEGER                    ::    &
  i,j               ! loop indicees

REAL (KIND=dp)             ::    &
  f_2d_field(ie,je),             & !
  sxin(ie), sxh(ie), sxout(ie),  & ! local storage
  syin(je), syh(je), syout(je)     ! local storage

!------------------------------------------------------------------------------
! begin subroutine smoother_double

  f_2d_field = RESHAPE (finout, (/ie,je/))

  IF ( nlength /= 4 .AND. nlength /= 8 ) THEN
    PRINT*, ' CAUTION: Filterlength =',nlength,' not implemented'
    PRINT*, ' No filtering of output field done'
    RETURN
  ENDIF

  DO j = 1, je
    sxin(:) = f_2d_field(:,j)
    IF(nlength==4)  CALL dfilt4 ( sxin, ie, sxh, sxout, nfilt )
    IF(nlength==8)  CALL dfilt8 ( sxin, ie, sxh, sxout, nfilt )
    f_2d_field(:,j) = sxout(:)
  ENDDO
  DO i = 1, ie
    syin(:) = f_2d_field(i,:)
    IF(nlength==4)  CALL dfilt4 ( syin, je, syh, syout, nfilt )
    IF(nlength==8)  CALL dfilt8 ( syin, je, syh, syout, nfilt )
    f_2d_field(i,:) = syout(:)
  ENDDO

  finout = RESHAPE (f_2d_field, (/ie*je/))

END SUBROUTINE smoother_double

!------------------------------------------------------------------------------
!+ Subroutine for single precision
!------------------------------------------------------------------------------

SUBROUTINE smoother_single (finout, ie, je, nlength, nfilt)

!------------------------------------------------------------------------------
!
! Parameter list:
INTEGER       , INTENT (IN)      ::    &
  ie, je,         & ! Dimension of the field
  nlength,        & ! Filter lenght
  nfilt             ! Number of iterative filerings

REAL (KIND=sp), INTENT (INOUT)   ::    &
  finout (ie*je)    ! 2-d field: unfiltered at input, filtered at output

! Local variables
INTEGER                  ::    &
  i,j               ! loop indicees

REAL (KIND=sp)           ::    &
  f_2d_field(ie,je),             & !
  sxin(ie), sxh(ie), sxout(ie),  & ! local storage
  syin(je), syh(je), syout(je)     ! local storage

!------------------------------------------------------------------------------
! begin subroutine smoother_single

  f_2d_field = RESHAPE (finout, (/ie,je/))

  IF ( nlength /= 4 .AND. nlength /= 8 ) THEN
    PRINT*, ' CAUTION: Filterlength =',nlength,' not implemented'
    PRINT*, ' No filtering of output field done'
    RETURN
  ENDIF

  DO j = 1, je
    sxin(:) = f_2d_field(:,j)
    IF(nlength==4)  CALL dfilt4 ( sxin, ie, sxh, sxout, nfilt )
    IF(nlength==8)  CALL dfilt8 ( sxin, ie, sxh, sxout, nfilt )
    f_2d_field(:,j) = sxout(:)
  ENDDO
  DO i = 1, ie
    syin(:) = f_2d_field(i,:)
    IF(nlength==4)  CALL dfilt4 ( syin, je, syh, syout, nfilt )
    IF(nlength==8)  CALL dfilt8 ( syin, je, syh, syout, nfilt )
    f_2d_field(i,:) = syout(:)
  ENDDO

  finout = RESHAPE (f_2d_field, (/ie*je/))

END SUBROUTINE smoother_single

!==============================================================================
!==============================================================================

!------------------------------------------------------------------------------

SUBROUTINE smooth9 (finout, imin,imaxx,jmin,jmaxx,ie,je,ke)

!------------------------------------------------------------------------------
!
! Description:
!   This routine smoothes an arbitrary two-dimensional field (finout) by applying
!   a 9 points smoother. The filtered field is written on finout.
!
! Method:
!   A 9 points smoother is applied for the computation of the
!   large scale part of finout. The boundary values are treated
!   separately to assure, that also these points are smoothed.
!
!------------------------------------------------------------------------------

! Parameter list:
INTEGER       , INTENT (IN)      ::    &
  imin,jmin,imaxx,jmaxx,    & ! Local Dimension of the field
  ie, je, ke                  ! Dimension of the field

REAL (KIND=wp), INTENT (INOUT)   ::    &
  finout (ie,je,ke)    ! 3-d field: unfiltered at input, filtered at output

! Local variables
INTEGER       ::    &
  i,j,k, imin1, imaxx1,jmin1, jmaxx1

LOGICAL lbord12,lbord13,lbord24,lbord34,lcorn1,lcorn2,lcorn3,lcorn4

REAL (KIND=wp)     ::  fhelp (ie,je) ! local storage

!------------------------------------------------------------------------------
! begin subroutine smooth9
!
      lcorn1=.false.
      lcorn2=.false.
      lcorn3=.false.
      lcorn4=.false.
      lbord13=.false.
      lbord12=.false.
      lbord34=.false.
      lbord24=.false.

! If applied to a subdomain, smooth also points of a grid line halo

      imin1=imin
      jmin1=jmin
      imaxx1=imaxx
      jmaxx1=jmaxx

! Adapt dimensions to the subdomain type (if it has edge and/or corner points)

      IF( imin == 1 ) THEN
        imin1=imin+1
        lbord12=.true.
        IF(jmin == 1) THEN
          lcorn1=.true.
        ENDIF
        IF(jmaxx == je) THEN
          lcorn2=.true.
        ENDIF
      ENDIF
      IF( jmin == 1 ) THEN
        jmin1=jmin+1
        lbord13=.true.
      ENDIF
      IF(imaxx == ie )THEN
        imaxx1=imaxx-1
        lbord34=.true.
        IF (jmin == 1) THEN
          lcorn3=.true.
        ENDIF
        IF(jmaxx == je) THEN
          lcorn4=.true.
        ENDIF
      ENDIF
      IF(jmaxx == je) THEN
        jmaxx1=jmaxx-1
        lbord24=.true.
      ENDIF

      DO k = 1, ke

        fhelp(:,:) = finout(:,:,k)

! Treat inner points

        DO i=imin1,imaxx1
          DO j=jmin1,jmaxx1
            finout(i,j,k) = 0.25_wp * fhelp(i,j)                   &
              + 0.125_wp      * (fhelp(i-1,j  ) + fhelp(i+1,j )  + &
                                 fhelp(i  ,j-1) + fhelp(i  ,j+1))  &
              + 0.0625_wp     * (fhelp(i-1,j-1) + fhelp(i+1,j-1) + &
                                 fhelp(i-1,j+1) + fhelp(i+1,j+1))
          ENDDO
        ENDDO

! Treat corner points

        IF (lcorn1) finout(1,1,k) = 0.25_wp *                                    &
                         (fhelp(1   ,1   ) + fhelp(2   ,1   )      &
                        + fhelp(1   ,2   ) + fhelp(2   ,2   ))

        IF (lcorn2) finout(1 ,jmaxx,k) =  0.25_wp *                               &
                         (fhelp(1   ,jmaxx  ) + fhelp(   2,jmaxx  )  &
                        + fhelp(1   ,jmaxx-1) + fhelp(   2,jmaxx-1))

        IF (lcorn3) finout(imaxx,1 ,k) =  0.25_wp *                               &
                         (fhelp(imaxx,1  ) + fhelp(imaxx-1,1 )    &
                        + fhelp(imaxx,2  ) + fhelp(imaxx-1,2 ))

        IF (lcorn4) finout(imaxx,jmaxx,k) =  0.25_wp *                             &
                         (fhelp(imaxx,jmaxx ) + fhelp(imaxx-1,jmaxx  )&
                        + fhelp(imaxx,jmaxx-1) + fhelp(imaxx-1,jmaxx-1))
! Treat edge points

        IF(lbord12)THEN
          DO j = jmin1,jmaxx1
            finout(1,j,k)  =                                           &
                  0.25_wp   * (fhelp(1   ,j   ) + fhelp(2   ,j   ))    &
               +  0.125_wp  * (fhelp(1   ,j -1) + fhelp(1   ,j +1) +   &
                               fhelp(2   ,j -1) + fhelp(2   ,j +1) )
          ENDDO
        ENDIF

        IF(lbord34)THEN
          DO j = jmin1,jmaxx1
            finout(imaxx,j,k) =                                                   &
               0.25_wp      * (fhelp(imaxx  ,j   ) + fhelp(imaxx-1,j  ))  &
              +  0.125_wp     * (fhelp(imaxx  ,j -1) + fhelp(imaxx  ,j +1) + &
                         fhelp(imaxx-1,j -1) + fhelp(imaxx-1,j +1) )
          ENDDO
        ENDIF

        IF(lbord13)THEN
          DO i = imin1,imaxx1
            finout(i,1,k)  =                                                     &
                  0.25_wp      * (fhelp(i   ,1  ) + fhelp(i   ,2  ))    &
              +   0.125_wp     * (fhelp(i -1,1 ) + fhelp(i +1,1  ) +   &
                           fhelp(i -1,2 ) + fhelp(i +1,2 ) )
          ENDDO
        ENDIF

        IF(lbord24)THEN
          DO i = imin1,imaxx1
            finout(i,jmaxx,k) =                                                   &
             0.25_wp      * (fhelp(i   ,jmaxx ) + fhelp(i   ,jmaxx-1))  &
             +  0.125_wp     * (fhelp(i -1,jmaxx ) + fhelp(i +1,jmaxx ) + &
                         fhelp(i -1,jmaxx-1) + fhelp(i +1,jmaxx-1) )
          ENDDO
        ENDIF

      ENDDO


END SUBROUTINE smooth9

!==============================================================================
!==============================================================================

!------------------------------------------------------------------------------

SUBROUTINE tautsp (TAU,GTAU,NTAU,GAMMA,S,BREAK,COEF,L,IFLAG)

!------------------------------------------------------------------------------
!
! Description:
!   Computes the tension spline for abscissae TAU(i) and ordinates GTAU(i)
!   (i = 1,...,NTAU).
!
! From: Carl DeBoor: A Practical Guide to Splines
!
! Parameters:
!   TAU       Sequence of data points; must be strictly increasing (abscissae)
!   GTAU      Corresponding sequence of function values (ordinates)
!   NTAU      Number of data points; must be at least 4
!   GAMMA     Indicates whether additional flexibility is desired:
!               0   :  no additional knots
!             0<  <3:  Under certain conditions on the given data at points
!                      i-1,i,i+1,i+2, a knot is added in the i-th interval
!                      (i=2,...,NTAU-2).
!             3<  <6:  Same, except that knots might also be added in intervals
!                      in which an inflection point would be permitted
!             The interpolant gets rounded with increasing GAMMA
!
! Output:
!   BREAK,COEF,L,K give the polynomial representation of the interpolant.
!   For BREAK(i) <= X <= BREAK(i+1) the interpolant has the following form:
!
!       F(X)=COEF(1,i)+DX(COEF(2,i)+DX/2(COEF(3,i)+DX/3(COEF(4,i)))
!                        with DX = X-BREAK(i) and i=1,...,L
! Workspace
!   S(NTAU,6)  WORK-ARRAY
!
! Return Codes:
!  IFLAG = 0  No Error
!  IFLAG = 2  Wrong Input
!
! Method:
!
!==============================================================================

INTEGER :: IFLAG,L,NTAU,I,METHOD,NTAUM1
REAL (KIND=wp)                                                     &
   BREAK(L),COEF(4,L),GAMMA,GTAU(NTAU),S(NTAU,6),TAU(NTAU),        &
   ALPHA,C,D,DEL,DENOM,DIVDIF,ENTRY,ENTRY3,FACTOR,FACTR2,GAM,      &
   ONEMG3,ONEMZT,RATIO,SIXTH,TEMP,X,Z,ZETA,ZT2,ALPH

!==============================================================================
!
      ALPH(X)= MIN (1.0_wp,ONEMG3/X)
!
!   Test of input parameters
!
      IF (NTAU .LT. 4) THEN
        WRITE (*,'(A,I4,A)') '  NTAU =', NTAU, ':  has to be greater than 4!'
        GO TO 999
      ENDIF
!
!   Computation of Delta(TAU) and of 1. and 2. derivation of data
!
      NTAUM1=NTAU-1
      DO I=1,NTAUM1
      S(I,1)=TAU(I+1)-TAU(I)
      IF (S(I,1) .LE. 0.0_wp) THEN
        WRITE (*,'(A,I3,A,2E15.6,A)')                                       &
           'Point ', i, ' and the following ', TAU(i), TAU(i+1),            &
           ' are in a wrong order!'
        GO TO 999
      ENDIF
      S(I+1,4) = (GTAU(I+1) - GTAU(I))/S(I,1)
      ENDDO
!
      DO I=2,NTAUM1
      S(I,4) = S(I+1,4) - S(I,4)
      ENDDO
!
!   Construct system of equations for 2. derivatives at TAU. At each interior
!   data point there is one continuity equation; at the first and the last
!   interior data point there is an additional one for a total of NTAU
!   equations in NTAU unknowns.
!
      I=2
      S(2,2) = S(1,1)/3.0_wp
      SIXTH = 1.0_wp/6.0_wp
      METHOD = 2
      GAM = GAMMA
      IF(GAM .LE. 0.0_wp) METHOD = 1
      IF(GAM .GT. 3.0_wp) THEN
        METHOD = 3
        GAM = GAM - 3.0_wp
      ENDIF
      ONEMG3=1.0_wp - GAM/3.0_wp
!
!   Loop over i
!
 10   CONTINUE
      Z=0.5_wp
      IF (METHOD .EQ. 1) THEN
        GO TO 19
      ELSE IF (METHOD .EQ. 2) THEN
        GO TO 11
      ELSE IF (METHOD .EQ. 3) THEN
        GO TO 12
      ENDIF
 11   CONTINUE
      IF(S(I,4)*S(I+1,4).LT.0.0_wp) GO TO 19
 12   CONTINUE
      TEMP = ABS(S(I+1,4))
      DENOM = ABS(S(I,4)) + TEMP
      IF(DENOM.EQ.0.0_wp) GO TO 19
      Z = TEMP/DENOM
      IF(ABS(Z-0.5_wp).LE.SIXTH) Z=0.5_wp
 19   CONTINUE
      S(I,5) = Z
!
!   Set up part of the i-th equation which depends on the i-th interval
!
      IF (Z-0.5_wp .LT. 0._wp) THEN
        ZETA = GAM*Z
        ONEMZT = 1.0_wp - ZETA
        ZT2 = ZETA**2
        ALPHA = ALPH(ONEMZT)
        FACTOR = ZETA/(ALPHA*(ZT2 - 1.0_wp) + 1.0_wp)
        S(I,6) = ZETA*FACTOR/6.0_wp
        S(I,2) = S(I,2) + S(I,1)*((1.0_wp-ALPHA*ONEMZT)*FACTOR*0.5_wp-S(I,6))
        IF(S(I,2).LE.0.0_wp) S(I,2) = 1.0_wp
        S(I,3) = S(I,1)/6.0_wp
!
      ELSE IF (Z-0.5_wp .EQ. 0._wp) THEN
!
        S(I,2) = S(I,2) + S(I,1)/3.0_wp
        S(I,3) = S(I,1)/6.0_wp
!
      ELSE
!
        ONEMZT = GAM*(1.0_wp - Z)
        ZETA = 1.0_wp - ONEMZT
        ALPHA = ALPH(ZETA)
        FACTOR = ONEMZT/(1.0_wp - ALPHA*ZETA*(1.0_wp + ONEMZT))
        S(I,6) = ONEMZT*FACTOR/6.0_wp
        S(I,2) = S(I,2) + S(I,1)/3.0_wp
        S(I,3) = S(I,6) * S(I,1)
      ENDIF
!
      IF (I .GT. 2) GO TO 30
      S(1,5) = 0.5_wp
!
!   The first two equations enforce continuity of the first and of the third
!   derivative across TAU(2)
!
      S(1,2) = S(1,1)/6.0_wp
      S(1,3) = S(2,2)
      ENTRY3 = S(2,3)

      IF (Z-0.5_wp .LT. 0._wp) THEN
        FACTR2 = ZETA*(ALPHA*(ZT2-1.0_wp)+1.0_wp)/(ALPHA*(ZETA*ZT2-1.0_wp) + 1.0_wp)
        RATIO = FACTR2*S(2,1)/S(1,2)
        S(2,2) = FACTR2*S(2,1) + S(1,1)
        S(2,3) = -FACTR2 * S(1,1)
!
      ELSE IF (Z-0.5_wp .EQ. 0._wp) THEN
!
        RATIO = S(2,1)/S(1,2)
        S(2,2) = S(2,1) + S(1,1)
        S(2,3) = -S(1,1)
!
      ELSE
!
        RATIO = S(2,1)/S(1,2)
        S(2,2) = S(2,1) + S(1,1)
        S(2,3) = -S(1,1)*6.0_wp*ALPHA*S(2,6)
      ENDIF
!
!   At this point the first two equations read
!            DIAG(1)*X1 +    U(1)*X2 + ENTRY3*X3 = R(2)
!     -RATIO*DIAG(1)*X1 + DIAG(2)*X2 +   U(2)*X3 = 0
!   Eliminate first unknown from second equation
!
!
      S(2,2) = RATIO*S(1,3) + S(2,2)
      S(2,3) = RATIO*ENTRY3 + S(2,3)
      S(1,4) = S(2,4)
      S(2,4) = RATIO*S(1,4)
      GO TO 35
!
!  The i-th equation forces continuity of the first derivative across TAU(i).
!  It reads now
!     -RATIO*DIAG(i-1)*Xi-1 + DIAG(i)*Xi + U(i)*Xi+1 = R(i)
!  Eliminate i-1st unknown from this equation
!
 30   CONTINUE
      S(I,2) = RATIO*S(I-1,3) + S(I,2)
      S(I,4) = RATIO*S(I-1,4) + S(I,4)
!
!  Set up the part of the next equation which depends on the i-th interval
!
 35   CONTINUE
      IF (Z-0.5_wp .LT. 0._wp) THEN
        RATIO = -S(I,6)*S(I,1)/S(I,2)
        S(I+1,2) = S(I,1)/3.0_wp
!
      ELSE IF (Z-0.5_wp .EQ. 0._wp) THEN
!
        RATIO = -S(I,1)/(6.0_wp*S(I,2))
        S(I+1,2) = S(I,1)/3.0_wp
!
      ELSE
!
        RATIO = -(S(I,1)/6.0_wp)/S(I,2)
        S(I+1,2) = S(I,1)*((1.0_wp - ZETA*ALPHA)*0.5_wp*FACTOR-S(I,6))
      ENDIF
!
!   End of loop over i
!
      I = I + 1
      IF(I.LT.NTAUM1) GO TO 10
      S(I,5) = 0.5_wp
!
!   The last two equations enforce continuity of third derivative and of
!   first derivative across TAU (NTAU-1)
!
      ENTRY = RATIO*S(I-1,3) + S(I,2) + S(I,1)/3.0_wp
      S(I+1,2) = S(I,1)/6.0_wp
      S(I+1,4) = RATIO*S(I-1,4) + S(I,4)
      IF (Z-0.5_wp .LT. 0._wp) THEN
        RATIO = S(I,1)*6.0_wp*S(I-1,6)*ALPHA/S(I-1,2)
        S(I,2) = RATIO*S(I-1,3) + S(I,1) + S(I-1,1)
        S(I,3) = -S(I-1,1)
!
      ELSE IF (Z-0.5_wp .EQ. 0._wp) THEN
!
        RATIO = S(I,1)/S(I-1,2)
        S(I,2) = RATIO*S(I-1,3) + S(I,1) + S(I-1,1)
        S(I,3) = -S(I-1,1)
!
      ELSE
!
        FACTR2 = ONEMZT*(ALPHA*(ONEMZT**2-1.0_wp)+1.0_wp)/     &
                        (ALPHA*(ONEMZT**3-1.0_wp)+1.0_wp)
        RATIO = FACTR2*S(I,1)/S(I-1,2)
        S(I,2) = RATIO*S(I-1,3) + FACTR2*S(I-1,1) + S(I,1)
        S(I,3) = -FACTR2*S(I-1,1)
      ENDIF
!
!  At this point the last two equations read
!           DIAG(i)*Xi +      U(i)*Xi+1 = R(i)
!    -RATIO*DIAG(i)*Xi + DIAG(i+1)*Xi+1 = R(i+1)
!  Eliminate Xi from last equation
!
      S(I,4) = RATIO*S(I-1,4)
      RATIO = -ENTRY/S(I,2)
      S(I+1,2) = RATIO*S(I,3) + S(I+1,2)
      S(I+1,4) = RATIO*S(I,4) + S(I+1,4)
!
!   Back Substitution
!
      S(NTAU,4) = S(NTAU,4)/S(NTAU,2)
 50   CONTINUE
      S(I,4) = (S(I,4) - S(I,3)*S(I+1,4))/S(I,2)
      I = I - 1
      IF(I.GT.1) GO TO 50
      S(1,4) = (S(1,4) -S(1,3)*S(2,4)-ENTRY3*S(3,4))/S(1,2)
!
!   Construct polynomial pieces
!
      BREAK(1) = TAU(1)
      L = 1
      DO 70 I = 1,NTAUM1
      COEF(1,L) = GTAU(I)
      COEF(3,L) = S(I,4)
      DIVDIF = (GTAU(I+1) - GTAU(I))/S(I,1)
      Z = S(I,5)
!
      IF (Z-0.5_wp .LT. 0._wp) THEN
        IF(Z.EQ.0.0_wp) GO TO 65
        ZETA = GAM*Z
        ONEMZT = 1.0_wp -ZETA
        C = S(I+1,4)/6.0_wp
        D = S(I,4)*S(I,6)
        L = L + 1
        DEL = ZETA*S(I,1)
        BREAK(L) = TAU(I) + DEL
        ZT2 = ZETA**2
        ALPHA = ALPH(ONEMZT)
        FACTOR = ONEMZT**2*ALPHA
        COEF(1,L) = GTAU(I) + DIVDIF*DEL+S(I,1)**2*(D*ONEMZT*(FACTOR- &
           1.0_wp) + C*ZETA*(ZT2 - 1.0_wp))
        COEF(2,L) = DIVDIF + S(I,1)*(D*(1.0_wp-3.0_wp*FACTOR) + C*(3.0_wp*ZT2- &
           1.0_wp))
        COEF(3,L) = 6.0_wp*(D*ALPHA*ONEMZT + C*ZETA)
        COEF(4,L) = 6.0_wp*(C - D*ALPHA)/S(I,1)
        COEF(4,L-1) = COEF(4,L) -6.0_wp*D*(1.0_wp-ALPHA)/(DEL*ZT2)
        COEF(2,L-1) = COEF(2,L) - DEL*(COEF(3,L)-DEL*0.5_wp*COEF(4,L-1))
        GO TO 68
!
      ELSE IF (Z-0.5_wp .EQ. 0._wp) THEN
!
        COEF(2,L) = DIVDIF - S(I,1)*(2.0_wp*S(I,4) + S(I+1,4))/6.0_wp
        COEF(4,L) = (S(I+1,4) - S(I,4))/S(I,1)
        GO TO 68
!
      ELSE
!
        ONEMZT = GAM*(1.0_wp - Z)
        IF(ONEMZT.EQ.0.0_wp) GO TO 65
        ZETA = 1.0_wp - ONEMZT
        ALPHA = ALPH(ZETA)
        C = S(I+1,4)*S(I,6)
        D = S(I,4)/6.0_wp
        DEL = ZETA*S(I,1)
        BREAK(L+1) = TAU(I) + DEL
        COEF(2,L) = DIVDIF -S(I,1)*(2.0_wp*D + C)
        COEF(4,L) = 6.0_wp*(C*ALPHA - D)/S(I,1)
        L = L + 1
        COEF(4,L) = COEF(4,L-1) + 6.0_wp*(1.0_wp-ALPHA)*C/(S(I,1)*ONEMZT**3)
        COEF(3,L) = COEF(3,L-1) + DEL* COEF(4,L-1)
        COEF(2,L) = COEF(2,L-1) + DEL*(COEF(3,L-1)+DEL*0.5_wp*COEF(4,L-1))
        COEF(1,L) = COEF(1,L-1) + DEL*(COEF(2,L-1)+DEL*0.5_wp*   &
              (COEF(3,L-1) + (DEL/3.0_wp)*COEF(4,L-1)))
        GO TO 68
      ENDIF
!
!
   65 CONTINUE
      COEF(2,L) = DIVDIF
      COEF(3,L) = 0.0_wp
      COEF(4,L) = 0.0_wp
   68 CONTINUE
!
      L = L + 1
      BREAK(L) = TAU(I+1)
   70 CONTINUE

      IFLAG = 0
      RETURN
!
 999  IFLAG = 2

END SUBROUTINE tautsp

!==============================================================================
!==============================================================================

!------------------------------------------------------------------------------

SUBROUTINE tautsp2D (TAU, GTAU, NTAU, NI, IMIN, IMAX, NTAUMAX, GAMMA,       &
                     S, BREAK, COEF, L_VEC, IFLAG)

!------------------------------------------------------------------------------
!
! Description:
!   Computes the tension spline for abscissae TAU(i) and ordinates GTAU(i)
!   (i = 1,...,NTAU), but vectorized over many "columns"
!
! From: Carl DeBoor: A Practical Guide to Splines
!
! Parameters:
!   TAU       Sequence of data points; must be strictly increasing (abscissae)
!   GTAU      Corresponding sequence of function values (ordinates)
!   NTAU      Number of data points; must be at least 4
!
!   NI        Number of columns
!   IMIN,IMAX Start- and end-index of columns
!   NTAUMAX   Maximum over the NTAUs in all columns
!
!   GAMMA     Indicates whether additional flexibility is desired:
!               0   :  no additional knots
!             0<  <3:  Under certain conditions on the given data at points
!                      i-1,i,i+1,i+2, a knot is added in the i-th interval
!                      (i=2,...,NTAU-2).
!             3<  <6:  Same, except that knots might also be added in intervals
!                      in which an inflection point would be permitted
!             The interpolant gets rounded with increasing GAMMA
!
! Output:
!   BREAK,COEF,L,K give the polynomial representation of the interpolant.
!   For BREAK(i) <= X <= BREAK(i+1) the interpolant has the following form:
!
!       F(X)=COEF(1,i)+DX(COEF(2,i)+DX/2(COEF(3,i)+DX/3(COEF(4,i)))
!                        with DX = X-BREAK(i) and i=1,...,L
! Workspace
!   S(NTAU,6)  WORK-ARRAY
!
! Return Codes:
!  IFLAG = 0  No Error
!  IFLAG = 2  Wrong Input
!
! Method:
!
!==============================================================================

INTEGER, INTENT(IN)   :: &
    NI, IMIN, IMAX, NTAUMAX

INTEGER, INTENT(IN)   :: &
    NTAU(NI)

REAL   (KIND=wp),        INTENT(IN)   :: &
    GTAU(NI,NTAUMAX),                    &
    TAU (NI,NTAUMAX),                    &
    GAMMA

REAL   (KIND=wp),        INTENT(OUT)  :: &
    BREAK(NI,*),                         &
    COEF (NI,4,*),                       &
    S    (NI,NTAUMAX,6)

INTEGER, INTENT(OUT)  :: &
    L_VEC(NI),           &
    IFLAG

! Local Variables
INTEGER ::  I,K,L,METHOD, mb_err_indx_i,mb_err_indx_k

REAL(KIND=wp)     C,D,DEL,DENOM,DIVDIF,ENTRY,FACTR2,GAM,      &
                  ONEMG3,SIXTH,TEMP,X,ALPH

REAL(KIND=wp)                         :: &
    RATIO_VEC   (NI),                    &
    Z_VEC       (NI),                    &
    ZETA_VEC    (NI),                    &
    ZT2_VEC     (NI),                    &
    ALPHA_VEC   (NI),                    &
    FACTOR_VEC  (NI),                    &
    ONEMZT_VEC  (NI),                    &
    ENTRY3      (NI)

!==============================================================================
!
   ALPH(X)= MIN (1.0_wp,ONEMG3/X)
!
!   Test of input parameters
!
      mb_err_indx_i = -1
      DO i = IMIN, IMAX
         IF (NTAU(i) .LT. 4) mb_err_indx_i = i
      ENDDO

      IF ( mb_err_indx_i /= -1 ) THEN
        WRITE (*,'(A,2I4,A)') '  NTAU =', NTAU(mb_err_indx_i), mb_err_indx_i, &
                              ':  MUST BE GREATER THAN 4'
        GO TO 999
      ENDIF

!
!   Computation of Delta(TAU) and of 1. and 2. derivation of data
!
      mb_err_indx_i = -1
      mb_err_indx_k = -1

      DO k = 1, NTAUMAX
         DO i = IMIN, IMAX
            IF (k <= NTAU(i)-1) THEN
               S(i,k,1)=TAU(i,k+1)-TAU(i,k)
               IF (S(i,k,1) .LE. 0.0_wp) THEN
                  mb_err_indx_i = i
                  mb_err_indx_k = k
               ELSE
                  S(i,k+1,4) = (GTAU(i,k+1) - GTAU(i,k))/S(i,k,1)
               ENDIF
            ENDIF
         ENDDO

         IF ( mb_err_indx_i /= -1 .OR. mb_err_indx_k /= -1) THEN
            WRITE (*,'(A,2I3,A,2E15.6,A)')                                    &
               ' Point ',mb_err_indx_i, mb_err_indx_k, ' and the following ', &
               TAU(mb_err_indx_i,mb_err_indx_k), TAU(mb_err_indx_i,mb_err_indx_k+1), &
               ' are in the wrong order! '
            GO TO 999
         ENDIF
      ENDDO

      DO k = 1, NTAUMAX
         DO i = IMIN, IMAX
            IF (k >= 2 .AND. k <= NTAU(i)-1) THEN
               S(i,k,4) = S(i,k+1,4) - S(i,k,4)
            ENDIF
         ENDDO
      ENDDO
!
!   Construct system of equations for 2. derivatives at TAU. At each interior
!   data point there is one continuity equation; at the first and the last
!   interior data point there is an additional one for a total of NTAU
!   equations in NTAU unknowns.
!
      DO i = IMIN, IMAX
         S(i,2,2) = S(i,1,1)/3.0_wp
      ENDDO

      SIXTH = 1.0_wp/6.0_wp
      METHOD = 2
      GAM = GAMMA
      IF(GAM .LE. 0.0_wp) METHOD = 1
      IF(GAM .GT. 3.0_wp) THEN
        METHOD = 3
        GAM = GAM - 3.0_wp
      ENDIF
      ONEMG3=1.0_wp - GAM/3.0_wp
!
!   Loops over k (interpolation points) and i (columns)
!
      DO k = 2, NTAUMAX
         DO i = IMIN, IMAX
            IF ( k <= NTAU(i)-2 ) THEN

               Z_VEC(i)=0.5_wp
               IF (METHOD /= 1) THEN
                  IF ( ((METHOD == 2) .AND.                                   &
                    (S(i,k,4)*S(i,k+1,4) >= 0.0_wp)) .OR. (METHOD == 3) ) THEN
                     TEMP = ABS(S(i,k+1,4))
                     DENOM = ABS(S(i,k,4)) + TEMP
                     IF (DENOM /= 0.0_wp) THEN
                        Z_VEC(i) = TEMP/DENOM
                        IF(ABS(Z_VEC(i)-0.5_wp).LE.SIXTH) Z_VEC(i)=0.5_wp
                     ENDIF
                  ENDIF
               ENDIF
               S(i,k,5) = Z_VEC(i)
!
!   Set up part of the k-th equation which depends on the k-th interval
!
               IF (Z_VEC(i)-0.5_wp .LT. 0._wp) THEN
                  ZETA_VEC(i) = GAM*Z_VEC(i)
                  ONEMZT_VEC(i) = 1.0_wp - ZETA_VEC(i)
                  ZT2_VEC(i) = ZETA_VEC(i)**2
                  ALPHA_VEC(i) = ALPH(ONEMZT_VEC(i))
                  FACTOR_VEC(i) = ZETA_VEC(i) /                       &
                                   (ALPHA_VEC(i)*(ZT2_VEC(i) - 1.0_wp) + 1.0_wp)
                  S(i,k,6) = ZETA_VEC(i)*FACTOR_VEC(i)/6.0_wp
                  S(i,k,2) = S(i,k,2) + S(i,k,1) *                  &
                                   ((1.0_wp-ALPHA_VEC(i)*ONEMZT_VEC(i))  &
                                     *FACTOR_VEC(i)*0.5_wp-S(i,k,6))
                  IF(S(i,k,2).LE.0.0_wp) S(i,k,2) = 1.0_wp
                  S(i,k,3) = S(i,k,1)/6.0_wp
!
               ELSE IF (Z_VEC(i)-0.5_wp .EQ. 0._wp) THEN
!
                  S(i,k,2) = S(i,k,2) + S(i,k,1)/3.0_wp
                  S(i,k,3) = S(i,k,1)/6.0_wp
!
               ELSE
!
                  ONEMZT_VEC(i) = GAM*(1.0_wp - Z_VEC(i))
                  ZETA_VEC(i) = 1.0_wp - ONEMZT_VEC(i)
                  ALPHA_VEC(i) = ALPH(ZETA_VEC(i))
                  FACTOR_VEC(i) = ONEMZT_VEC(i) /                    &
                   (1.0_wp - ALPHA_VEC(i)*ZETA_VEC(i)*(1.0_wp + ONEMZT_VEC(i)))
                  S(i,k,6) = ONEMZT_VEC(i)*FACTOR_VEC(i)/6.0_wp
                  S(i,k,2) = S(i,k,2) + S(i,k,1)/3.0_wp
                  S(i,k,3) = S(i,k,6) * S(i,k,1)
               ENDIF
!
               IF (k == 2) THEN
                  S(i,1,5) = 0.5_wp
!
!   The first two equations enforce continuity of the first and of the third
!   derivative across TAU(2)
!
                  S(i,1,2) = S(i,1,1)/6.0_wp
                  S(i,1,3) = S(i,2,2)
                  ENTRY3(i) = S(i,2,3)

                  IF (Z_VEC(i)-0.5_wp .LT. 0._wp) THEN
                     FACTR2 = ZETA_VEC(i)*(ALPHA_VEC(i)                 &
                              *(ZT2_VEC(i)-1.0_wp)+1.0_wp)/                     &
                        (ALPHA_VEC(i)*(ZETA_VEC(i)*ZT2_VEC(i)-1.0_wp) + 1.0_wp)
                     RATIO_VEC(i) = FACTR2*S(i,2,1)/S(i,1,2)
                     S(i,2,2) = FACTR2*S(i,2,1) + S(i,1,1)
                     S(i,2,3) = -FACTR2 * S(i,1,1)
!
                  ELSE IF (Z_VEC(i)-0.5_wp .EQ. 0._wp) THEN
!
                     RATIO_VEC(i) = S(i,2,1)/S(i,1,2)
                     S(i,2,2) = S(i,2,1) + S(i,1,1)
                     S(i,2,3) = -S(i,1,1)
!
                  ELSE
!
                     RATIO_VEC(i) = S(i,2,1)/S(i,1,2)
                     S(i,2,2) = S(i,2,1) + S(i,1,1)
                     S(i,2,3) = -S(i,1,1)*6.0_wp*ALPHA_VEC(i)*S(i,2,6)
                  ENDIF
!
!   At this point the first two equations read
!            DIAG(1)*X1 +    U(1)*X2 + ENTRY3*X3 = R(2)
!     -RATIO*DIAG(1)*X1 + DIAG(2)*X2 +   U(2)*X3 = 0
!   Eliminate first unknown from second equation
!
                  S(i,2,2) = RATIO_VEC(i)*S(i,1,3) + S(i,2,2)
                  S(i,2,3) = RATIO_VEC(i)*ENTRY3(i) + S(i,2,3)
                  S(i,1,4) = S(i,2,4)
                  S(i,2,4) = RATIO_VEC(i)*S(i,1,4)
!

               ELSE ! k > 2
!
                  S(i,k,2) = RATIO_VEC(i)*S(i,k-1,3) + S(i,k,2)
                  S(i,k,4) = RATIO_VEC(i)*S(i,k-1,4) + S(i,k,4)
               ENDIF  ! k == 2
!
!  Set up the part of the next equation which depends on the k-th interval
!
               IF (Z_VEC(i)-0.5_wp .LT. 0._wp) THEN
                  RATIO_VEC(i) = -S(i,k,6)*S(i,k,1)/S(i,k,2)
                  S(i,k+1,2) = S(i,k,1)/3.0_wp
!
               ELSE IF (Z_VEC(i)-0.5_wp .EQ. 0._wp) THEN
!
                  RATIO_VEC(i) = -S(i,k,1)/(6.0_wp*S(i,k,2))
                  S(i,k+1,2) = S(i,k,1)/3.0_wp
!
               ELSE
!
                  RATIO_VEC(i) = -(S(i,k,1)/6.0_wp)/S(i,k,2)
                  S(i,k+1,2)   = S(i,k,1) *                            &
                               ((1.0_wp - ZETA_VEC(i)*ALPHA_VEC(i))*      &
                               0.5_wp*FACTOR_VEC(i)-S(i,k,6))
               ENDIF
!
!   End of Loop over k (interpolation points) and i (columns)
!
            ENDIF ! k <= NTAU(i)-2
         ENDDO ! i = IMIN, IMAX
      ENDDO ! k = 2, NTAUMAX

      DO i = IMIN, IMAX
         k = NTAU(i)-1
         S(i,k,5) = 0.5_wp

!
!   The last two equations enforce continuity of third derivative and of
!   first derivative across TAU (NTAU-1)
!
         ENTRY = RATIO_VEC(i)*S(i,k-1,3) + S(i,k,2) + S(i,k,1)/3.0_wp
         S(i,k+1,2) = S(i,k,1)/6.0_wp
         S(i,k+1,4) = RATIO_VEC(i)*S(i,k-1,4) + S(i,k,4)
         IF (Z_VEC(i)-0.5_wp .LT. 0._wp) THEN
            RATIO_VEC(i) = S(i,k,1) * 6.0_wp * S(i,k-1,6) *              &
                             ALPHA_VEC(i)/S(i,k-1,2)
            S(i,k,2) = RATIO_VEC(i)*S(i,k-1,3) +S(i,k,1) + S(i,k-1,1)
            S(i,k,3) = -S(i,k-1,1)
!
         ELSE IF (Z_VEC(i)-0.5_wp .EQ. 0._wp) THEN
!
            RATIO_VEC(i) = S(i,k,1)/S(i,k-1,2)
            S(i,k,2) = RATIO_VEC(i)*S(i,k-1,3) + S(i,k,1) + S(i,k-1,1)
            S(i,k,3) = -S(i,k-1,1)
!
         ELSE
!
            FACTR2 = ONEMZT_VEC(i) * (ALPHA_VEC(i) *                    &
                            (ONEMZT_VEC(i)**2-1.0_wp)+1.0_wp)  /                &
                            (ALPHA_VEC(i)*(ONEMZT_VEC(i)**3-1.0_wp)+1.0_wp)
            RATIO_VEC(i) = FACTR2*S(i,k,1)/S(i,k-1,2)
            S(i,k,2) = RATIO_VEC(i)*S(i,k-1,3) + FACTR2*S(i,k-1,1)  &
                         + S(i,k,1)
            S(i,k,3) = -FACTR2*S(i,k-1,1)
         ENDIF
!
!  At this point the last two equations read
!           DIAG(k)*Xk +      U(k)*Xk+1 = R(k)
!    -RATIO*DIAG(k)*Xk + DIAG(k+1)*Xk+1 = R(k+1)
!  Eliminate Xk from last equation
!
         S(i,k,4) = RATIO_VEC(i)*S(i,k-1,4)
         RATIO_VEC(i) = -ENTRY/S(i,k,2)
         S(i,k+1,2) = RATIO_VEC(i)*S(i,k,3) + S(i,k+1,2)
         S(i,k+1,4) = RATIO_VEC(i)*S(i,k,4) + S(i,k+1,4)
      ENDDO ! i = IMIN, IMAX

!
!   Back Substitution
!
      DO i = IMIN, IMAX
         S(i,NTAU(i),4) = S(i,NTAU(i),4)/S(i,NTAU(i),2)
      ENDDO

      DO k = NTAUMAX,2,-1
         DO i = IMIN, IMAX
            IF (k <= NTAU(i)-1) THEN
               S(i,k,4) = (S(i,k,4) - S(i,k,3)*S(i,k+1,4))/S(i,k,2)
            ENDIF
         ENDDO
      ENDDO

      DO i = IMIN, IMAX
         S(i,1,4) = (S(i,1,4) - S(i,1,3)*S(i,2,4) -              &
                       ENTRY3(i)*S(i,3,4))/S(i,1,2)
      ENDDO
!
!   Construct polynomial pieces
!
      DO i = IMIN, IMAX
         BREAK(i,1) = TAU(i,1)
         L_VEC(i) = 1
      ENDDO

      DO k = 1, NTAUMAX
         DO i = IMIN, IMAX
            IF ( k <= NTAU(i)-1) THEN
               L = L_VEC(i)
               COEF(i,1,L) = GTAU(i,k)
               COEF(i,3,L) = S(i,k,4)
               DIVDIF = (GTAU(i,k+1) - GTAU(i,k))/S(i,k,1)
               Z_VEC(i) = S(i,k,5)
!
               IF (Z_VEC(i)-0.5_wp .LT. 0._wp) THEN
                  ! US avoid division by 0, if Z_VEC is veeeery small
                  ! by treating it as 0
                  IF(ABS(Z_VEC(i)) < repsilon) THEN
                     COEF(i,2,L) = DIVDIF
                     COEF(i,3,L) = 0.0_wp
                     COEF(i,4,L) = 0.0_wp
                  ELSE
                     ZETA_VEC(i) = GAM*Z_VEC(i)
                     ONEMZT_VEC(i) = 1.0_wp -ZETA_VEC(i)
                     C = S(i,k+1,4)/6.0_wp
                     D = S(i,k,4)*S(i,k,6)
                     L = L + 1
                     DEL = ZETA_VEC(i)*S(i,k,1)
                     BREAK(i,L) = TAU(i,k) + DEL
                     ZT2_VEC(i) = ZETA_VEC(i)**2
!                    ALPHA_VEC(i) = ALPH(ONEMZT_VEC(i))
                     ALPHA_VEC(i) = MIN(1.0_wp,ONEMG3/ONEMZT_VEC(i))
                     FACTOR_VEC(i) = ONEMZT_VEC(i)**2*ALPHA_VEC(i)
                     COEF(i,1,L) = GTAU(i,k) + DIVDIF*DEL +              &
                          S(i,k,1)**2*(D*ONEMZT_VEC(i)*(FACTOR_VEC(i)- &
                             1.0_wp) + C*ZETA_VEC(i)*(ZT2_VEC(i) - 1.0_wp))
                     COEF(i,2,L) = DIVDIF + S(i,k,1) *                   &
                         (D*(1.0_wp-3.0_wp*FACTOR_VEC(i)) + C*(3.0_wp*ZT2_VEC(i)- &
                                    1.0_wp))
                     COEF(i,3,L) = 6.0_wp*(D*ALPHA_VEC(i)*ONEMZT_VEC(i)   &
                                      + C*ZETA_VEC(i))
                     COEF(i,4,L) = 6.0_wp*(C - D*ALPHA_VEC(i))/S(i,k,1)
                     COEF(i,4,L-1) = COEF(i,4,L) -6.0_wp*D*                 &
                                       (1.0_wp-ALPHA_VEC(i))/MAX(DEL*ZT2_VEC(i),repsilon)
                     COEF(i,2,L-1) = COEF(i,2,L) -                       &
                                   DEL*(COEF(i,3,L)-DEL*0.5_wp*COEF(i,4,L-1))
                  ENDIF
!
               ELSE IF (Z_VEC(i)-0.5_wp .EQ. 0._wp) THEN
!
                  COEF(i,2,L) = DIVDIF - S(i,k,1) *                      &
                                  (2.0_wp*S(i,k,4) + S(i,k+1,4))/6.0_wp
                  COEF(i,4,L) = (S(i,k+1,4) - S(i,k,4))/S(i,k,1)
!
               ELSE
!
                  ONEMZT_VEC(i) = GAM*(1.0_wp - Z_VEC(i))
                  IF(ONEMZT_VEC(i).EQ.0.0_wp) THEN
                     COEF(i,2,L) = DIVDIF
                     COEF(i,3,L) = 0.0_wp
                     COEF(i,4,L) = 0.0_wp
                  ELSE
                     ZETA_VEC(i) = 1.0_wp - ONEMZT_VEC(i)
!                    ALPHA_VEC(i) = ALPH(ZETA_VEC(i))
                     ALPHA_VEC(i) = MIN(1.0_wp,ONEMG3/ZETA_VEC(i))
                     C = S(i,k+1,4)*S(i,k,6)
                     D = S(i,k,4)/6.0_wp
                     DEL = ZETA_VEC(i)*S(i,k,1)
                     BREAK(i,L+1) = TAU(i,k) + DEL
                     COEF(i,2,L) = DIVDIF -S(i,k,1)*(2.0_wp*D + C)
                     COEF(i,4,L) = 6.0_wp*(C*ALPHA_VEC(i) - D)/S(i,k,1)
                     L = L + 1
                     COEF(i,4,L) = COEF(i,4,L-1) + 6.0_wp *                 &
                         (1.0_wp-ALPHA_VEC(i))*C/(S(i,k,1)*ONEMZT_VEC(i)**3)
                     COEF(i,3,L) = COEF(i,3,L-1) + DEL* COEF(i,4,L-1)
                     COEF(i,2,L) = COEF(i,2,L-1) + DEL*(COEF(i,3,L-1)  &
                                     +DEL*0.5_wp*COEF(i,4,L-1))
                     COEF(i,1,L) = COEF(i,1,L-1) + DEL*(COEF(i,2,L-1)  &
                                     +DEL*0.5_wp*                               &
                           (COEF(i,3,L-1) + (DEL/3.0_wp)*COEF(i,4,L-1)))
                  ENDIF
               ENDIF
!
               L = L + 1
               BREAK(i,L) = TAU(i,k+1)
               L_VEC(i) = L
            ENDIF
         ENDDO ! i = IMIN, IMAX
      ENDDO ! k = 1, NTAUMAX

      IFLAG = 0

      RETURN
!
 999  IFLAG = 2

END SUBROUTINE tautsp2D

!==============================================================================
!==============================================================================

!------------------------------------------------------------------------------

SUBROUTINE tautsp3D (TAU, GTAU, NTAU, NI, NJ, IMIN, IMAX, JMIN, JMAX, NTAUMAX, &
                     GAMMA, S, BREAK, COEF, L_VEC, IFLAG, LACC)

!------------------------------------------------------------------------------
!
! Description:
!   Computes the tension spline for abscissae TAU(i) and ordinates GTAU(i)
!   (i = 1,...,NTAU), but vectorized over many "columns"
!
! From: Carl DeBoor: A Practical Guide to Splines
!
! Parameters:
!   TAU       Sequence of data points; must be strictly increasing (abscissae)
!   GTAU      Corresponding sequence of function values (ordinates)
!   NTAU      Number of data points; must be at least 4
!
!   NI        Number of columns in X
!   NJ        Number of columns in Y
!   IMIN,IMAX Start- and end-index of columns in X
!   JMIN,JMAX Start- and end-index of columns in Y
!   NTAUMAX   Maximum over the NTAUs in all columns
!
!   GAMMA     Indicates whether additional flexibility is desired:
!               0   :  no additional knots
!             0<  <3:  Under certain conditions on the given data at points
!                      i-1,i,i+1,i+2, a knot is added in the i-th interval
!                      (i=2,...,NTAU-2).
!             3<  <6:  Same, except that knots might also be added in intervals
!                      in which an inflection point would be permitted
!             The interpolant gets rounded with increasing GAMMA
!
!   LACC      If set to true, the routine is run on GPU, otherwise on CPU.
!
! Output:
!   BREAK,COEF,L,K give the polynomial representation of the interpolant.
!   For BREAK(i) <= X <= BREAK(i+1) the interpolant has the following form:
!
!       F(X)=COEF(1,i)+DX(COEF(2,i)+DX/2(COEF(3,i)+DX/3(COEF(4,i)))
!                        with DX = X-BREAK(i) and i=1,...,L
! Workspace
!   S(NTAU,6)  WORK-ARRAY
!
! Return Codes:
!  IFLAG = 0  No Error
!  IFLAG = 2  Wrong Input
!
! Method:
!
!==============================================================================

INTEGER, INTENT(IN)   :: &
    NI, NJ, IMIN, IMAX, JMIN, JMAX, NTAUMAX

INTEGER, INTENT(IN)   :: &
    NTAU(NI,NJ)

REAL   (KIND=wp),        INTENT(IN)   :: &
    GTAU(NI,NJ,NTAUMAX),                 &
    TAU (NI,NJ,NTAUMAX),                 &
    GAMMA

REAL   (KIND=wp),        INTENT(OUT)  :: &
    BREAK(NI,NJ,NTAUMAX*3),              &
    COEF (NI,NJ,4,NTAUMAX*3),            &
    S    (NI,NJ,NTAUMAX,6)

INTEGER, INTENT(OUT)  :: &
    L_VEC(NI,NJ),        &
    IFLAG

LOGICAL, INTENT(IN), OPTIONAL :: &
    LACC

! Local Variables
INTEGER ::  I,J,K,L,METHOD, mb_err_indx_i,mb_err_indx_j,mb_err_indx_k

LOGICAL :: LZACC, L_MB_ERR

REAL(KIND=wp)     C,D,DEL,DENOM,DIVDIF,ENTRY,FACTR2,GAM,      &
                  ONEMG3,SIXTH,TEMP,X,ALPH

REAL(KIND=wp)                         :: &
    RATIO_VEC   (NI,NJ),                 &
    Z_VEC       (NI,NJ),                 &
    ZETA_VEC    (NI,NJ),                 &
    ZT2_VEC     (NI,NJ),                 &
    ALPHA_VEC   (NI,NJ),                 &
    FACTOR_VEC  (NI,NJ),                 &
    ONEMZT_VEC  (NI,NJ),                 &
    ENTRY3      (NI,NJ)

!==============================================================================
!
   ALPH(X)= MIN (1.0_wp,ONEMG3/X)
!
!   Initialize error and GPU flags
!
      IFLAG = 0
!      
      IF (PRESENT(LACC)) THEN
         LZACC = LACC
      ELSE
         LZACC = .FALSE.
      ENDIF

!
!   Test of input parameters
!
      l_mb_err = .FALSE.
      !$acc parallel present(NTAU) if (lzacc)
      !$acc loop gang reduction (.or.:l_mb_err)
      DO j = JMIN, JMAX
         !$acc loop vector reduction (.or.:l_mb_err)
         DO i = IMIN, IMAX
            IF (NTAU(i,j) .LT. 4) l_mb_err = .TRUE.
         ENDDO
      ENDDO
      !$acc end parallel
 
      ! In case an error occurred in the computation above, re-run it to obtain more
      ! information about the error. Storing this information directly in the computation
      ! would require costly reductions on GPU, wherease re-running it doesn't matter in
      ! terms of performance because the model is aborted afterwards anyway.
      IF (l_mb_err) THEN
        !$acc update host (NTAU) if (lzacc)
        mb_err_indx_i = -1
        mb_err_indx_j = -1
        DO j = JMIN, JMAX
           DO i = IMIN, IMAX
              IF (NTAU(i,j) .LT. 4) THEN
                 mb_err_indx_i = i
                 mb_err_indx_j = j
              ENDIF
           ENDDO
        ENDDO
        IF ( mb_err_indx_i /= -1 ) THEN
          WRITE (*,'(A,2I4,A)') '  NTAU =', NTAU(mb_err_indx_i,mb_err_indx_j), &
              mb_err_indx_i, mb_err_indx_j, ':  MUST BE GREATER THAN 4'
          IFLAG = 2
          RETURN
        ENDIF
      ENDIF

!
!   Computation of Delta(TAU) and of 1. and 2. derivation of data
!
      !$acc parallel present(NTAU,S,GTAU,TAU) if (lzacc)
      DO k = 1, NTAUMAX
        !$acc loop gang reduction(.or.:l_mb_err)
        DO j = JMIN, JMAX
         !$acc loop vector reduction(.or.:l_mb_err)
         DO i = IMIN, IMAX            
               IF (k <= NTAU(i,j)-1) THEN
                  S(i,j,k,1)=TAU(i,j,k+1)-TAU(i,j,k)
                  IF (S(i,j,k,1) .LE. 0.0_wp) THEN
                     l_mb_err = .TRUE.
                  ELSE
                     S(i,j,k+1,4) = (GTAU(i,j,k+1) - GTAU(i,j,k))/S(i,j,k,1)
                  ENDIF
               ENDIF
            ENDDO
         ENDDO
      ENDDO
      !$acc end parallel

      ! In case an error occurred in the computation above, re-run it to obtain more
      ! information about the error. Storing this information directly in the computation
      ! would require costly reductions on GPU, wherease re-running it doesn't matter in
      ! terms of performance because the model is aborted afterwards anyway.
      IF (l_mb_err) THEN
         !$acc update host (ntau,s,tau,gtau) if (lzacc)
         mb_err_indx_i = -1
         mb_err_indx_k = -1
         DO k = 1, NTAUMAX
            DO j = JMIN, JMAX
              DO i = IMIN, IMAX
                 IF (k <= NTAU(i,j)-1) THEN
                    S(i,j,k,1)=TAU(i,j,k+1)-TAU(i,j,k)
                    IF (S(i,j,k,1) .LE. 0.0_wp) THEN
                       mb_err_indx_i = i
                       mb_err_indx_j = j
                       mb_err_indx_k = k
                    ELSE
                       S(i,j,k+1,4) = (GTAU(i,j,k+1) - GTAU(i,j,k))/S(i,j,k,1)
                    ENDIF
                 ENDIF
              ENDDO
            ENDDO
            IF (IFLAG .GT. 0) THEN
               WRITE (*,'(A,2I3,A,2E15.6,A)')                            &
                  ' Point ',mb_err_indx_i, mb_err_indx_k, mb_err_indx_j, &
                  ' and the following ',                                 &
                  TAU(mb_err_indx_i,mb_err_indx_j,mb_err_indx_k),        &
                  TAU(mb_err_indx_i,mb_err_indx_j,mb_err_indx_k+1),      &
                  ' are in the wrong order! '
               IFLAG = 2
               RETURN
            ENDIF
          ENDDO
      ENDIF


      !
      !   Enter GPU data region
      !
      !$acc data &
      !$acc present ( ntau,gtau,tau                               ) &
      !$acc present ( break,coef,s,l_vec                          ) &
      !$acc create  ( ratio_vec,z_vec,zeta_vec,zt2_vec,alpha_vec  ) &
      !$acc create  ( factor_vec,onemzt_vec,entry3                ) if (lzacc)

      !$acc parallel if (lzacc)
      DO k = 1, NTAUMAX
         !$acc loop gang
         DO j = JMIN, JMAX
            !$acc loop vector
            DO i = IMIN, IMAX
               IF (k >= 2 .AND. k <= NTAU(i,j)-1) THEN
                  S(i,j,k,4) = S(i,j,k+1,4) - S(i,j,k,4)
               ENDIF
            ENDDO
         ENDDO
      ENDDO
      !$acc end parallel
!
!   Construct system of equations for 2. derivatives at TAU. At each interior
!   data point there is one continuity equation; at the first and the last
!   interior data point there is an additional one for a total of NTAU
!   equations in NTAU unknowns.
!
      !$acc parallel if (lzacc)
      !$acc loop gang
      DO j = JMIN, JMAX
         !$acc loop vector
         DO i = IMIN, IMAX
            S(i,j,2,2) = S(i,j,1,1)/3.0_wp
         ENDDO
      ENDDO
      !$acc end parallel

      SIXTH = 1.0_wp/6.0_wp
      METHOD = 2
      GAM = GAMMA
      IF(GAM .LE. 0.0_wp) METHOD = 1
      IF(GAM .GT. 3.0_wp) THEN
        METHOD = 3
        GAM = GAM - 3.0_wp
      ENDIF
      ONEMG3=1.0_wp - GAM/3.0_wp
!
!   Loops over k (interpolation points) and i (columns)
!
      !$acc parallel if (lzacc)
      DO k = 2, NTAUMAX
         !$acc loop gang
         DO j = JMIN, JMAX
            !$acc loop vector private( temp, denom, factr2 )
            DO i = IMIN, IMAX
               IF ( k <= NTAU(i,j)-2 ) THEN
 
                  Z_VEC(i,j)=0.5_wp
                  IF (METHOD /= 1) THEN
                     IF ( ((METHOD == 2) .AND.                                   &
                       (S(i,j,k,4)*S(i,j,k+1,4) >= 0.0_wp)) .OR. (METHOD == 3) ) THEN
                        TEMP = ABS(S(i,j,k+1,4))
                        DENOM = ABS(S(i,j,k,4)) + TEMP
                        IF (DENOM /= 0.0_wp) THEN
                           Z_VEC(i,j) = TEMP/DENOM
                           IF(ABS(Z_VEC(i,j)-0.5_wp).LE.SIXTH) Z_VEC(i,j)=0.5_wp
                        ENDIF
                     ENDIF
                  ENDIF
                  S(i,j,k,5) = Z_VEC(i,j)
!
!   Set up part of the k-th equation which depends on the k-th interval
!
                  IF (Z_VEC(i,j)-0.5_wp .LT. 0._wp) THEN
                     ZETA_VEC(i,j) = GAM*Z_VEC(i,j)
                     ONEMZT_VEC(i,j) = 1.0_wp - ZETA_VEC(i,j)
                     ZT2_VEC(i,j) = ZETA_VEC(i,j)**2
                     ALPHA_VEC(i,j) = ALPH(ONEMZT_VEC(i,j))
                     FACTOR_VEC(i,j) = ZETA_VEC(i,j) /                       &
                                      (ALPHA_VEC(i,j)*(ZT2_VEC(i,j) - 1.0_wp) + 1.0_wp)
                     S(i,j,k,6) = ZETA_VEC(i,j)*FACTOR_VEC(i,j)/6.0_wp
                     S(i,j,k,2) = S(i,j,k,2) + S(i,j,k,1) *                  &
                                      ((1.0_wp-ALPHA_VEC(i,j)*ONEMZT_VEC(i,j))  &
                                        *FACTOR_VEC(i,j)*0.5_wp-S(i,j,k,6))
                     IF(S(i,j,k,2).LE.0.0_wp) S(i,j,k,2) = 1.0_wp
                     S(i,j,k,3) = S(i,j,k,1)/6.0_wp
!        
                  ELSE IF (Z_VEC(i,j)-0.5_wp .EQ. 0._wp) THEN
!        
                     S(i,j,k,2) = S(i,j,k,2) + S(i,j,k,1)/3.0_wp
                     S(i,j,k,3) = S(i,j,k,1)/6.0_wp
!
                 ELSE
!
                     ONEMZT_VEC(i,j) = GAM*(1.0_wp - Z_VEC(i,j))
                     ZETA_VEC(i,j) = 1.0_wp - ONEMZT_VEC(i,j)
                     ALPHA_VEC(i,j) = ALPH(ZETA_VEC(i,j))
                     FACTOR_VEC(i,j) = ONEMZT_VEC(i,j) /                    &
                      (1.0_wp - ALPHA_VEC(i,j)*ZETA_VEC(i,j)*(1.0_wp + ONEMZT_VEC(i,j)))
                     S(i,j,k,6) = ONEMZT_VEC(i,j)*FACTOR_VEC(i,j)/6.0_wp
                     S(i,j,k,2) = S(i,j,k,2) + S(i,j,k,1)/3.0_wp
                     S(i,j,k,3) = S(i,j,k,6) * S(i,j,k,1)
                  ENDIF
!
                  IF (k == 2) THEN
                     S(i,j,1,5) = 0.5_wp
!
!   The first two equations enforce continuity of the first and of the third
!   derivative across TAU(2)
!
                     S(i,j,1,2) = S(i,j,1,1)/6.0_wp
                     S(i,j,1,3) = S(i,j,2,2)
                     ENTRY3(i,j) = S(i,j,2,3)
       
                     IF (Z_VEC(i,j)-0.5_wp .LT. 0._wp) THEN
                        FACTR2 = ZETA_VEC(i,j)*(ALPHA_VEC(i,j)                 &
                                 *(ZT2_VEC(i,j)-1.0_wp)+1.0_wp)/                     &
                           (ALPHA_VEC(i,j)*(ZETA_VEC(i,j)*ZT2_VEC(i,j)-1.0_wp) + 1.0_wp)
                        RATIO_VEC(i,j) = FACTR2*S(i,j,2,1)/S(i,j,1,2)
                        S(i,j,2,2) = FACTR2*S(i,j,2,1) + S(i,j,1,1)
                        S(i,j,2,3) = -FACTR2 * S(i,j,1,1)
!      
                     ELSE IF (Z_VEC(i,j)-0.5_wp .EQ. 0._wp) THEN
!      
                        RATIO_VEC(i,j) = S(i,j,2,1)/S(i,j,1,2)
                        S(i,j,2,2) = S(i,j,2,1) + S(i,j,1,1)
                        S(i,j,2,3) = -S(i,j,1,1)
!      
                     ELSE
!      
                        RATIO_VEC(i,j) = S(i,j,2,1)/S(i,j,1,2)
                        S(i,j,2,2) = S(i,j,2,1) + S(i,j,1,1)
                        S(i,j,2,3) = -S(i,j,1,1)*6.0_wp*ALPHA_VEC(i,j)*S(i,j,2,6)
                     ENDIF
!
!   At this point the first two equations read
!            DIAG(1)*X1 +    U(1)*X2 + ENTRY3*X3 = R(2)
!     -RATIO*DIAG(1)*X1 + DIAG(2)*X2 +   U(2)*X3 = 0
!   Eliminate first unknown from second equation
!
                     S(i,j,2,2) = RATIO_VEC(i,j)*S(i,j,1,3) + S(i,j,2,2)
                     S(i,j,2,3) = RATIO_VEC(i,j)*ENTRY3(i,j) + S(i,j,2,3)
                     S(i,j,1,4) = S(i,j,2,4)
                     S(i,j,2,4) = RATIO_VEC(i,j)*S(i,j,1,4)
!     
      
                  ELSE ! k > 2
!     
                     S(i,j,k,2) = RATIO_VEC(i,j)*S(i,j,k-1,3) + S(i,j,k,2)
                     S(i,j,k,4) = RATIO_VEC(i,j)*S(i,j,k-1,4) + S(i,j,k,4)
                  ENDIF  ! k == 2
!
!  Set up the part of the next equation which depends on the k-th interval
!
                  IF (Z_VEC(i,j)-0.5_wp .LT. 0._wp) THEN
                     RATIO_VEC(i,j) = -S(i,j,k,6)*S(i,j,k,1)/S(i,j,k,2)
                     S(i,j,k+1,2) = S(i,j,k,1)/3.0_wp
! 
                  ELSE IF (Z_VEC(i,j)-0.5_wp .EQ. 0._wp) THEN
! 
                     RATIO_VEC(i,j) = -S(i,j,k,1)/(6.0_wp*S(i,j,k,2))
                     S(i,j,k+1,2) = S(i,j,k,1)/3.0_wp
! 
                  ELSE
! 
                     RATIO_VEC(i,j) = -(S(i,j,k,1)/6.0_wp)/S(i,j,k,2)
                     S(i,j,k+1,2)   = S(i,j,k,1) *                            &
                                  ((1.0_wp - ZETA_VEC(i,j)*ALPHA_VEC(i,j))*      &
                                  0.5_wp*FACTOR_VEC(i,j)-S(i,j,k,6))
                  ENDIF
!
!   End of Loop over k (interpolation points) and i (columns)
!
               ENDIF ! k <= NTAU(i)-2
            ENDDO ! i = IMIN, IMAX
         ENDDO ! j = JMIN, JMAX
      ENDDO ! k = 2, NTAUMAX
      !$acc end parallel

      !$acc parallel if (lzacc)
      !$acc loop gang
      DO j = JMIN, JMAX
         !$acc loop vector private( factr2 )
         DO i = IMIN, IMAX
            k = NTAU(i,j)-1
            S(i,j,k,5) = 0.5_wp

!
!   The last two equations enforce continuity of third derivative and of
!   first derivative across TAU (NTAU-1)
!
            ENTRY = RATIO_VEC(i,j)*S(i,j,k-1,3) + S(i,j,k,2) + S(i,j,k,1)/3.0_wp
            S(i,j,k+1,2) = S(i,j,k,1)/6.0_wp
            S(i,j,k+1,4) = RATIO_VEC(i,j)*S(i,j,k-1,4) + S(i,j,k,4)
            IF (Z_VEC(i,j)-0.5_wp .LT. 0._wp) THEN
               RATIO_VEC(i,j) = S(i,j,k,1) * 6.0_wp * S(i,j,k-1,6) *              &
                                ALPHA_VEC(i,j)/S(i,j,k-1,2)
               S(i,j,k,2) = RATIO_VEC(i,j)*S(i,j,k-1,3) +S(i,j,k,1) + S(i,j,k-1,1)
               S(i,j,k,3) = -S(i,j,k-1,1)
! 
            ELSE IF (Z_VEC(i,j)-0.5_wp .EQ. 0._wp) THEN
! 
               RATIO_VEC(i,j) = S(i,j,k,1)/S(i,j,k-1,2)
               S(i,j,k,2) = RATIO_VEC(i,j)*S(i,j,k-1,3) + S(i,j,k,1) + S(i,j,k-1,1)
               S(i,j,k,3) = -S(i,j,k-1,1)
! 
            ELSE
! 
               FACTR2 = ONEMZT_VEC(i,j) * (ALPHA_VEC(i,j) *                    &
                               (ONEMZT_VEC(i,j)**2-1.0_wp)+1.0_wp)  /                &
                               (ALPHA_VEC(i,j)*(ONEMZT_VEC(i,j)**3-1.0_wp)+1.0_wp)
               RATIO_VEC(i,j) = FACTR2*S(i,j,k,1)/S(i,j,k-1,2)
               S(i,j,k,2) = RATIO_VEC(i,j)*S(i,j,k-1,3) + FACTR2*S(i,j,k-1,1)  &
                            + S(i,j,k,1)
               S(i,j,k,3) = -FACTR2*S(i,j,k-1,1)
            ENDIF
!
!  At this point the last two equations read
!           DIAG(k)*Xk +      U(k)*Xk+1 = R(k)
!    -RATIO*DIAG(k)*Xk + DIAG(k+1)*Xk+1 = R(k+1)
!  Eliminate Xk from last equation
!
            S(i,j,k,4) = RATIO_VEC(i,j)*S(i,j,k-1,4)
            RATIO_VEC(i,j) = -ENTRY/S(i,j,k,2)
            S(i,j,k+1,2) = RATIO_VEC(i,j)*S(i,j,k,3) + S(i,j,k+1,2)
            S(i,j,k+1,4) = RATIO_VEC(i,j)*S(i,j,k,4) + S(i,j,k+1,4)
        ENDDO ! i = IMIN, IMAX
      ENDDO ! j = JMIN, JMAX
      !$acc end parallel

!
!   Back Substitution
!
      !$acc parallel if (lzacc)
      !$acc loop gang
      DO j = JMIN, JMAX
         !$acc loop vector
         DO i = IMIN, IMAX
            S(i,j,NTAU(i,j),4) = S(i,j,NTAU(i,j),4)/S(i,j,NTAU(i,j),2)
         ENDDO
      ENDDO
      !$acc end parallel

      !$acc parallel if (lzacc)
      !$acc loop seq
      DO k = NTAUMAX,2,-1
         !$acc loop gang
         DO j = JMIN, JMAX
            !$acc loop vector
            DO i = IMIN, IMAX
               IF (k <= NTAU(i,j)-1) THEN
                  S(i,j,k,4) = (S(i,j,k,4) - S(i,j,k,3)*S(i,j,k+1,4))/S(i,j,k,2)
               ENDIF
            ENDDO
         ENDDO
      ENDDO
      !$acc end parallel

      !$acc parallel if (lzacc)
      !$acc loop gang
      DO j = JMIN, JMAX
         !$acc loop vector
         DO i = IMIN, IMAX
            S(i,j,1,4) = (S(i,j,1,4) - S(i,j,1,3)*S(i,j,2,4) -              &
                          ENTRY3(i,j)*S(i,j,3,4))/S(i,j,1,2)
         ENDDO
      ENDDO
      !$acc end parallel
!
!   Construct polynomial pieces
!
      !$acc parallel if (lzacc)
      !$acc loop gang
      DO j = JMIN, JMAX
         !$acc loop vector
         DO i = IMIN, IMAX
            BREAK(i,j,1) = TAU(i,j,1)
            L_VEC(i,j) = 1
         ENDDO
      ENDDO
      !$acc end parallel

      !$acc parallel if (lzacc)
      DO k = 1, NTAUMAX
         !$acc loop gang
         DO j = JMIN, JMAX
            !$acc loop vector private( c, d, del, l, divdif )
            DO i = IMIN, IMAX
               IF ( k <= NTAU(i,j)-1) THEN
                  L = L_VEC(i,j)
                  COEF(i,j,1,L) = GTAU(i,j,k)
                  COEF(i,j,3,L) = S(i,j,k,4)
                  DIVDIF = (GTAU(i,j,k+1) - GTAU(i,j,k))/S(i,j,k,1)
                  Z_VEC(i,j) = S(i,j,k,5)
!         
                  IF (Z_VEC(i,j)-0.5_wp .LT. 0._wp) THEN
                     ! US avoid division by 0, if Z_VEC is veeeery small
                     ! by treating it as 0
                     IF(ABS(Z_VEC(i,j)) < repsilon) THEN
                        COEF(i,j,2,L) = DIVDIF
                        COEF(i,j,3,L) = 0.0_wp
                        COEF(i,j,4,L) = 0.0_wp
                     ELSE
                        ZETA_VEC(i,j) = GAM*Z_VEC(i,j)
                        ONEMZT_VEC(i,j) = 1.0_wp -ZETA_VEC(i,j)
                        C = S(i,j,k+1,4)/6.0_wp
                        D = S(i,j,k,4)*S(i,j,k,6)
                        L = L + 1
                        DEL = ZETA_VEC(i,j)*S(i,j,k,1)
                        BREAK(i,j,L) = TAU(i,j,k) + DEL
                        ZT2_VEC(i,j) = ZETA_VEC(i,j)**2
!                       ALPHA_VEC(i,j) = ALPH(ONEMZT_VEC(i,j))
                        ALPHA_VEC(i,j) = MIN(1.0_wp,ONEMG3/ONEMZT_VEC(i,j))
                        FACTOR_VEC(i,j) = ONEMZT_VEC(i,j)**2*ALPHA_VEC(i,j)
                        COEF(i,j,1,L) = GTAU(i,j,k) + DIVDIF*DEL +              &
                             S(i,j,k,1)**2*(D*ONEMZT_VEC(i,j)*(FACTOR_VEC(i,j)- &
                                1.0_wp) + C*ZETA_VEC(i,j)*(ZT2_VEC(i,j) - 1.0_wp))
                        COEF(i,j,2,L) = DIVDIF + S(i,j,k,1) *                   &
                            (D*(1.0_wp-3.0_wp*FACTOR_VEC(i,j)) + C*(3.0_wp*ZT2_VEC(i,j)- &
                                       1.0_wp))
                        COEF(i,j,3,L) = 6.0_wp*(D*ALPHA_VEC(i,j)*ONEMZT_VEC(i,j)   &
                                         + C*ZETA_VEC(i,j))
                        COEF(i,j,4,L) = 6.0_wp*(C - D*ALPHA_VEC(i,j))/S(i,j,k,1)
                        COEF(i,j,4,L-1) = COEF(i,j,4,L) -6.0_wp*D*                 &
                                          (1.0_wp-ALPHA_VEC(i,j))/MAX(DEL*ZT2_VEC(i,j),repsilon)
                        COEF(i,j,2,L-1) = COEF(i,j,2,L) -                       &
                                      DEL*(COEF(i,j,3,L)-DEL*0.5_wp*COEF(i,j,4,L-1))
                     ENDIF
!         
                  ELSE IF (Z_VEC(i,j)-0.5_wp .EQ. 0._wp) THEN
!         
                     COEF(i,j,2,L) = DIVDIF - S(i,j,k,1) *                      &
                                     (2.0_wp*S(i,j,k,4) + S(i,j,k+1,4))/6.0_wp
                     COEF(i,j,4,L) = (S(i,j,k+1,4) - S(i,j,k,4))/S(i,j,k,1)
!         
                  ELSE
!         
                     ONEMZT_VEC(i,j) = GAM*(1.0_wp - Z_VEC(i,j))
                     IF(ONEMZT_VEC(i,j).EQ.0.0_wp) THEN
                        COEF(i,j,2,L) = DIVDIF
                        COEF(i,j,3,L) = 0.0_wp
                        COEF(i,j,4,L) = 0.0_wp
                     ELSE
                        ZETA_VEC(i,j) = 1.0_wp - ONEMZT_VEC(i,j)
!                       ALPHA_VEC(i,j) = ALPH(ZETA_VEC(i,j))
                        ALPHA_VEC(i,j) = MIN(1.0_wp,ONEMG3/ZETA_VEC(i,j))
                        C = S(i,j,k+1,4)*S(i,j,k,6)
                        D = S(i,j,k,4)/6.0_wp
                        DEL = ZETA_VEC(i,j)*S(i,j,k,1)
                        BREAK(i,j,L+1) = TAU(i,j,k) + DEL
                        COEF(i,j,2,L) = DIVDIF -S(i,j,k,1)*(2.0_wp*D + C)
                        COEF(i,j,4,L) = 6.0_wp*(C*ALPHA_VEC(i,j) - D)/S(i,j,k,1)
                        L = L + 1
                        COEF(i,j,4,L) = COEF(i,j,4,L-1) + 6.0_wp *                 &
                            (1.0_wp-ALPHA_VEC(i,j))*C/(S(i,j,k,1)*ONEMZT_VEC(i,j)**3)
                        COEF(i,j,3,L) = COEF(i,j,3,L-1) + DEL* COEF(i,j,4,L-1)
                        COEF(i,j,2,L) = COEF(i,j,2,L-1) + DEL*(COEF(i,j,3,L-1)  &
                                        +DEL*0.5_wp*COEF(i,j,4,L-1))
                        COEF(i,j,1,L) = COEF(i,j,1,L-1) + DEL*(COEF(i,j,2,L-1)  &
                                        +DEL*0.5_wp*                               &
                              (COEF(i,j,3,L-1) + (DEL/3.0_wp)*COEF(i,j,4,L-1)))
                     ENDIF
                  ENDIF
!         
                  L = L + 1
                  BREAK(i,j,L) = TAU(i,j,k+1)
                  L_VEC(i,j) = L
               ENDIF
            ENDDO ! i = IMIN, IMAX
         ENDDO ! j = JMIN, JMAX
      ENDDO ! k = 1, NTAUMAX
      !$acc end parallel

      !$acc end data

END SUBROUTINE tautsp3D

!==============================================================================
!==============================================================================

!------------------------------------------------------------------------------

SUBROUTINE to_upper ( string )

!-------------------------------------------------------------------------------
!
! Description:
!   Convert alphabetic characters in 'string' from lower to upper case
!-------------------------------------------------------------------------------

  IMPLICIT NONE

! Subroutine arguments:
! --------------------
  CHARACTER (LEN=*), INTENT(INOUT) :: string

! Local parameters:
! ----------------
  CHARACTER (LEN=26), PARAMETER :: UPPER="ABCDEFGHIJKLMNOPQRSTUVWXYZ"
  CHARACTER (LEN=26), PARAMETER :: lower="abcdefghijklmnopqrstuvwxyz"

! Local variables:
! ---------------
  INTEGER                       :: i, j
!
!------------ End of header ----------------------------------------------------

  DO i = 1, LEN_TRIM(string)
    j = INDEX ( lower, string(i:i) )
    IF ( j > 0 ) string(i:i) = UPPER(j:j)
  END DO

END SUBROUTINE to_upper


!==============================================================================
!==============================================================================
! SUBROUTINE sortrx for 4 byte and 8 byte integer
!------------------------------------------------------------------------------
!
! Description:
!
!   This routine performs an in-memory sort of the first 'nn' elements of
!   array 'idata', returning into array 'iindex' the indices of elements of
!   'idata' arranged in ascending order.  Thus,
!     - 'idata(iindex(1 ))' will be the smallest number in array 'idata';
!     - 'idata(iindex(nn))' will be the largest  number in array 'idata'.
!   The original data is not physically rearranged.  The original order of
!   equal input values is preserved.
!
! Method:
!   'sortrx' uses a hybrid QuickSort algorithm, based on several suggestions in
!   Knuth, Volume 3, Section 5.2.2.  In particular, the "pivot key" [my term]
!   for dividing each subsequence is chosen to be the median of the first,
!   last, and middle values of the subsequence; and the QuickSort is cut off
!   when a subsequence has 9 or fewer elements, and a straight insertion sort
!   of the entire array is done at the end.
!   The result is comparable to a pure insertion sort for very short arrays,
!   and very fast for very large arrays. It is also not subject to the poor
!   performance of the pure QuickSort on partially ordered data.
!
! Created:  15 Jul 1986  Leonard J. Moss of SLAC
! Modified: 27 Apr 2009  Christoph Schraff of DWD:
!                        Preserve the original order of equal input values.
! Modified: 08 May 2011  Christoph Schraff of DWD:
!                        Translated from F77 into free format F90.
!------------------------------------------------------------------------------

!------------------------------------------------------------------------------

SUBROUTINE sortrx4 ( nn, idata, iindex )

!------------------------------------------------------------------------------

! Subroutine arguments:
! --------------------
 
  INTEGER          , INTENT(IN)    ::  nn          ! length of 'data'
  INTEGER (KIND=i4), INTENT(IN)    ::  idata (nn)  ! array to be sorted
  INTEGER          , INTENT(INOUT) ::  iindex (nn) ! indices for 'idata'

! Local parameters:
! ----------------

  INTEGER , PARAMETER  :: &
    mqcut  =  9    ! QuickSort Cutoff: QuickSort is quit when a subsequence
                   !      contains 'mqcut' or fewer elements and finish off
                   !      at end with straight insertion sort.  According to
                   !      Knuth, V.3, the optimum value of 'mqcut' is around 9.

! Local variables:
! ---------------

  INTEGER (KIND=i4) ::  datap  ! value of pivot element
  INTEGER           ::  &
    jl_stack (31)      ,& ! first index of 'data' which belongs to current stack
    jr_stack (31)      ,& ! last  index of 'data' which belongs to current stack
    i_stack            ,& ! index of current stack
    indexp             ,& ! index of pivot element
    indext             ,& ! temporary index value
    ill, irr, ii, jj, ipp
 
!------------------------------------------------------------------------------
! Begin subroutine sortrx4
!------------------------------------------------------------------------------
 
  ! Make initial guess for 'iindex'
 
  DO ii = 1 , nn
    iindex(ii) = ii
  ENDDO
 
  ! for short arrays, skip QuickSort and go directly to straight insertion sort

  IF (nn > mqcut) THEN

!------------------------------------------------------------------------------
! Section 1:  QuickSort
!             ---------
!             The "Qn:"s correspond roughly to steps in Algorithm Q,
!             Knuth, V.3, PP.116-117, modified to select the median of the
!             first, last, and middle elements as the "pivot key" (in Knuth's
!             notation, "K").  Also modified to leave data in place and produce
!             an 'iindex' array.
!             To simplify comments, let 'idata[ii] = idata(iindex(ii))'.
!------------------------------------------------------------------------------
 
    ! Initialize
    i_stack = 0
    ill     = 1
    irr     = nn

    quicksort : DO
 
      ! Q2: Sort the subsequence idata[ill]...idata[irr].
      !
      !     At this point, idata[l] <= idata[m] <= idata[r] for all l < ill,
      !     r > irr, and ill <= m <= irr.
      !     (First time through, there is no idata for l < ill or r > irr.)
 
      ii = ill
      jj = irr

      ! Q2.5: Select pivot key
      !
      !     Let the pivot, 'ipp', be the midpoint of this subsequence,
      !     'ipp=(ill+irr)/2';
      !     then rearrange 'iindex(ill)', 'iindex(ipp)', and 'iindex(irr)'
      !     so the corresponding 'idata' values are in increasing order.
      !     The pivot key, 'datap', is then 'idata[ipp]'.
 
      ipp    = (ill+irr)/2
      indexp = iindex(ipp)
      datap  = idata(indexp)
 
      IF (idata(iindex(ill)) > datap) THEN
        iindex(ipp) = iindex(ill)
        iindex(ill) = indexp
        indexp      = iindex(ipp)
        datap       = idata(indexp)
      ENDIF
 
      IF (datap > idata(iindex(irr))) THEN
        IF (idata(iindex(ill)) > idata(iindex(irr))) THEN
          iindex(ipp) = iindex(ill)
          iindex(ill) = iindex(irr)
        ELSE
          iindex(ipp) = iindex(irr)
        ENDIF
        iindex(irr) = indexp
        indexp      = iindex(ipp)
        datap       = idata(indexp)
      ENDIF
 
      !     Now we swap values between the right and left sides and/or
      !     move 'datap' until all smaller values are on the left and all
      !     larger values are on the right.  Neither the left or right
      !     side will be internally ordered yet; however, 'datap' will be
      !     in its final position.
 
      ! Q5: Have the two scans collided?
      DO WHILE (ii < jj)
 
        ! Q3: Search for datum on left >= 'datap'
        !
        !     At this point, 'idata[ill] <= datap'.  We can therefore start
        !     scanning up from 'ill', looking for a value >= 'datap'
        !     (this scan is guaranteed to terminate since we initially
        !      placed 'datap' near the middle of the subsequence).
        ii = ii + 1
        DO WHILE (idata(iindex(ii)) < datap)
          ii = ii + 1
        ENDDO
 
        ! Q4: Search for datum on right <= 'datap'
        !
        !     At this point, 'idata[irr] >= datap'.  We can therefore start
        !     scanning down from 'irr', looking for a value <= 'datap'
        !     (this scan is guaranteed to terminate since we initially
        !      placed 'datap' near the middle of the subsequence).
        jj = jj - 1
        DO WHILE (idata(iindex(jj)) > datap)
          jj = jj - 1
        ENDDO
 
        ! Q5: If the two scans have not collided,
        !     then interchange data[ii] <--> data[jj] and continue
        IF (ii < jj) THEN
          indext     = iindex(ii)
          iindex(ii) = iindex(jj)
          iindex(jj) = indext
        ENDIF
      ENDDO
 
      ! Q7: select next subsequence to sort
      !
      !     At this point, 'ii >= jj' ,
      !     'idata[l] <= idata[ii] == datap <= idata[r]',
      !     for all 'ill <= l < ii' and 'jj < r <= irr'.
      !     If both subsequences are more than 'mqcut' elements long, push
      !     the longer one on the stack and go back to QuickSort the shorter;
      !     if only one is '> mqcut' elements long, go back and QuickSort it;
      !     otherwise, pop a subsequence off the stack and QuickSort it.
      IF (    (irr-jj >= ii-ill) .AND. (ii-ill > mqcut)) THEN
        i_stack = i_stack+1
        jl_stack(i_stack) = jj + 1
        jr_stack(i_stack) = irr
        irr = ii - 1
      ELSEIF ((ii-ill >  irr-jj) .AND. (irr-jj > mqcut)) THEN
        i_stack = i_stack+1
        jl_stack(i_stack) = ill
        jr_stack(i_stack) = ii - 1
        ill = jj + 1
      ELSEIF (irr-jj > mqcut) THEN
        ill = jj + 1
      ELSEIF (ii-ill > mqcut) THEN
        irr = ii - 1
      ELSE
        ! Q8: Pop the stack, or terminate QuickSort if empty
        IF (i_stack < 1)                                         EXIT quicksort
        ill = jl_stack(i_stack)
        irr = jr_stack(i_stack)
        i_stack = i_stack - 1
      ENDIF

    ENDDO quicksort
  ENDIF
 
!------------------------------------------------------------------------------
! Section 2:  Straight Insertion sort
!------------------------------------------------------------------------------
 
  DO ii = 2 , nn
    IF (     (       idata(iindex(ii-1)) >  idata(iindex(ii)) )               &
        .OR. (      (idata(iindex(ii-1)) == idata(iindex(ii)))                &
              .AND. (      iindex(ii-1)  >        iindex(ii) ))) THEN
      indexp = iindex(ii)
      datap  = idata(indexp)
      ipp = ii - 1
      DO
        iindex(ipp+1) = iindex(ipp)
        ipp = ipp - 1
        IF (ipp > 0) THEN
          IF (     (       idata(iindex(ipp)) >  datap  )                     &
              .OR. (      (idata(iindex(ipp)) == datap )                      &
                    .AND. (      iindex(ipp)  >  indexp)))                CYCLE
        ENDIF
        EXIT
      ENDDO
      iindex(ipp+1) = indexp
    ENDIF
  ENDDO
 
!------------------------------------------------------------------------------

END SUBROUTINE sortrx4

!------------------------------------------------------------------------------
!------------------------------------------------------------------------------

SUBROUTINE sortrx8 ( nn, idata, iindex )

!------------------------------------------------------------------------------

! Subroutine arguments:
! --------------------

  INTEGER , INTENT(IN)          ::  nn          ! length of 'data'
  INTEGER (KIND=i8), INTENT(IN) ::  idata (nn)  ! array to be sorted
  INTEGER , INTENT(INOUT)       ::  iindex (nn) ! indices for 'idata'

! Local parameters:
! ----------------

  INTEGER , PARAMETER  :: &
    mqcut  =  9    ! QuickSort Cutoff: QuickSort is quit when a subsequence
                   !      contains 'mqcut' or fewer elements and finish off
                   !      at end with straight insertion sort.  According to
                   !      Knuth, V.3, the optimum value of 'mqcut' is around 9.

! Local variables:
! ---------------

  INTEGER (KIND=i8) ::  datap  ! value of pivot element
  INTEGER           ::  &
    jl_stack (31)      ,& ! first index of 'data' which belongs to current stack
    jr_stack (31)      ,& ! last  index of 'data' which belongs to current stack
    i_stack            ,& ! index of current stack
    indexp             ,& ! index of pivot element
    indext             ,& ! temporary index value
    ill, irr, ii, jj, ipp

!------------------------------------------------------------------------------
! Begin subroutine sortrx8
!------------------------------------------------------------------------------
 
  ! Make initial guess for 'iindex'
 
  DO ii = 1 , nn
    iindex(ii) = ii
  ENDDO
 
  ! for short arrays, skip QuickSort and go directly to straight insertion sort

  IF (nn > mqcut) THEN

!------------------------------------------------------------------------------
! Section 1:  QuickSort
!             ---------
!             The "Qn:"s correspond roughly to steps in Algorithm Q,
!             Knuth, V.3, PP.116-117, modified to select the median of the
!             first, last, and middle elements as the "pivot key" (in Knuth's
!             notation, "K").  Also modified to leave data in place and produce
!             an 'iindex' array.
!             To simplify comments, let 'idata[ii] = idata(iindex(ii))'.
!------------------------------------------------------------------------------
 
    ! Initialize
    i_stack = 0
    ill     = 1
    irr     = nn

    quicksort : DO
 
      ! Q2: Sort the subsequence idata[ill]...idata[irr].
      !
      !     At this point, idata[l] <= idata[m] <= idata[r] for all l < ill,
      !     r > irr, and ill <= m <= irr.
      !     (First time through, there is no idata for l < ill or r > irr.)
 
      ii = ill
      jj = irr

      ! Q2.5: Select pivot key
      !
      !     Let the pivot, 'ipp', be the midpoint of this subsequence,
      !     'ipp=(ill+irr)/2';
      !     then rearrange 'iindex(ill)', 'iindex(ipp)', and 'iindex(irr)'
      !     so the corresponding 'idata' values are in increasing order.
      !     The pivot key, 'datap', is then 'idata[ipp]'.
 
      ipp    = (ill+irr)/2
      indexp = iindex(ipp)
      datap  = idata(indexp)
 
      IF (idata(iindex(ill)) > datap) THEN
        iindex(ipp) = iindex(ill)
        iindex(ill) = indexp
        indexp      = iindex(ipp)
        datap       = idata(indexp)
      ENDIF
 
      IF (datap > idata(iindex(irr))) THEN
        IF (idata(iindex(ill)) > idata(iindex(irr))) THEN
          iindex(ipp) = iindex(ill)
          iindex(ill) = iindex(irr)
        ELSE
          iindex(ipp) = iindex(irr)
        ENDIF
        iindex(irr) = indexp
        indexp      = iindex(ipp)
        datap       = idata(indexp)
      ENDIF
 
      !     Now we swap values between the right and left sides and/or
      !     move 'datap' until all smaller values are on the left and all
      !     larger values are on the right.  Neither the left or right
      !     side will be internally ordered yet; however, 'datap' will be
      !     in its final position.
 
      ! Q5: Have the two scans collided?
      DO WHILE (ii < jj)
 
        ! Q3: Search for datum on left >= 'datap'
        !
        !     At this point, 'idata[ill] <= datap'.  We can therefore start
        !     scanning up from 'ill', looking for a value >= 'datap'
        !     (this scan is guaranteed to terminate since we initially
        !      placed 'datap' near the middle of the subsequence).
        ii = ii + 1
        DO WHILE (idata(iindex(ii)) < datap)
          ii = ii + 1
        ENDDO
 
        ! Q4: Search for datum on right <= 'datap'
        !
        !     At this point, 'idata[irr] >= datap'.  We can therefore start
        !     scanning down from 'irr', looking for a value <= 'datap'
        !     (this scan is guaranteed to terminate since we initially
        !      placed 'datap' near the middle of the subsequence).
        jj = jj - 1
        DO WHILE (idata(iindex(jj)) > datap)
          jj = jj - 1
        ENDDO
 
        ! Q5: If the two scans have not collided,
        !     then interchange data[ii] <--> data[jj] and continue
        IF (ii < jj) THEN
          indext     = iindex(ii)
          iindex(ii) = iindex(jj)
          iindex(jj) = indext
        ENDIF
      ENDDO
 
      ! Q7: select next subsequence to sort
      !
      !     At this point, 'ii >= jj' ,
      !     'idata[l] <= idata[ii] == datap <= idata[r]',
      !     for all 'ill <= l < ii' and 'jj < r <= irr'.
      !     If both subsequences are more than 'mqcut' elements long, push
      !     the longer one on the stack and go back to QuickSort the shorter;
      !     if only one is '> mqcut' elements long, go back and QuickSort it;
      !     otherwise, pop a subsequence off the stack and QuickSort it.
      IF (    (irr-jj >= ii-ill) .AND. (ii-ill > mqcut)) THEN
        i_stack = i_stack+1
        jl_stack(i_stack) = jj + 1
        jr_stack(i_stack) = irr
        irr = ii - 1
      ELSEIF ((ii-ill >  irr-jj) .AND. (irr-jj > mqcut)) THEN
        i_stack = i_stack+1
        jl_stack(i_stack) = ill
        jr_stack(i_stack) = ii - 1
        ill = jj + 1
      ELSEIF (irr-jj > mqcut) THEN
        ill = jj + 1
      ELSEIF (ii-ill > mqcut) THEN
        irr = ii - 1
      ELSE
        ! Q8: Pop the stack, or terminate QuickSort if empty
        IF (i_stack < 1)                                         EXIT quicksort
        ill = jl_stack(i_stack)
        irr = jr_stack(i_stack)
        i_stack = i_stack - 1
      ENDIF

    ENDDO quicksort
  ENDIF
 
!------------------------------------------------------------------------------
! Section 2:  Straight Insertion sort
!------------------------------------------------------------------------------
 
  DO ii = 2 , nn
    IF (     (       idata(iindex(ii-1)) >  idata(iindex(ii)) )               &
        .OR. (      (idata(iindex(ii-1)) == idata(iindex(ii)))                &
              .AND. (      iindex(ii-1)  >        iindex(ii) ))) THEN
      indexp = iindex(ii)
      datap  = idata(indexp)
      ipp = ii - 1
      DO
        iindex(ipp+1) = iindex(ipp)
        ipp = ipp - 1
        IF (ipp > 0) THEN
          IF (     (       idata(iindex(ipp)) >  datap  )                     &
              .OR. (      (idata(iindex(ipp)) == datap )                      &
                    .AND. (      iindex(ipp)  >  indexp)))                CYCLE
        ENDIF
        EXIT
      ENDDO
      iindex(ipp+1) = indexp
    ENDIF
  ENDDO
 
!------------------------------------------------------------------------------

END SUBROUTINE sortrx8

!==============================================================================
!==============================================================================

!------------------------------------------------------------------------------

SUBROUTINE uvrot2uv (urot, vrot, rlat, rlon, pollat, pollon, u, v)


!------------------------------------------------------------------------------
!
! Description:
!   This routine converts the wind components u and v from the rotated system
!   to the real geographical system.
!
! Method:
!   Transformation formulas for converting between these two systems.
!
!------------------------------------------------------------------------------

! Parameter list:
REAL (KIND=wp),     INTENT (IN)          ::    &
  urot, vrot,     & ! wind components in the rotated grid
  rlat, rlon,     & ! latitude and longitude in the true geographical system
  pollat, pollon    ! latitude and longitude of the north pole of the
                    ! rotated grid

REAL (KIND=wp),     INTENT (OUT)         ::    &
  u, v              ! wind components in the true geographical system

! Local variables

REAL (KIND=wp)                           ::    &
  zsinpol, zcospol, zlonp, zlat, zarg1, zarg2, znorm

! added PARAMETER attribute to enable inlining and vectorization
! (otherwise zrpi18 / zpir18 get an implicit "SAVE" attribute which hinders inlining!)
REAL (KIND=wp),     PARAMETER   ::    &
  zrpi18 = 57.2957795_wp,             & !
  zpir18 = 0.0174532925_wp

!------------------------------------------------------------------------------
! Begin subroutine uvrot2uv
!------------------------------------------------------------------------------

! Converting from degree to radians
  zsinpol = SIN(pollat * zpir18)
  zcospol = COS(pollat * zpir18)
  zlonp   = (pollon-rlon) * zpir18
  zlat    =         rlat  * zpir18

  zarg1   = zcospol*SIN(zlonp)
  zarg2   = zsinpol*COS(zlat) - zcospol*SIN(zlat)*COS(zlonp)
  znorm   = 1.0_wp/SQRT(zarg1**2 + zarg2**2)

! Convert the u- and v-components
  u       =   urot*zarg2*znorm + vrot*zarg1*znorm
  v       = - urot*zarg1*znorm + vrot*zarg2*znorm

END SUBROUTINE uvrot2uv

!==============================================================================
!==============================================================================

!------------------------------------------------------------------------------

SUBROUTINE uvrot2uv_vec(u, v, rlat, rlon, pollat, pollon, idim, jdim)

!------------------------------------------------------------------------------
!
! Description:
!   This routine converts the wind components u and v from the rotated
!   system to the real geographical system. This is the vectorized form
!   of the routine above, i.e. the computation is for a whole 2D field.
!
! Method:
!   Transformation formulas for converting between these two systems.
!
!------------------------------------------------------------------------------

!------------------------------------------------------------------------------
! Parameter list:
INTEGER       , INTENT(IN)     ::    &
  idim, jdim        ! dimensions of the field

REAL (KIND=wp), INTENT (INOUT) ::    &
  u  (idim,jdim), & ! wind components in the true geographical system
  v  (idim,jdim)    !

REAL (KIND=wp), INTENT (IN)    ::    &
  rlat(idim,jdim),& ! coordinates in the true geographical system
  rlon(idim,jdim),& !
  pollat, pollon    ! latitude and longitude of the north pole of the
                    ! rotated grid

! Local variables
REAL (KIND=wp)                 ::    &
  zsinpol, zcospol, zlonp, zlat, zarg1, zarg2, znorm, zugeo, zvgeo

INTEGER                        ::    i, j

! added PARAMETER attribute to enable inlining and vectorization
! (otherwise zrpi18 / zpir18 get an implicit "SAVE" attribute which hinders inlining!)
REAL (KIND=wp),     PARAMETER            ::    &
  zrpi18 = 57.2957795_wp,                      & !
  zpir18 = 0.0174532925_wp

!------------------------------------------------------------------------------
! Begin Subroutine uvrot2uv_vec
!------------------------------------------------------------------------------

!$acc data present(u, v, rlat, rlon)

! Converting from degree to radians
  zsinpol = SIN(pollat * zpir18)
  zcospol = COS(pollat * zpir18)

  !$acc parallel
  !$acc loop gang
  DO j = 1, jdim
    !$acc loop vector private (zlonp, zlat, zarg1, zarg2, znorm, zugeo, zvgeo)
    DO i = 1, idim

      zlonp   = (pollon-rlon(i,j)) * zpir18
      zlat    =         rlat(i,j)  * zpir18

      zarg1   = zcospol*SIN(zlonp)
      zarg2   = zsinpol*COS(zlat) - zcospol*SIN(zlat)*COS(zlonp)
      znorm   = 1.0_wp/SQRT(zarg1**2 + zarg2**2)

      ! Convert the u- and v-components
      zugeo   =  u(i,j)*zarg2*znorm + v(i,j)*zarg1*znorm
      zvgeo   = -u(i,j)*zarg1*znorm + v(i,j)*zarg2*znorm
      u(i,j) = zugeo
      v(i,j) = zvgeo

    ENDDO
  ENDDO
  !$acc end parallel

!$acc end data

END SUBROUTINE uvrot2uv_vec

!==============================================================================
!==============================================================================

!------------------------------------------------------------------------------

SUBROUTINE uv2uvrot(u, v, rlat, rlon, pollat, pollon, urot, vrot)

!------------------------------------------------------------------------------
!
! Description:
!   This routine converts the wind components u and v from the real
!   geographical system to the rotated system.
!
! Method:
!   Transformation formulas for converting between these two systems.
!
!------------------------------------------------------------------------------

!------------------------------------------------------------------------------
! Parameter list:
REAL (KIND=wp),     INTENT (IN)          ::    &
  u   , v   ,     & ! wind components in the true geographical system
  rlat, rlon,     & ! coordinates in the true geographical system
  pollat, pollon    ! latitude and longitude of the north pole of the
                    ! rotated grid

REAL (KIND=wp),     INTENT (OUT)         ::    &
  urot, vrot        ! wind components in the rotated grid

! Local variables

REAL (KIND=wp)                           ::    &
  zsinpol, zcospol, zlonp, zlat, zarg1, zarg2, znorm

! added PARAMETER attribute to enable inlining and vectorization
! (otherwise zrpi18 / zpir18 get an implicit "SAVE" attribute which hinders inlining!)
REAL (KIND=wp),     PARAMETER            ::    &
  zrpi18 = 57.2957795_wp,                      & !
  zpir18 = 0.0174532925_wp

!------------------------------------------------------------------------------
! Begin Subroutine uv2uvrot
!------------------------------------------------------------------------------

  zsinpol = SIN(pollat * zpir18)
  zcospol = COS(pollat * zpir18)
  zlonp   = (pollon-rlon) * zpir18
  zlat    =         rlat  * zpir18

  zarg1   = zcospol*SIN(zlonp)
  zarg2   = zsinpol*COS(zlat) - zcospol*SIN(zlat)*COS(zlonp)
  znorm   = 1.0_wp/SQRT( zarg1**2 + zarg2**2 )

! Transform the u and v wind components
  urot   =  u*zarg2*znorm - v*zarg1*znorm
  vrot   =  u*zarg1*znorm + v*zarg2*znorm

END SUBROUTINE uv2uvrot

!==============================================================================
!==============================================================================

!------------------------------------------------------------------------------

SUBROUTINE uv2uvrot_vec(u, v, rlat, rlon, pollat, pollon, idim, jdim)

!------------------------------------------------------------------------------
!
! Description:
!   This routine converts the wind components u and v from the real
!   geographical system to the rotated system. This is the vectorized form
!   of the routine above, i.e. the computation is for a whole 2D field.
!
! Method:
!   Transformation formulas for converting between these two systems.
!
!------------------------------------------------------------------------------

!------------------------------------------------------------------------------
! Parameter list:
INTEGER       , INTENT(IN)           ::    &
  idim, jdim        ! dimensions of the field

REAL (KIND=wp), INTENT (INOUT)       ::    &
  u  (idim,jdim), & ! wind components in the true geographical system
  v  (idim,jdim)    !

REAL (KIND=wp), INTENT (IN)          ::    &
  rlat(idim,jdim),& ! coordinates in the true geographical system
  rlon(idim,jdim),& !
  pollat, pollon    ! latitude and longitude of the north pole of the
                    ! rotated grid

! Local variables
REAL (KIND=wp)                           ::    &
  zsinpol, zcospol, zlonp, zlat, zarg1, zarg2, znorm, zurot, zvrot

INTEGER                                  ::    i, j

! added PARAMETER attribute to enable inlining and vectorization
! (otherwise zrpi18 / zpir18 get an implicit "SAVE" attribute which hinders inlining!)
REAL (KIND=wp),     PARAMETER            ::    &
  zrpi18 = 57.2957795_wp,                      & !
  zpir18 = 0.0174532925_wp

!------------------------------------------------------------------------------
! Begin Subroutine uv2uvrot_vec
!------------------------------------------------------------------------------

  zsinpol = SIN ( pollat * zpir18 )
  zcospol = COS ( pollat * zpir18 )

  DO j = 1, jdim
    DO i = 1, idim

      zlonp   = ( pollon - rlon(i,j) ) * zpir18
      zlat    =            rlat(i,j)   * zpir18

      zarg1   = zcospol*SIN(zlonp)
      zarg2   = zsinpol*COS(zlat) - zcospol*SIN(zlat)*COS(zlonp)
      znorm   = 1.0_wp/SQRT( zarg1**2 + zarg2**2 )

      ! Transform the u and v wind components
      zurot =  u(i,j)*zarg2*znorm - v(i,j)*zarg1*znorm
      zvrot =  u(i,j)*zarg1*znorm + v(i,j)*zarg2*znorm
      u(i,j) = zurot
      v(i,j) = zvrot

    ENDDO
  ENDDO

END SUBROUTINE uv2uvrot_vec

!==============================================================================
!==============================================================================

!------------------------------------------------------------------------------

SUBROUTINE uv2df (u, v, d, f)
!$acc routine seq 
!------------------------------------------------------------------------------
!
! Description:
!   This routine computes wind speed and wind direction from the wind
!   components.
!
! Method:
!   Straightforward.
!
!------------------------------------------------------------------------------
!

IMPLICIT NONE

! Parameter list:
REAL (KIND=wp),     INTENT (IN)          ::    &
  u   , v           ! wind components in the true geographical system

REAL (KIND=wp),     INTENT (OUT)         ::    &
  f   , d           ! wind speed and wind direction

! Local variables

! added PARAMETER attribute to enable inlining and vectorization
! (otherwise zrpi18 / zpir18 get an implicit "SAVE" attribute which hinders inlining!)
REAL (KIND=wp),     PARAMETER            ::    &
  zrpi18 = 57.2957795_wp,                      & ! conversion from radians to degrees
  zsmall = 0.001_wp

!------------------------------------------------------------------------------
! Begin Subroutine uv2df
!------------------------------------------------------------------------------

  IF (ABS(u) > zsmall) THEN
    f  =  SQRT( u*u + v*v )
    d  =  v / u
    d  =  180.0_wp + SIGN( 90.0_wp , u ) - ATAN( d ) *zrpi18
  ELSEIF (ABS(v) > zsmall) THEN
    f  =  ABS( v )
    d  =  270.0_wp - SIGN( 90.0_wp , v )
  ELSE
    f  =    0.0_wp
    d  =    0.0_wp
  ENDIF

END SUBROUTINE uv2df

!==============================================================================
!==============================================================================

!------------------------------------------------------------------------------

SUBROUTINE uv2df_vec (u, v, d, f, idim, jdim)

!------------------------------------------------------------------------------
!
! Description:
!   This routine computes wind speed and wind direction from the wind
!   components.  This is the vectorized form of the routine above,
!   i.e. the computation is for a whole 2D field.
!
! Method:
!   Straightforward.
!
!------------------------------------------------------------------------------
!
! Parameter list:
INTEGER       , INTENT(IN)           ::    &
  idim, jdim        ! dimensions of the field

REAL (KIND=wp), INTENT (IN)          ::    &
  u  (idim,jdim) ,& ! wind components in the true geographical system
  v  (idim,jdim)    !

REAL (KIND=wp), INTENT (OUT)         ::    &
  f  (idim,jdim) ,& ! wind speed
  d  (idim,jdim)    ! wind direction

! Local variables

INTEGER                              ::    i, j

! added PARAMETER attribute to enable inlining and vectorization
! (otherwise zrpi18 / zpir18 get an implicit "SAVE" attribute which hinders inlining!)
REAL (KIND=wp),     PARAMETER            ::    &
  zrpi18 = 57.2957795_wp,                      & ! conversion from radians to degrees
  zsmall = 0.001_wp

!------------------------------------------------------------------------------
! Begin Subroutine uv2df_vec
!------------------------------------------------------------------------------

  DO j = 1, jdim
    DO i = 1, idim

      IF (ABS(u(i,j)) > zsmall) THEN
        f (i,j)  =  SQRT( u(i,j)*u(i,j) + v(i,j)*v(i,j) )
        d (i,j)  =  180.0_wp + SIGN( 90.0_wp , u(i,j) )               &
                                 - ATAN( v(i,j) / u(i,j) ) *zrpi18
      ELSEIF (ABS(v(i,j)) > zsmall) THEN
        f (i,j)  =  ABS( v(i,j) )
        d (i,j)  =  270.0_wp - SIGN( 90.0_wp , v(i,j) )
      ELSE
        f (i,j)  =    0.0_wp
        d (i,j)  =    0.0_wp
      ENDIF

    ENDDO
  ENDDO

END SUBROUTINE uv2df_vec

!==============================================================================
!==============================================================================

!------------------------------------------------------------------------------
!
! Integral averaging (using the trapezoidal rule) of the M ("anz") data values
! in the vector "fwerte", (a function of X-values in "xwerte") over intervals
! of X-values, whose borders are defined in the vector "xgrenzen".
! The X-values in "xwerte" and "xgrenzen" have to be strictly monotonically increasing.
!
! The resulting interval-average values are defined as follows:
!
! The original value pairs "xwerte"/"fwerte" are interpreted as
! the nodes of the linear spline p(x) (therefore the use of the trapezoidal rule)
! and the resulting averages over the single intervals [xgrenzen(i) , xgrenzen(i+1)]
! is given by
!             finter(i) = integral_{xgrenzen(i)}^{xgrenzen(i+1)} p(x) dx
!
! If N is the number of averaging intervals (input parameter "anzinter"), then
!
! xgrenzen(N+1) ---> Vector of averaging interval borders
! finter(N)     ---> Vector of corresponding averaged values
!
! If some values in "xgrenzen" are outside the span of "xwerte", "finter" attains
! the same value as on the borders of "xwerte" (constant extrapolation).
!
! If there spacing of "xwerte" is much smaller than "xgrenzen", then "finter"
! behaves like a lowpass filtered and interpolated signal, whereas in the other
! case ("xgrenzen" much finer than "xwerte"), it behaves like an unfiltered
! linear interpolation.
!
!------------------------------------------------------------------------------


!===============================================================
! Routine for scalar machines:
!===============================================================

  SUBROUTINE mittel_integral(xwerte, fwerte, anz, xgrenzen, finter, anzinter, ierr)

    IMPLICIT NONE

    INTEGER      , INTENT(in)  :: anz, anzinter
    REAL(KIND=wp), INTENT(in)  :: xwerte(anz), fwerte(anz), xgrenzen(anzinter+1)
    INTEGER      , INTENT(out) :: ierr
    REAL(KIND=wp), INTENT(out) :: finter(anzinter)

    INTEGER           :: i, j, fehler
    REAL(KIND=wp)     :: xtmpu(1), ftmpu(1), xtmpo(1), ftmpo(1), xtmp, ftmp


    ierr = 0

    finter = -9999.99_wp

    xtmpu(1) = xgrenzen(1)
    CALL linear_interpol(xwerte, fwerte, anz, xtmpu, ftmpu, 1, fehler)
    IF (fehler /= 0) THEN
      ierr = 1
      WRITE (*,*) '%%%% mittel_integral: Error in first call to linear_interpol!'
      RETURN
    END IF

    j = 1
    DO i=1, anzinter

      xtmpo(1) = xgrenzen(i+1)
      IF (xtmpo(1) < xtmpu(1)) THEN
        ierr = 2
        WRITE (*,*) '%%%% mittel_integral: Error --- Xgrenzen must be monotonically increasing!'
        finter = -9999.99_wp
        RETURN
      END IF

      CALL linear_interpol(xwerte, fwerte, anz, xtmpo, ftmpo, 1, fehler)
      IF (fehler /= 0) ierr = 1

      xtmp = xtmpu(1)
      ftmp = ftmpu(1)
      finter(i) = 0.0_wp
      DO
        IF (j > anz) EXIT
        IF (xwerte(j) > xtmpo(1)) EXIT
        IF (xwerte(j) > xtmpu(1)) THEN
          finter(i) = finter(i) + 0.5_wp * (fwerte(j) + ftmp) * (xwerte(j) - xtmp)
          ftmp = fwerte(j)
          xtmp = xwerte(j)
        END IF
        j = j + 1
      END DO
      finter(i) = finter(i) + 0.5_wp * (ftmpo(1) + ftmp) * (xtmpo(1)-xtmp)
      IF ( xtmpo(1)-xtmpu(1) > 0.0_wp ) THEN
        finter(i) = finter(i) / (xtmpo(1)-xtmpu(1))
      ELSE
        finter(i) = ftmpo(i)
      END IF

      xtmpu = xtmpo
      ftmpu = ftmpo

    END DO

    RETURN
  END SUBROUTINE mittel_integral

!===============================================================
! Routine optimized for vector machines:
!===============================================================

  SUBROUTINE mittel_integral_vec(xwerte, fwerte, anz, xgrenzen, finter, anzinter, ierr)

    IMPLICIT NONE

    INTEGER      , INTENT(in)  :: anz, anzinter
    REAL(KIND=wp), INTENT(in)  :: xwerte(anz), fwerte(anz), xgrenzen(anzinter+1)
    INTEGER      , INTENT(out) :: ierr
    REAL(KIND=wp), INTENT(out) :: finter(anzinter)

    INTEGER           :: i, j, fehler, maxiter, iorig_low(anzinter+1)
    REAL(KIND=wp)     :: xtmpu(anzinter), ftmpu(anzinter), ftmp(anzinter+1)
    LOGICAL :: nocheine(anzinter)

    maxiter = anz + 3

    ierr = 0

    finter = -9999.99_wp

    IF ( ANY(xwerte(2:anz) < xwerte(1:anz-1) ) ) THEN
      ierr = 2
      WRITE (*,*) &
           '%%%% mittel_integral_vec: Error --- Xinter must be monotonically increasing!'
      RETURN
    END IF

    IF ( ANY(xgrenzen(2:anzinter+1) < xgrenzen(1:anzinter) ) ) THEN
      ierr = 2
      WRITE (*,*) &
           '%%%% mittel_integral_vec: Error --- Xinter must be monotonically increasing!'
      RETURN
    END IF

    CALL linear_interpol_vec(xwerte, fwerte, anz, xgrenzen, ftmp, anzinter+1, &
         fehler, iorig_low=iorig_low)
    IF (fehler /= 0) THEN
      ierr = 1
      WRITE (*,*) '%%%% mittel_integral_vec: Error in call to linear_interpol_vec!'
      RETURN
    END IF
    IF (fehler /= 0) ierr = 1

    ! iorig_low are the x-Indices of the lower neighbouring nodes
    ! relative to the averaging interval borders. By adding 1 they become the
    ! the upper neighbouring nodes. That's why the incrementing of j starts
    ! at 1, not at 0.

    j = 1
    xtmpu = xgrenzen(1:anzinter)
    ftmpu = ftmp(1:anzinter)
    finter = 0.0_wp
    DO i=1, anzinter
      nocheine(i) = (xwerte(MIN(iorig_low(i)+j,anz)) <= xgrenzen(i+1) .AND. &
           xwerte(MIN(iorig_low(i)+j,anz)) > xgrenzen(i) )
      nocheine(i) = nocheine(i) .AND. (iorig_low(i)+j <= anz)
    END DO
    DO WHILE ( ANY(nocheine) .AND. j <= maxiter )
      DO i=1, anzinter
        IF ( nocheine(i) ) THEN
          finter(i) = finter(i) + 0.5_wp * (fwerte(iorig_low(i)+j) + &
               ftmpu(i)) * (xwerte(iorig_low(i)+j) - xtmpu(i))
          ftmpu(i) = fwerte(iorig_low(i)+j)
          xtmpu(i) = xwerte(iorig_low(i)+j)
        END IF
      END DO
      j = j + 1
      DO i=1, anzinter
        nocheine(i) = (xwerte(MIN(iorig_low(i)+j,anz)) <= xgrenzen(i+1) .AND. &
             xwerte(MIN(iorig_low(i)+j,anz)) > xgrenzen(i) )
        nocheine(i) = nocheine(i) .AND. (iorig_low(i)+j <= anz)
      END DO
    END DO

    IF ( j > maxiter ) THEN
      ierr = 3
      finter = -9999.99_wp
      WRITE (*,*) '%%%% mittel_integral_vec: Error --- j > maxiter!'
      RETURN
    END IF

    DO i=1, anzinter
      finter(i) = finter(i) + 0.5_wp * (ftmp(i+1) + ftmpu(i)) * (xgrenzen(i+1)-xtmpu(i))
      IF ( xgrenzen(i+1) - xgrenzen(i) > 0.0_wp ) THEN
        finter(i) = finter(i) / ( xgrenzen(i+1) - xgrenzen(i))
      ELSE
        finter(i) = ftmp(i+1)
      END IF
    END DO

    RETURN
  END SUBROUTINE mittel_integral_vec

!==============================================================================
!==============================================================================

  !------------------------------------------------------------------------------
  !
  ! Numerical quadrature (using the trapezoidal rule) of the M ("anz") data values 
  ! in the vector "fwerte", (a function of X-values in "xwerte") over intervals 
  ! of X-values, whose borders are defined in the vector "xgrenzen".
  ! The X-values in "xwerte" and "xgrenzen" have to be strictly monotonically increasing.
  !
  ! The resulting integral values are defined as follows:
  !
  ! The original value pairs "xwerte"/"fwerte" are interpreted as 
  ! the nodes of the linear spline p(x) (therefore the use of the trapezoidal rule)
  ! and the resulting integral over the single intervals [xgrenzen(i) , xgrenzen(i+1)]
  ! is given by
  !             finter(i) = integral_{xgrenzen(i)}^{xgrenzen(i+1)} p(x) dx
  !
  ! If N is the number of integration intervals (input parameter "anzinter"), then
  !
  ! xgrenzen(N+1) ---> Vector of averaging interval borders
  ! finter(N)     ---> Vector of corresponding integral values
  !
  ! The values of p at the integration borders xgrenzen are linearily interpolated
  ! between the original points (xwerte, fwerte).
  !
  ! If some values in "xgrenzen" are outside the span of "xwerte", "finter" attains
  ! the same value as on the borders of "xwerte" (constant extrapolation).
  !
  ! Optional: On top of integration, divide by the interval widths xgrenzen(i+1)-xgrenzen(i) to
  !           compute integral averages instead of integrals.
  !           This can be selected by setting the optional switch
  !
  !           do_integral_averaging = .TRUE.
  !
  ! If the spacing of "xwerte" is much smaller than "xgrenzen", then "finter"
  ! behaves like a lowpass-filtered and -interpolated signal, whereas in the other
  ! case ("xgrenzen" much finer than "xwerte"), it behaves like an unfiltered
  ! linear interpolation.
  !
  !------------------------------------------------------------------------------

  ! derived from the routine mittel_integral() from COSMO utilities.f90
  SUBROUTINE trapz_integral(xwerte, fwerte, anz, xgrenzen, finter, anzinter, ierr, do_integral_averaging)

    INTEGER      , INTENT(IN)  :: anz, anzinter
    REAL(KIND=wp), INTENT(IN)  :: xwerte(anz), fwerte(anz), xgrenzen(anzinter+1)
    INTEGER      , INTENT(OUT) :: ierr
    REAL(KIND=wp), INTENT(OUT) :: finter(anzinter)
    LOGICAL, OPTIONAL          :: do_integral_averaging

    INTEGER           :: i, j, fehler
    REAL(KIND=wp)     :: xtmpu(1), ftmpu(1), xtmpo(1), ftmpo(1), xtmp, ftmp
    CHARACTER(LEN=*), PARAMETER :: rname = 'trapz_integral'
    LOGICAL           :: laveraging

    ierr = 0

    finter = -9999.99_wp

    IF (PRESENT(do_integral_averaging)) THEN
      laveraging = do_integral_averaging
    ELSE
      laveraging = .FALSE.
    END IF

    xtmpu(1) = xgrenzen(1)
    CALL linear_interpol(xwerte, fwerte, anz, xtmpu, ftmpu, 1, fehler)
    IF (fehler /= 0) THEN
      ierr = 1
      WRITE (*,*) '%%%% '//TRIM(rname)//': Error in first call to linear_interpol!'
      RETURN
    END IF

    j = 1
    DO i=1, anzinter

      xtmpo(1) = xgrenzen(i+1)
      IF (xtmpo(1) < xtmpu(1)) THEN
        ierr = 2
        WRITE (*,*) '%%%% '//TRIM(rname)//': Error --- Xgrenzen must be monotonically increasing!'
        finter = -9999.99_wp
        RETURN
      END IF

      CALL linear_interpol(xwerte, fwerte, anz, xtmpo, ftmpo, 1, fehler)
      IF (fehler /= 0) ierr = 1

      xtmp = xtmpu(1)
      ftmp = ftmpu(1)
      finter(i) = 0.0_wp
      DO
        IF (j > anz) EXIT
        IF (xwerte(j) > xtmpo(1)) EXIT
        IF (xwerte(j) > xtmpu(1)) THEN
          finter(i) = finter(i) + 0.5_wp * (fwerte(j) + ftmp) * (xwerte(j) - xtmp)
          ftmp = fwerte(j)
          xtmp = xwerte(j)
        END IF
        j = j + 1
      END DO
      finter(i) = finter(i) + 0.5_wp * (ftmpo(1) + ftmp) * (xtmpo(1)-xtmp)

      IF (laveraging) THEN
        IF ( xtmpo(1)-xtmpu(1) > 0.0_wp ) THEN
          finter(i) = finter(i) / (xtmpo(1)-xtmpu(1))
        ELSE
          finter(i) = ftmpo(i)
        END IF
      ELSE
        IF ( xtmpo(1)-xtmpu(1) <= 0.0_wp ) THEN
          finter(i) = 0.0_wp
        END IF
      END IF

      xtmpu = xtmpo
      ftmpu = ftmpo

    END DO

  END SUBROUTINE trapz_integral

!==============================================================================
!==============================================================================

!**************************************************************************************
!
! Routine for linear interpolation (1D) of the M ("anz") values "fwerte" defined at
! positions "xwerte" to the N ("anzinter") positions in "xinter". "finter" returns the
! corresponding interpolated values, and ierr contains an error flag, which
! is 0 if all "anzinter" points could be interpolated.
! For points in "xinter" which are outside the range of "xwerte",
! a constant extrapolation is applied, i.e., corresponding values
! of "finter" are equal to "fwerte(1)" or "fwerte(anz)", resp.
!
! Values in "xwerte" have to be strictly monotonically increasing, whereas
! no such constraint applies for the values in "xinter".
!
!**************************************************************************************

!===============================================================
! Routine for scalar machines:
!===============================================================

  SUBROUTINE linear_interpol(xwerte, fwerte, anz, xinter, finter, anzinter, ierr, missingval)

    IMPLICIT NONE

    INTEGER      , INTENT(in)  :: anz, anzinter
    REAL(KIND=wp), INTENT(in)  :: xwerte(anz), fwerte(anz), xinter(anzinter)
    REAL(KIND=wp), INTENT(in), OPTIONAL :: missingval
    INTEGER      , INTENT(out) :: ierr
    REAL(KIND=wp), INTENT(out) :: finter(anzinter)

    INTEGER           :: i, j, cnt
    REAL(KIND=wp)     :: xtmp, xmax, xmin
    CHARACTER(LEN=*), PARAMETER :: rname = 'linear_interpol'


    ierr = 0

    IF ( ANY(xwerte(2:anz) < xwerte(1:anz-1) ) ) THEN
      ierr = 2
      WRITE (*,*) '%%%% '//TRIM(rname)//': Error --- Xwerte must be monotonically increasing!'
      RETURN
    END IF

    xmin = MINVAL(xwerte)
    xmax = MAXVAL(xwerte)
    cnt = 0

    IF (.NOT.PRESENT(missingval)) THEN    

      DO i=1, anzinter

        xtmp = xinter(i)

        IF (xtmp > xmax) THEN
          cnt = cnt + 1
          finter(i) = fwerte(anz)
        ELSEIF (xtmp <= xmin) THEN
          cnt = cnt + 1
          finter(i) = fwerte(1)
        ELSE
          intervallsuchen: DO j=1, anz-1
            IF ( xtmp > xwerte(j) .AND. xtmp <= xwerte(j+1) ) THEN
              cnt = cnt + 1
              finter(i) = fwerte(j) + (fwerte(j+1)-fwerte(j)) / &
                   (xwerte(j+1)-xwerte(j)) * (xtmp-xwerte(j))
              EXIT intervallsuchen
            END IF
          END DO intervallsuchen
        END IF

      END DO

    ELSE

      DO i=1, anzinter

        xtmp = xinter(i)

        IF (xtmp > xmax .OR. xtmp <= xmin) THEN
          cnt = cnt + 1
          finter(i) = missingval
        ELSE
          intervallsuchen2: DO j=1, anz-1
            IF ( xtmp > xwerte(j) .AND. xtmp <= xwerte(j+1) ) THEN
              cnt = cnt + 1
              finter(i) = fwerte(j) + (fwerte(j+1)-fwerte(j)) / &
                   (xwerte(j+1)-xwerte(j)) * (xtmp-xwerte(j))
              EXIT intervallsuchen2
            END IF
          END DO intervallsuchen2
        END IF

      END DO

    END IF

    IF (cnt < anzinter) ierr = 1

  END SUBROUTINE linear_interpol

!===============================================================
! Routine (1D) optimized for vector machines:
!===============================================================

  SUBROUTINE linear_interpol_vec(xwerte, fwerte, anz, &
       xinter, finter, anzinter, ierr, missingval, iorig_low)

    IMPLICIT NONE

    INTEGER      , INTENT(IN)            :: anz, anzinter
    REAL(KIND=wp), INTENT(IN)            :: xwerte(anz), fwerte(anz), xinter(anzinter)
    REAL(KIND=wp), INTENT(IN) , OPTIONAL :: missingval
    INTEGER      , INTENT(OUT), OPTIONAL :: iorig_low(anzinter)
    INTEGER      , INTENT(OUT)           :: ierr
    REAL(KIND=wp), INTENT(OUT)           :: finter(anzinter)

    INTEGER           :: i, j, cnt(anzinter), ju(anzinter)
    REAL(KIND=wp)     :: xmax, xmin


    ierr = 0

    IF (PRESENT(iorig_low)) THEN
      iorig_low = 0
    END IF

    IF ( ANY(xwerte(2:anz) < xwerte(1:anz-1) ) ) THEN
      ierr = 2
      WRITE (*,*) &
           '%%%% linear_interpol_vec: Error --- Xwerte must be monotonically increasing!'
      RETURN
    END IF

    ju = 0

    xmin = MINVAL(xwerte)
    xmax = MAXVAL(xwerte)
    cnt = 0
    ju = anz + 1
    IF (.NOT.PRESENT(missingval)) THEN
      DO i=1, anzinter
        IF (xinter(i) > xmax) THEN
          cnt(i) = cnt(i) + 1
          finter(i) = fwerte(anz)
          ju(i) = anz + 1
        ELSEIF (xinter(i) <= xmin) THEN
          cnt(i) = cnt(i) + 1
          finter(i) = fwerte(1)
          ju(i) = 0
        ENDIF
      END DO
    ELSE
      DO i=1, anzinter
        IF (xinter(i) > xmax .OR. xinter(i) <= xmin) THEN
          cnt(i) = cnt(i) + 1
          finter(i) = missingval
          ju(i) = anz + 1
        END IF
      END DO
    END IF

    intervallsuchen: DO j=1, anz-1
      DO i=1, anzinter
        IF (cnt(i) == 0) THEN
          IF ( xinter(i) > xwerte(j) .AND. xinter(i) <= xwerte(j+1) ) THEN
            cnt(i) = 1
            ju(i)  = j
          END IF
        END IF
      END DO
    END DO intervallsuchen

    DO i=1, anzinter
      IF (ju(i) <= anz-1 .AND. ju(i) > 0) THEN
        finter(i) = fwerte(ju(i)) + (fwerte(ju(i)+1)-fwerte(ju(i))) / &
             (xwerte(ju(i)+1)-xwerte(ju(i))) * (xinter(i)-xwerte(ju(i)))
      END IF
    END DO

    IF (SUM(cnt) /= anzinter) ierr = 1

    IF (PRESENT(iorig_low)) THEN
      iorig_low = ju
    END IF

  END SUBROUTINE linear_interpol_vec


!===============================================================
! Routine (2D) optimized for vector machines:
!
! Interpolation is done with respect to the 2. index of
! "xwerte(ni,anz)" resp. "fwerte(ni,anz)" to the points given
! in vector "xinter". Vectorization is with respect to
! the first index "ni".
!
!===============================================================

  SUBROUTINE lininterp2D_xinter1D_vec(xwerte, fwerte, ni, anz, &
       xinter, finter, anzinter, ierr, missingval)

    IMPLICIT NONE

    INTEGER      , INTENT(IN)           :: ni, anz, anzinter
    REAL(KIND=wp), INTENT(IN)           :: xwerte(ni, anz), fwerte(ni, anz), xinter(anzinter)
    REAL(KIND=wp), INTENT(IN), OPTIONAL :: missingval
    INTEGER      , INTENT(OUT)          :: ierr
    REAL(KIND=wp), INTENT(OUT)          :: finter(ni, anzinter)


    INTEGER           :: i, j, k, cnt(ni)
    REAL(KIND=wp)     :: xtmp, xmax(ni), xmin(ni)


    ierr = 0

    IF ( ANY(xwerte(:,2:anz) < xwerte(:,1:anz-1) ) ) THEN
      ierr = 2
      WRITE (*,*) &
           '%%%% lininterp2D_xinter1D: Error --- Xwerte must be monotonically increasing!'
      RETURN
    END IF

    xmin = MINVAL(xwerte,2)
    xmax = MAXVAL(xwerte,2)
    cnt = 0
    DO i=1, anzinter

      xtmp = xinter(i)

      IF (PRESENT(missingval)) THEN
        ! set out-of-x-range values to missingval:
        DO j=1,ni
          IF (xtmp > xmax(j) .OR. xtmp <= xmin(j)) THEN
            cnt(j) = cnt(j) + 1
            finter(j,i) = missingval
          END IF
        END DO
      ELSE
        ! constant extrapolation for out-of-x-range values:
        DO j=1,ni
          IF (xtmp > xmax(j)) THEN
            cnt(j) = cnt(j) + 1
            finter(j,i) = fwerte(j,anz)
          ELSEIF (xtmp <= xmin(j)) THEN
            cnt(j) = cnt(j) + 1
            finter(j,i) = fwerte(j,1)
          END IF
        END DO
      END IF

      intervallsuchen: DO k=1, anz-1
        IF (ALL(xtmp <= xwerte(:,k))) EXIT intervallsuchen
        DO j=1,ni
          IF ( xtmp > xwerte(j,k) .AND. xtmp <= xwerte(j,k+1)) THEN
            cnt(j) = cnt(j) + 1
            finter(j,i) = fwerte(j,k) + (fwerte(j,k+1)-fwerte(j,k)) / &
                 (xwerte(j,k+1)-xwerte(j,k)) * (xtmp-xwerte(j,k))
          END IF
        END DO
      END DO intervallsuchen

    END DO

    IF (ANY(cnt /= anzinter)) THEN
      ierr = 1
      WRITE (*,'(a)') '%%%% lininterp2D_xinter1D: Error --- cnt /= anzinter!'
      WRITE (*,*) '%%%% lininterp2D_xinter1D', cnt-anzinter
      RETURN
    END IF

    RETURN
  END SUBROUTINE lininterp2D_xinter1D_vec

!==============================================================================
!==============================================================================

!===============================================================
! Routine (3D) optimized for vector (and GPU) machines:
!===============================================================

  SUBROUTINE lininterp3D_xinter2D_vec(xwerte, fwerte,   &
       istart, iend, jstart, jend, kstart, kend,        &
       xinter, finter, anzinter, ierr, missingval, lacc )
    
    IMPLICIT NONE
    
    INTEGER, INTENT(in) :: istart, iend, jstart,jend, kstart, kend
    INTEGER, INTENT(in) :: anzinter
    REAL(KIND=wp),     INTENT(in) :: xwerte(:,:,:), fwerte(:,:,:), xinter(:,:)
    REAL(KIND=wp),     INTENT(in), OPTIONAL :: missingval
    INTEGER, INTENT(out) :: ierr
    REAL(KIND=wp),     INTENT(inout) :: finter(:,:,:)
    LOGICAL,           INTENT(in), OPTIONAL :: lacc
 
    INTEGER :: n, i, j, k, cnt(istart:iend,jstart:jend)
    REAL(KIND=wp) :: xmax(istart:iend,jstart:jend), xmin(istart:iend,jstart:jend)
    LOGICAL :: lzacc, lerr

    IF (PRESENT(lacc)) THEN
      lzacc = lacc
    ELSE
      lzacc = .FALSE.
    ENDIF

    !$acc enter data create ( cnt,xmax,xmin ) if (lzacc)

    ierr = 0

    lerr = .FALSE.
    !$acc parallel present (xwerte) if (lzacc)
    !$acc loop gang
    DO j=jstart,jend
      !$acc loop vector
      DO i=istart,iend
        !$acc loop seq
        DO k=kstart+1,kend
          IF (xwerte(i,j,k) < xwerte(i,j,k-1)) THEN
            !$acc atomic write
            lerr = .TRUE.
            !$acc end atomic
          ENDIF
        ENDDO
      ENDDO
    ENDDO
    !$acc end parallel

    IF (lerr) THEN
      ierr = 2
      WRITE (*,*) &
           '%%%% lininterp3D_xinter2D: Error --- Xwerte must be monotonically increasing!'
      RETURN
    END IF
 
    !$acc data &
    !$acc present ( xwerte,fwerte,xinter,finter ) &
    !$acc present ( cnt,xmax,xmin               ) if (lzacc)
    
    !$acc parallel if (lzacc)
    !$acc loop gang
    DO j=jstart,jend
      !$acc loop vector
      DO i=istart,iend
        xmin(i,j) = MINVAL(xwerte(i,j,kstart:kend))
        xmax(i,j) = MAXVAL(xwerte(i,j,kstart:kend))
        cnt(i,j) = 0
      ENDDO
    ENDDO
    !$acc end parallel

    DO n=1, anzinter

      IF (PRESENT(missingval)) THEN
        ! set out-of-x-range values to missingval:
        !$acc parallel if (lzacc)
        !$acc loop gang
        DO j=jstart,jend
          !$acc loop vector
          DO i=istart,iend
            IF (xinter(i,n) > xmax(i,j) .OR. xinter(i,n) <= xmin(i,j)) THEN
              cnt(i,j) = cnt(i,j) + 1
              finter(i,j,n) = missingval
            ENDIF
          ENDDO
        ENDDO
        !$acc end parallel
      ELSE
        ! constant extrapolation for out-of-x-range values:
        !$acc parallel if (lzacc)
        !$acc loop gang
        DO j=jstart,jend
          !$acc loop vector
          DO i=istart,iend
            IF (xinter(i,n) > xmax(i,j)) THEN
              cnt(i,j) = cnt(i,j) + 1
              finter(i,j,n) = fwerte(i,j,kend)
            ELSEIF (xinter(i,n) <= xmin(i,j)) THEN
              cnt(i,j) = cnt(i,j) + 1
              finter(i,j,n) = fwerte(i,j,1)
            ENDIF
          ENDDO
        ENDDO
        !$acc end parallel
      END IF

      !$acc parallel if (lzacc)
      DO k=kstart,kend-1
        !$acc loop gang
        DO j=jstart,jend
          !$acc loop vector
          DO i=istart,iend
            IF ( xinter(i,n) > xwerte(i,j,k) .AND. xinter(i,n) <= xwerte(i,j,k+1)) THEN
              cnt(i,j) = cnt(i,j) + 1
              finter(i,j,n) = fwerte(i,j,k) + (fwerte(i,j,k+1)-fwerte(i,j,k)) / &
                             (xwerte(i,j,k+1)-xwerte(i,j,k)) * (xinter(i,n)-xwerte(i,j,k))
            ENDIF
          ENDDO
        ENDDO
      ENDDO
      !$acc end parallel
      
    END DO
    
    !$acc parallel if (lzacc)
    !$acc loop gang
    DO j=jstart,jend
      !$acc loop vector
      DO i=istart,iend
        IF (cnt(i,j) /= anzinter) THEN
          !$acc atomic write
          lerr = .TRUE.
          !$acc end atomic
        ENDIF
      ENDDO
    ENDDO
    !$acc end parallel
    
    !$acc update host( cnt ) if (lzacc)
    !$acc end data
    
    !$acc exit data delete ( cnt,xmax,xmin ) if (lzacc)
    IF( lerr ) THEN
      ierr = 1


      WRITE (*,'(a)') '%%%% lininterp3D_xinter2D: Error --- cnt /= anzinter!'
      WRITE (*,*) '%%%% lininterp3D_xinter2D', cnt(istart:iend,jstart:jend)-anzinter
      WRITE (*,*) '%%%% lininterp3D_xinter2D', anzinter
      RETURN
    END IF
    
  END SUBROUTINE lininterp3D_xinter2D_vec

!==============================================================================
!==============================================================================

!-------------------------------------------------------------------------------
!   check a 4D field for occurences of NaN (double precision)
!       field     : the field to check
!       fieldname : string literal with name of the field
!       found     : boolean set to true IF NaN found in field
!       my_id     : PE number
!-------------------------------------------------------------------------------
SUBROUTINE check_field_NaNs_4d_double (field, fieldname, found, my_id, lacc)

  IMPLICIT NONE

  LOGICAL            , INTENT(INOUT) :: found
  CHARACTER (LEN=*)  , INTENT(IN) :: fieldname
  REAL      (KIND=dp), INTENT(IN) :: field(:, :, :, :)
  INTEGER            , INTENT(IN) :: my_id
  LOGICAL,  OPTIONAL , INTENT(IN) :: lacc !this should be set to true
                                          !if the function is called within the
                                          !data region where in and out
                                          !variables are present

  INTEGER  :: NaNs          ! counter
  INTEGER  :: i, j, k, l    ! loop indexes
  INTEGER  :: ii, jj, kk, ll! loop limits
  INTEGER  :: i1, j1, k1, l1! memorize last occurrence
  LOGICAL  :: lzacc, lzfound

  IF (PRESENT(lacc)) THEN
     lzacc=lacc
  ELSE
     lzacc=.FALSE.
  END IF

  NaNs=0
  lzfound=.FALSE.
  ii = size(field,1)
  jj = size(field,2)
  kk = size(field,3)
  ll = size(field,4)

  !$acc data present (field) if (lzacc)
    
  !$acc parallel loop gang vector collapse(4) if (lzacc)
  DO l=1,ll
    DO k=1,kk
      DO j=1,jj
        DO i=1,ii
          IF ( is_nan(field(i,j,k,l)) ) THEN
          !$acc atomic write
          lzfound =  .true.
          !$acc end atomic
          END IF
        END DO
      END DO
    END DO
  END DO

 IF (lzfound) THEN    !Print if NaN
   found = .true.

 ! Copy to host to get the position of the first NaN for printing
 !$acc update host(field) if(lzacc)
 
  DO l=1,ll
    DO k=1,kk
      DO j=1,jj
        DO i=1,ii
          IF ( is_nan(field(i,j,k,l)) .OR. is_inf(field(i,j,k,l)) ) THEN
            NaNs = NaNs+1
            i1 = i
            j1 = j
            k1 = k
            l1 = l
          ENDIF
        END DO
      END DO
    END DO
  END DO

    WRITE(0,'(A,I7,A,A,A,I5,A,4(I3.3,A))')                          &
         'ERROR:', NaNs, ' NaNs in ', TRIM(fieldname),              &
         ' on PE ', my_id, ' e.g. (i,j,k) = (',i1,',',j1,',',k1,',',l1,')'
  ENDIF

  !$acc end data
END SUBROUTINE check_field_NaNs_4d_double

!-------------------------------------------------------------------------------
!   check a 4D field for occurences of NaN (single precision)
!       field     : the field to check
!       fieldname : string literal with name of the field
!       found     : boolean set to true IF NaN found in field
!       my_id     : PE number
!-------------------------------------------------------------------------------
SUBROUTINE check_field_NaNs_4d_single (field, fieldname, found, my_id, lacc)

  IMPLICIT NONE

  LOGICAL            , INTENT(INOUT) :: found
  CHARACTER (LEN=*)  , INTENT(IN) :: fieldname
  REAL      (KIND=sp), INTENT(IN) :: field(:, :, :, :)
  INTEGER            , INTENT(IN) :: my_id
  LOGICAL,  OPTIONAL , INTENT(IN) :: lacc !this should be set to true if the
                                          !functions is called within the data
                                          !region where in and out variables are
                                          !present

  INTEGER :: NaNs          ! counter
  INTEGER :: i, j, k, l    ! loop indexes
  INTEGER :: ii, jj, kk, ll! loop limits
  INTEGER :: i1, j1, k1, l1! memorize last occurrence
  LOGICAL :: lzacc, lzfound

  IF (PRESENT(lacc)) THEN
     lzacc=lacc
  ELSE
     lzacc=.FALSE.
  END IF

  NaNs=0
  lzfound=.FALSE.
  ii = size(field,1)
  jj = size(field,2)
  kk = size(field,3)
  ll = size(field,4)

  !$acc data present (field) if(lzacc)
    
  !$acc parallel loop gang vector collapse(4) if (lzacc)
  DO l=1,ll
    DO k=1,kk
      DO j=1,jj
        DO i=1,ii   
          IF ( is_nan(field(i,j,k,l))) THEN
            !$acc atomic write
            lzfound = .TRUE.
            !$acc end atomic
          END IF
        END DO
      END DO
    END DO
  END DO

  IF (lzfound) THEN 
    found = .TRUE.
  
    !$acc update host(field) if (lzacc)
    DO l=1,ll
      DO k=1,kk
        DO j=1,jj
          DO i=1,ii
            IF ( is_nan(field(i,j,k,l)) .OR. is_inf(field(i,j,k,l)) ) THEN
              NaNs = NaNs+1
              i1 = i
              j1 = j
              k1 = k
              l1 = l
            ENDIF
          END DO
        END DO
      END DO
    END DO

    WRITE(0,'(A,I7,A,A,A,I5,A,4(I3.3,A))')                          &
         'ERROR:', NaNs, ' NaNs in ', TRIM(fieldname),              &
         ' on PE ', my_id, ' e.g. (i,j,k) = (',i1,',',j1,',',k1,',',l1,')'
  ENDIF

  !$acc end data

END SUBROUTINE check_field_NaNs_4d_single

!-------------------------------------------------------------------------------
!   check a 3D field for occurences of NaN (double precision)
!       field     : the field to check
!       fieldname : string literal with name of the field
!       found     : boolean set to true IF NaN found in field
!       my_id     : PE number
!-------------------------------------------------------------------------------
SUBROUTINE check_field_NaNs_3d_double (field, fieldname, found, my_id, lacc)

  IMPLICIT NONE

  LOGICAL            , INTENT(INOUT) :: found
  CHARACTER (LEN=*)  , INTENT(IN) :: fieldname
  REAL      (KIND=dp), INTENT(IN) :: field(:, :, :)
  INTEGER            , INTENT(IN) :: my_id
  LOGICAL, OPTIONAL  , INTENT(IN) :: lacc !this should be set to true
                                          !if the function is called within a
                                          !data region where in and out
                                          !variables are present

  INTEGER :: NaNs          ! counter
  INTEGER :: i, j, k       ! loop indexes
  INTEGER :: ii, jj, kk    ! loop limits
  INTEGER :: i1, j1, k1    ! memorize last occurrence
  LOGICAL :: lzacc, lzfound

  IF (PRESENT(lacc)) THEN
     lzacc=lacc
  ELSE 
     lzacc=.FALSE.
  END IF

  NaNs=0
  lzfound=.FALSE.
  ii = size(field,1)
  jj = size(field,2)
  kk = size(field,3)
  !$acc data present (field) if (lzacc)
    
  !$acc parallel loop gang vector collapse(3) if(lzacc)
  DO k=1,kk
    DO j=1,jj
      DO i=1,ii
        IF ( is_nan(field(i,j,k)) ) THEN
          !$acc atomic write
          lzfound = .true.
          !$acc end atomic
        END IF
      END DO
    END DO
  END DO

  IF (lzfound) THEN 
    found = .true. 

    !$acc update host (field) if (lzacc)
    DO k=1,kk
      DO j=1,jj
        DO i=1,ii
          IF ( is_nan(field(i,j,k)) .OR. is_inf(field(i,j,k)) ) THEN
            NaNs = NaNs+1
            i1 = i
            j1 = j
            k1 = k
          ENDIF
        END DO
      END DO
    END DO

    WRITE(0,'(A,I7,A,A,A,I5,A,3(I3.3,A))')                          &
         'ERROR:', NaNs, ' NaNs in ', TRIM(fieldname),              &
         ' on PE ', my_id, ' e.g. (i,j,k) = (',i1,',',j1,',',k1,')'
  ENDIF
 
  !$acc end data

END SUBROUTINE check_field_NaNs_3d_double

!-------------------------------------------------------------------------------
!   check a 3D field for occurences of NaN (single precision)
!       field     : the field to check
!       fieldname : string literal with name of the field
!       found     : boolean set to true IF NaN found in field
!       my_id     : PE number
!-------------------------------------------------------------------------------
SUBROUTINE check_field_NaNs_3d_single (field, fieldname, found, my_id, lacc)

  IMPLICIT NONE

  LOGICAL            , INTENT(INOUT) :: found
  CHARACTER (LEN=*)  , INTENT(IN) :: fieldname
  REAL      (KIND=sp), INTENT(IN) :: field(:, :, :)
  INTEGER            , INTENT(IN) :: my_id
  LOGICAL, OPTIONAL  , INTENT(IN) :: lacc !this should be set to true
                                          !if the function is called within a
                                          !data region where in and out
                                          !variables are present

  INTEGER :: NaNs          ! counter
  INTEGER :: i, j, k       ! loop indexes
  INTEGER :: ii, jj, kk    ! loop limits
  INTEGER :: i1, j1, k1    ! memorize last occurrence
  LOGICAL :: lzacc, lzfound

    IF (PRESENT(lacc)) THEN
       lzacc=lacc
    ELSE
       lzacc=.FALSE.
    END IF

  NaNs=0
  lzfound=.FALSE.
  ii = size(field,1)
  jj = size(field,2)
  kk = size(field,3)

  !$acc data present (field) if (lzacc)

  !$acc parallel loop gang vector collapse(3) if(lzacc)
  DO k=1,kk
    DO j=1,jj
      DO i=1,ii
        IF ( is_nan(field(i,j,k)) ) THEN
          !$acc atomic write
          lzfound = .true.
          !$acc end atomic
        END IF
      END DO
    END DO
  END DO

  IF (lzfound) THEN 
    found = .true.

    !$acc update host(field) if (lzacc)

    DO k=1,kk
      DO j=1,jj
        DO i=1,ii
          IF ( is_nan(field(i,j,k)) .OR. is_inf(field(i,j,k)) ) THEN
            NaNs = NaNs+1
            i1 = i
            j1 = j
            k1 = k
          ENDIF
        END DO
      END DO
    END DO

    WRITE(0,'(A,I7,A,A,A,I5,A,3(I3.3,A))')                          &
         'ERROR:', NaNs, ' NaNs in ', TRIM(fieldname),              &
         ' on PE ', my_id, ' e.g. (i,j,k) = (',i1,',',j1,',',k1,')'
  ENDIF

  !$acc end data

END SUBROUTINE check_field_NaNs_3d_single

!-------------------------------------------------------------------------------
!   check a 2D field for occurences of NaN (double precision)
!       field     : the field to check
!       fieldname : string literal with name of the field
!       found     : boolean set to true IF NaN found in field
!       my_id     : PE number
!-------------------------------------------------------------------------------
SUBROUTINE check_field_NaNs_2d_double (field, fieldname, found, my_id, lacc)

  IMPLICIT NONE

  LOGICAL            , INTENT(INOUT) :: found
  CHARACTER (LEN=*)  , INTENT(IN) :: fieldname
  REAL      (KIND=dp), INTENT(IN) :: field(:,:)
  INTEGER            , INTENT(IN) :: my_id
  LOGICAL, OPTIONAL  , INTENT(IN) :: lacc

  INTEGER :: NaNs          ! counter
  INTEGER :: i, j          ! loop indexes
  INTEGER :: ii, jj        ! loop limits
  INTEGER :: i1, j1        ! memorize last occurrence
  LOGICAL :: lzfound, lzacc

  IF (PRESENT(lacc)) THEN
     lzacc=lacc
  ELSE
     lzacc=.FALSE.
  END IF
  
  NaNs=0
  lzfound=.FALSE.
  ii = size(field,1)
  jj = size(field,2)

  !$acc data present (field) if (lzacc)

  !$acc parallel loop gang vector collapse(2) if(lzacc)
    DO j=1,jj
      DO i=1,ii
        IF ( is_nan(field(i,j)) ) THEN
          !$acc atomic write
          lzfound = .true.
          !$acc end atomic
        END IF
      END DO
    END DO

  IF (lzfound) THEN 
    found = .true.

    !$acc update host(field) if (lzacc)

  DO j=1,jj
    DO i=1,ii
      IF ( is_nan(field(i,j)) .OR. is_inf(field(i,j)) ) THEN
        NaNs = NaNs+1
        i1 = i
        j1 = j
      ENDIF
    END DO
  END DO

    WRITE(0,'(A,I7,A,A,A,I5,A,2(I3.3,A))')                          &
         'ERROR:', NaNs, ' NaNs in ', TRIM(fieldname),              &
         ' on PE ', my_id, ' e.g. (i,j) = (',i1,',',j1,')'
  ENDIF
  !$acc end data
END SUBROUTINE check_field_NaNs_2d_double

!-------------------------------------------------------------------------------
!   check a 2D field for occurences of NaN (single precision)
!       field     : the field to check
!       fieldname : string literal with name of the field
!       found     : boolean set to true IF NaN found in field
!       my_id     : PE number
!-------------------------------------------------------------------------------
SUBROUTINE check_field_NaNs_2d_single (field, fieldname, found, my_id, lacc)

  IMPLICIT NONE

  LOGICAL            , INTENT(INOUT) :: found
  CHARACTER (LEN=*)  , INTENT(IN) :: fieldname
  REAL      (KIND=sp), INTENT(IN) :: field(:,:)
  INTEGER            , INTENT(IN) :: my_id
  LOGICAL, OPTIONAL  , INTENT(IN) :: lacc

  INTEGER :: NaNs          ! counter
  INTEGER :: i, j          ! loop indexes
  INTEGER :: ii, jj        ! loop limits
  INTEGER :: i1, j1        ! memorize last occurrence
  LOGICAL :: lzfound, lzacc

  IF (PRESENT(lacc)) THEN
     lzacc=lacc
  ELSE
     lzacc=.FALSE.
  END IF

  NaNs=0
  lzfound=.FALSE.
  ii = size(field,1)
  jj = size(field,2)

  !$acc data present (field) if (lzacc)

  !$acc parallel loop gang vector collapse(2) if(lzacc)
    DO j=1,jj
      DO i=1,ii
        IF ( is_nan(field(i,j)) ) THEN
          !$acc atomic write
          lzfound = .true.
          !$acc end atomic
        END IF
      END DO
    END DO

  IF (lzfound) THEN 
    found = .true.

    !$acc update host(field) if (lzacc)
    DO j=1,jj
      DO i=1,ii
        IF ( is_nan(field(i,j)) .OR. is_inf(field(i,j)) ) THEN
          NaNs = NaNs+1
          i1 = i
          j1 = j
        ENDIF
      END DO
    END DO

    WRITE(0,'(A,I7,A,A,A,I5,A,2(I3.3,A))')                          &
         'ERROR:', NaNs, ' NaNs in ', TRIM(fieldname),              &
         ' on PE ', my_id, ' e.g. (i,j) = (',i1,',',j1,')'
  ENDIF
  
  !$acc end data

END SUBROUTINE check_field_NaNs_2d_single

!-------------------------------------------------------------------------------
!   check a 1D field for occurences of NaN (double precision)
!       field     : the field to check
!       fieldname : string literal with name of the field
!       found     : boolean set to true IF NaN found in field
!       my_id     : PE number
!-------------------------------------------------------------------------------
SUBROUTINE check_field_NaNs_1d_double (field, fieldname, found, my_id, lacc)

  IMPLICIT NONE

  LOGICAL            , INTENT(INOUT) :: found
  CHARACTER (LEN=*)  , INTENT(IN) :: fieldname
  REAL      (KIND=dp), INTENT(IN) :: field(:)
  INTEGER            , INTENT(IN) :: my_id
  LOGICAL, OPTIONAL  , INTENT(IN) :: lacc

  INTEGER :: NaNs          ! loop indexes
  INTEGER :: i             ! loop indexes
  INTEGER :: ii            ! loop limits
  INTEGER :: i1            ! memorize last occurrence
  LOGICAL :: lzacc, lzfound

  IF (PRESENT(lacc)) THEN
     lzacc=lacc
  ELSE
     lzacc=.FALSE.
  END IF

  NaNs=0
  lzfound=.FALSE.
  ii = size(field,1)

  !$acc data present (field) if (lzacc)

  !$acc parallel loop gang vector if(lzacc)
  DO i=1,ii
    IF ( is_nan(field(i)) ) THEN
       !$acc atomic write
       lzfound = .true.
       !$acc end atomic
    END IF
  END DO

  IF (lzfound) THEN 
    found = .true.

    !$acc update host(field) if (lzacc)
    DO i=1,ii
      IF ( is_nan(field(i)) .OR. is_inf(field(i)) ) THEN
        NaNs = NaNs+1
        i1 = i
      ENDIF
    END DO

    WRITE(0,'(A,I7,A,A,A,I5,A,1(I3.3,A))')                          &
         'ERROR:', NaNs, ' NaNs in ', TRIM(fieldname),              &
         ' on PE ', my_id, ' e.g. (i) = (',i1,')'
  ENDIF

  !$acc end data

END SUBROUTINE check_field_NaNs_1d_double

!-------------------------------------------------------------------------------
!   check a 1D field for occurences of NaN (single precision)
!       field     : the field to check
!       fieldname : string literal with name of the field
!       found     : boolean set to true IF NaN found in field
!       my_id     : PE number
!-------------------------------------------------------------------------------
SUBROUTINE check_field_NaNs_1d_single (field, fieldname, found, my_id, lacc)

  IMPLICIT NONE

  LOGICAL            , INTENT(INOUT) :: found
  CHARACTER (LEN=*)  , INTENT(IN) :: fieldname
  REAL      (KIND=sp), INTENT(IN) :: field(:)
  INTEGER            , INTENT(IN) :: my_id
  LOGICAL, OPTIONAL  , INTENT(IN) :: lacc

  INTEGER :: NaNs          ! loop indexes
  INTEGER :: i             ! loop indexes
  INTEGER :: ii            ! loop limits
  INTEGER :: i1            ! memorize last occurrence
  LOGICAL :: lzacc, lzfound

  IF (PRESENT(lacc)) THEN
     lzacc=lacc
  ELSE
     lzacc=.FALSE.
  END IF
   
  NaNs=0
  lzfound=.FALSE.
  ii = size(field,1)

  DO i=1,ii
    IF ( is_nan(field(i)) .OR. is_inf(field(i)) ) THEN
      NaNs = NaNs+1
      i1 = i
    ENDIF
  END DO

  !$acc data present (field) if (lzacc)

  !$acc parallel loop gang vector if(lzacc)
  DO i=1,ii
    IF ( is_nan(field(i)) ) THEN
       !$acc atomic write
       lzfound = .true.
       !$acc end atomic
    END IF
  END DO

  IF (lzfound) THEN 
    found = .true.

    !$acc update host(field) if (lzacc)
    WRITE(0,'(A,I7,A,A,A,I5,A,1(I3.3,A))')                          &
         'ERROR:', NaNs, ' NaNs in ', TRIM(fieldname),              &
         ' on PE ', my_id, ' e.g. (i) = (',i1,')'
  ENDIF

  !$acc end data

END SUBROUTINE check_field_NaNs_1d_single

!==============================================================================
!==============================================================================

!-------------------------------------------------------------------------------
! Check if a number is NaN, there is currently no standard solution which works
! with all compilers. This routine calls different method depending on the
! compiler. Tested with - cce (with -D__CRAY_FORTRAN__)
!                       - gnu
!                       - pgi (cp
!------------------------------------------------------------------------------

PURE FUNCTION is_nan_double(x)

#ifdef IEEE_INTR
! Required to use the IEEE_ARITHMETIC when using fp1 with cray
! The routine must be inlined in that case for OpenACC
!DIR$ INLINEALWAYS is_nan
   USE, INTRINSIC :: IEEE_ARITHMETIC, ONLY: IEEE_IS_NAN ! not supported with gcc < 5.0
#else
   !$acc routine seq
#endif

  LOGICAL :: is_nan_double
  REAL(KIND=dp), INTENT(IN) :: x

#ifdef IEEE_INTR
  is_nan_double=IEEE_IS_NAN(x)
#else
  is_nan_double=(x /= x)  ! does not work with Cray compiler
#endif 

END FUNCTION is_nan_double

!-------------------------------------------------------------------------------

PURE FUNCTION is_nan_single(x)

#ifdef IEEE_INTR
! Required to use the IEEE_ARITHMETIC when using fp1 with cray
! The routine must be inlined in that case for OpenACC
!DIR$ INLINEALWAYS is_nan
   USE, INTRINSIC :: IEEE_ARITHMETIC, ONLY: IEEE_IS_NAN ! not supported with gcc < 5.0
#else
   !$acc routine seq
#endif

  LOGICAL :: is_nan_single
  REAL(KIND=sp), INTENT(IN) :: x

#ifdef IEEE_INTR
  is_nan_single=IEEE_IS_NAN(x)
#else
  is_nan_single=(x /= x)  ! does not work with Cray compiler
#endif 

END FUNCTION is_nan_single

!==============================================================================

!-------------------------------------------------------------------------------
! Check if a number is inf
! Tested with - cce (with -D__CRAY_FORTRAN__)
!             - gnu
!             - pgi (cp
!------------------------------------------------------------------------------

PURE FUNCTION is_inf_double(x)

#ifdef IEEE_INTR
! Required to use the IEEE_ARITHMETIC when using fp1 with cray
! The routine must be inlined in that case for OpenACC
!DIR$ INLINEALWAYS is_nan
   USE, INTRINSIC :: IEEE_ARITHMETIC, ONLY: IEEE_IS_FINITE ! not supported with gcc < 5.0
#else
   !$acc routine seq
#endif

  LOGICAL :: is_inf_double
  REAL(KIND=dp), INTENT(IN) :: x

#ifdef IEEE_INTR
  is_inf_double=.NOT.IEEE_IS_FINITE(x)
#else
  is_inf_double=(ABS(x) > HUGE(x))
#endif 

END FUNCTION is_inf_double

!------------------------------------------------------------------------------

PURE FUNCTION is_inf_single(x)

#ifdef IEEE_INTR
! Required to use the IEEE_ARITHMETIC when using fp1 with cray
! The routine must be inlined in that case for OpenACC
!DIR$ INLINEALWAYS is_nan
   USE, INTRINSIC :: IEEE_ARITHMETIC, ONLY: IEEE_IS_FINITE ! not supported with gcc < 5.0
#else
   !$acc routine seq
#endif

  LOGICAL :: is_inf_single
  REAL(KIND=sp), INTENT(IN) :: x

#ifdef IEEE_INTR
  is_inf_single=.NOT.IEEE_IS_FINITE(x)
#else
  is_inf_single=(ABS(x) > HUGE(x))
#endif 

END FUNCTION is_inf_single

!==============================================================================
!==============================================================================

SUBROUTINE lm_sleep (seconds)

  IMPLICIT NONE

  INTEGER, INTENT(IN) :: seconds
  
  ! .. for type conversion to c_int:
  INTEGER   (KIND=c_int) :: wait_sec, dummy

  INTERFACE

    !  should be unsigned int ... not available in Fortran
    !  OK until highest bit gets set.
    FUNCTION FortSleep (sec)  BIND ( C, name="sleep" )
!!UB: does not work not on NEC      IMPORT
      USE, INTRINSIC :: iso_c_binding, ONLY :   c_int
      INTEGER (c_int) :: FortSleep
      INTEGER (c_int), INTENT (in), VALUE :: sec
    END FUNCTION FortSleep
    
  END INTERFACE
  
  wait_sec = INT(seconds, kind=c_int)
  dummy = FortSleep (wait_sec)
  
END SUBROUTINE lm_sleep

!==============================================================================
!==============================================================================

SUBROUTINE fill_array_3d(array, val, lasync_acc)
!-------------------------------------------------------------------------------
!
! Description:
! This routine fills an 3d array with a given value.
!
!-------------------------------------------------------------------------------

! Subroutine arguments:
! --------------------
IMPLICIT NONE

REAL(KIND=wp), INTENT(INOUT)  :: array(:,:,:)
REAL(KIND=wp), INTENT(IN)     :: val
LOGICAL, INTENT(IN), OPTIONAL :: lasync_acc

! Local variables
! --------------------
INTEGER :: i, j, k, iend, jend, kend    ! loop indices

!------------ End of header ----------------------------------------------------

iend = SIZE(array, dim=1)
jend = SIZE(array, dim=2)
kend = SIZE(array, dim=3)

!$acc parallel present(array) async
!$acc loop gang vector collapse(3)
DO k = 1, kend
  DO j = 1, jend
    DO i = 1, iend
      array(i, j, k) = val
    END DO
  END DO
END DO
!$acc end parallel

! if not async, we wait for execution to finish
IF( (.NOT. PRESENT(lasync_acc)) .OR. (.NOT. lasync_acc) ) THEN
  !$acc wait
END IF

END SUBROUTINE fill_array_3d

!==============================================================================
!==============================================================================

SUBROUTINE fill_array_2d(array, val, lasync_acc)
!-------------------------------------------------------------------------------
!
! Description:
! This routine fills an 2d array with a given value
!
!-------------------------------------------------------------------------------

! Subroutine arguments:
! --------------------
IMPLICIT NONE

REAL(KIND=wp), INTENT(INOUT)  :: array(:,:)
REAL(KIND=wp), INTENT(IN)     :: val
LOGICAL, INTENT(IN), OPTIONAL :: lasync_acc

! Local variables
! --------------------
INTEGER :: i, j, iend, jend   ! loop indices

!------------ End of header ----------------------------------------------------

iend = SIZE(array, dim=1)
jend = SIZE(array, dim=2)

!$acc parallel present(array) async
!$acc loop gang vector collapse(2)
DO j = 1, jend
  DO i = 1, iend
    array(i, j) = val
  END DO
END DO
!$acc end parallel

! if not async, we wait for execution to finish
IF( (.NOT. PRESENT(lasync_acc)) .OR. (.NOT. lasync_acc) ) THEN
  !$acc wait
END IF

END SUBROUTINE fill_array_2d

!==============================================================================
!==============================================================================

SUBROUTINE fill_array_1d(array, val, lasync_acc)
!-------------------------------------------------------------------------------
!
! Description:
! This routine fills an 1d array with a given value
!
!-------------------------------------------------------------------------------

! Subroutine arguments:
! --------------------
IMPLICIT NONE

REAL(KIND=wp), INTENT(INOUT)  :: array(:)
REAL(KIND=wp), INTENT(IN)     :: val
LOGICAL, INTENT(IN), OPTIONAL :: lasync_acc

! Local variables
! --------------------
INTEGER :: i, iend    ! loop indices

!------------ End of header ----------------------------------------------------

iend = SIZE(array, dim=1)

!$acc parallel present(array) async
!$acc loop gang vector
DO i = 1, iend
  array(i) = val
END DO
!$acc end parallel

! if not async, we wait for execution to finish
IF( (.NOT. PRESENT(lasync_acc)) .OR. (.NOT. lasync_acc) ) THEN
  !$acc wait
END IF

END SUBROUTINE fill_array_1d

!==============================================================================
!==============================================================================
#ifdef __INT2LM__
!==============================================================================
!
! Routine overtaken from COSMO 5.3 src_artifdata.f90, 2016/02/24, and interface modified
!
! Iteratively calculate pressure piter on the levels zml, given surface
! height hsurf, surface pressure psurf, also given the temperature t 
! (or potential temp. theta, if present), relative humidity relhum,  
! base state pressure p0 and base state density rho0, each on the levels zml.
!
! qv resp. qc is diagnosed from t / theta and the relative humidity in a way 
! as to condense all excess water at supersaturated voxels to qc.
! The final profiles of qv, p are determined by T, relhum and ps. 
!
! This routine requires monotonically decreasing height levels and distinguishes
! between orography height hsurf and model levels zml above it. It is especially for
! the pressure integration at the end of gen_ini_data().
!
! t and relhum at the surface (hsurf) are assumed to be the same values
! as in the layer above (zml(:,:,nk)).
!
!!! The SR calc_p_hydrostat_psts() leads
!!! to a solution which is exactly compatible with the
!!! p'T'-dynamics of the model.
!
! Changes:
!
!  - 6.8.2012: Added support for new fast waves solver (itype_fastwaves=2) (UB)
!
!==============================================================================
!==============================================================================

  SUBROUTINE calc_p_hydrostat_psts(ni,nj,nk,niter, &
       zml, sqrtg, hsurf, psurf, t, relhum, pstart, t0, p0, rho0, &
       piter, qv, qc, zmaxqv, r_d, rvd_m_o, itype_fastwaves, &
       lcond, ldebug, my_cart_id, ierror, errmsg, &
       t0hl, p0hl, wgtfac, theta)

    IMPLICIT NONE

    !.. Input/output variables:
    INTEGER,           INTENT(in) :: ni, nj, nk, niter, itype_fastwaves, my_cart_id
    LOGICAL,           INTENT(in) :: lcond, ldebug
    REAL(KIND=wp),     INTENT(in) :: zml(ni,nj,nk), sqrtg(ni,nj,nk), hsurf(ni,nj), psurf(ni,nj), &
         relhum(ni,nj,nk), pstart(ni,nj,nk)
    REAL(KIND=wp),     INTENT(out) :: qv(ni,nj,nk), qc(ni,nj,nk), piter(ni,nj,nk)
    !.. p, rho of the reference atmosphere at full levels:
    REAL(KIND=wp),     INTENT(in) :: t0(ni,nj,nk), p0(ni,nj,nk), rho0(ni,nj,nk)
    !.. at half levels needed only for itype_fastwaves=2:
    REAL(KIND=wp),     INTENT(in) :: zmaxqv, r_d, rvd_m_o
    REAL(KIND=wp),     INTENT(inout) :: t(ni,nj,nk)
    INTEGER,           INTENT(out) :: ierror
    CHARACTER(len=250), INTENT(out) :: errmsg
    REAL(KIND=wp),     INTENT(in), OPTIONAL :: t0hl(ni,nj,nk), p0hl(ni,nj,nk), wgtfac(ni,nj,nk)
    REAL(KIND=wp),     INTENT(in), OPTIONAL :: theta(ni,nj,nk)


    !.. Local variables:
    REAL(KIND=wp)     :: piterold(ni,nj,nk), relhum_lim(ni,nj,nk)
    REAL(KIND=wp)     :: eps_pp, zpa, ztvw, ztvw1, zesat, zsqv, zrhogdh, zrdm, zcpm
    INTEGER ::  i, j, k, iter
    LOGICAL :: ltheta_ini

    !.. For itype_fastwaves == 2:
    REAL(KIND=wp)     :: one_m_wgtfac, Tp_k_avg, pp_k_avg, T_hl, p_hl, rho_inv_k_avg, &
                         p0_p_k_avg, T_T0_k_avg, p_inv_k_avg, T0_inv_k_avg, q_x_k_avg, buoy


    ierror = 0
    errmsg(:) = ' '

    eps_pp = 1.0E-4_wp  ! required absolute accuracy of the pressure iteration, [Pa]

    !.. Check input parameters:

    IF (itype_fastwaves < 1 .OR. itype_fastwaves > 2) THEN
      ierror = 10010
      errmsg = 'ERROR utilities.f90, calc_p_hydrostat_psts(): Wrong itype_fastwaves!'
      RETURN
    END IF

    IF (itype_fastwaves == 2) THEN
      IF (.NOT.PRESENT(t0hl)) THEN
        ierror = 10011
        errmsg = 'ERROR utilities.f90, calc_p_hydrostat_psts(): '// &
                 'itype_fastwaves == 2, but t0hl not present in input parameters!'
        RETURN
      END IF
      IF (.NOT.PRESENT(p0hl)) THEN
        ierror = 10011
        errmsg = 'ERROR utilities.f90, calc_p_hydrostat_psts(): '// &
                 'itype_fastwaves == 2, but p0hl not present in input parameters!'
        RETURN
      END IF
      IF (.NOT.PRESENT(wgtfac)) THEN
        ierror = 10011
        errmsg = 'ERROR utilities.f90, calc_p_hydrostat_psts(): '// &
                 'itype_fastwaves == 2, but wgtfac not present in input parameters!'   
        RETURN
      END IF
    END IF

    IF (PRESENT(theta)) THEN
      ltheta_ini = .TRUE.
      ! Initialize qv and qc with their "dry" values so that zrdm and zcpm
      ! have a defined value in the first iteration:
      qv(:,:,:) = 0.0_wp
      qc(:,:,:) = 0.0_wp
    ELSE
      ltheta_ini = .FALSE.
      ! Initialize qv and qc with their "dry" values so that qv_Tprelhum()
      ! gets defined values in the first "moist" iteration:
      qv(:,:,:) = 0.0_wp
      qc(:,:,:) = 0.0_wp
    END IF


    ! Instead of iteration until convergence into some max. absolute residuum
    ! we choose to do a fixed number of iterations, since this produces
    ! reproducible results on vector machines.
    ! However, after the iteration it is checked whether the iteration
    ! has converged to the specified absolute error bounds resp.
    ! iteration increment on all gridpoints.

    ! initial pp in the atmosphere and at the surface, will be iteratively corrected below:
    piter(:,:,:)  = pstart(:,:,:)
    piter(:,:,nk) = psurf(:,:)

    DO iter = 1, niter

      ! New variable for limited relhum to max. allowed value p / E(T):
      ! Re-initialize it to relhum for each iteration
      ! to avoid drifts of relhum_lim during the iteration:
      relhum_lim(:,:,:) = relhum(:,:,:)

      ! Store the initial pp at the beginning of the iteration step:
      piterold(:,:,:) = piter(:,:,:)

      ! pressure deviation on the lowest full level
      ! and other initializations
      DO j = 1,nj
        DO i = 1,ni
          ! decomposition of the relative humidity into qv, qc using the 
          ! momentary pressure zpa = p0+pp, depending on the settings of lcond:
          zpa          = piter(i,j,nk)
          IF (ltheta_ini) THEN
            ! "moist" r_d:
            zrdm      = rd_moist(qv(i,j,nk),qc(i,j,nk))
            ! COSMO-approximation of cp:
            zcpm      = cp_moist_cosmo(qv(i,j,nk),qc(i,j,nk),0.0_wp)
            t(i,j,nk) = theta(i,j,nk)*(zpa/pt00)**(zrdm/zcpm)
          END IF
!!$          IF (t(i,j,nk) > 233.16) THEN
            zesat       = esat_w(t(i,j,nk))
!!$          ELSE
!!$            zesat       = esat_i(t(i,j,nk))
!!$          ENDIF
          ! Limit relhum to its maximum possible value p / E(T):
          relhum_lim(i,j,nk) = MIN( zpa/zesat , relhum(i,j,nk) )
          ! Compute actual Qv:
          qv(i,j,nk) = qv_Tprelhum( zpa, t(i,j,nk), relhum_lim(i,j,nk), qc(i,j,nk) )
          IF (lcond .AND. relhum_lim(i,j,1) > 1.0_wp) THEN
            ! condensation is allowed and physically can happen
            ! and relhum > 1.0, so convert qv -> qc to limit relhum to 1.0:
            zsqv = qvsat_w( zpa, t(i,j,nk) )
            qc(i,j,nk) = MAX ( 0.0_wp ,  MIN(qv(i,j,nk), zmaxqv) - zsqv )
            qv(i,j,nk) = MIN ( zsqv       ,  MIN(qv(i,j,nk), zmaxqv) )
          ELSE
            ! condensation is not allowed or cannot happen physically at 
            ! that pressure and temperature, so just impose the limit zmaxqv:
            qc(i,j,nk) = 0.0_wp
            qv(i,j,nk) = MIN(qv(i,j,nk), zmaxqv)
          END IF

          ! pressure on the full level nk by isothermal extrapolation from the ground:
          ztvw         = t(i,j,nk) &
               * (1.0_wp + rvd_m_o*qv(i,j,nk) - qc(i,j,nk))
          piter(i,j,nk) = psurf(i,j) * EXP((hsurf(i,j)-zml(i,j,nk))*g/(ztvw*r_d))            

        ENDDO
      ENDDO

      ! pressure deviation on the full level k-1
      DO k = nk,2, -1

        DO j = 1,nj
          DO i = 1,ni

            ! decomposition of the relative humidity into qv, qc using the 
            ! momentary pressure zpa = p0+pp
            zpa           = piter(i,j,k-1)
            IF (ltheta_ini) THEN
              ! "moist" r_d:
              zrdm       = rd_moist(qv(i,j,k-1),qc(i,j,k-1))
              ! COSMO-approximation of cp:
              zcpm       = cp_moist_cosmo(qv(i,j,k-1),qc(i,j,k-1),0.0_wp)
              t(i,j,k-1) = theta(i,j,k-1)*(zpa/pt00)**(zrdm/zcpm)
            END IF
!!$            IF (t(i,j,k-1) > 233.16) THEN
              zesat       = esat_w(t(i,j,k-1))
!!$            ELSE
!!$              zesat       = esat_i(t(i,j,k-1))
!!$            ENDIF
            ! Limit relhum to its maximum possible value p / E(T):
            relhum_lim(i,j,k-1) = MIN( zpa/zesat , relhum(i,j,k-1) )
            ! Compute actual Qv:
            qv(i,j,k-1) = qv_Tprelhum( zpa, t(i,j,k-1), relhum_lim(i,j,k-1), qc(i,j,k-1) )
            IF (lcond .AND. relhum_lim(i,j,k-1) > 1.0_wp) THEN
              ! condensation is allowed and physically can happen
              ! and relhum > 1.0, so convert qv -> qc to limit relhum to 1.0:
              zsqv = qvsat_w( zpa, t(i,j,k-1) )
              qc(i,j,k-1) = MAX ( 0.0_wp ,  MIN(qv(i,j,k-1), zmaxqv) - zsqv )
              qv(i,j,k-1) = MIN ( zsqv       ,  MIN(qv(i,j,k-1), zmaxqv) )
            ELSE
              ! condensation is not allowed, just set the limit to zmaxqv:
              qc(i,j,k-1) = 0.0_wp
              qv(i,j,k-1) = MIN(qv(i,j,k-1), zmaxqv)
            END IF

            IF (itype_fastwaves == 1) THEN

              ! virtual temperature at levels k and k-1, so that we can use "dry" R_d instead of rd_moist:
              ztvw1 = t(i,j,k-1)*(1.0_wp + rvd_m_o*qv(i,j,k-1) - qc(i,j,k-1))
              ztvw  = t(i,j,k  ) * (1.0_wp + rvd_m_o*qv(i,j,k) - qc(i,j,k))

              zrhogdh = 0.25_wp / sqrtg(i,j,k) * g * (rho0(i,j,k-1)+rho0(i,j,k))

              ! This expression for the pressure has been derived by solving the
              ! discretized r.h.s. of the vertical equation of motion for pp.
              ! Provides exact hydrostatic balance for p'T'-dynamics (itheta_adv=0)
              zpa   = piter(i,j,k) - p0(i,j,k)
              piter(i,j,k-1) = p0(i,j,k-1) + ( zpa + zrhogdh*(2._wp-t0(i,j,k-1)/ztvw1 &
                   - t0(i,j,k)/ztvw*(1._wp + zpa/p0(i,j,k)))) &
                   / (1._wp + zrhogdh*t0(i,j,k-1)/(ztvw1*p0(i,j,k-1)))

            ELSE IF (itype_fastwaves == 2) THEN

              one_m_wgtfac = 1.0_wp - wgtfac(i,j,k)

              Tp_k_avg = wgtfac(i,j,k) * ( t(i,j,k)   - t0(i,j,k)   )  +  &
                   &      one_m_wgtfac * ( t(i,j,k-1) - t0(i,j,k-1) )

              pp_k_avg = wgtfac(i,j,k) * ( piter(i,j,k)   - p0(i,j,k)   )  +  &
                   &      one_m_wgtfac * ( piter(i,j,k-1) - p0(i,j,k-1) )

              T_hl = t0hl(i,j,k) + Tp_k_avg
              p_hl = p0hl(i,j,k) + pp_k_avg

              zrdm       = rd_moist(qv(i,j,k-1),qc(i,j,k-1))
              rho_inv_k_avg   = ( zrdm * T_hl ) / p_hl

              p0_p_k_avg   = 1.0_wp / ( 1.0_wp + pp_k_avg / p0hl(i,j,k) )
              T_T0_k_avg   = 1.0_wp + Tp_k_avg / t0hl(i,j,k)
              p_inv_k_avg  = 1.0_wp / ( p0hl(i,j,k) + pp_k_avg )
              T0_inv_k_avg = 1.0_wp / t0hl(i,j,k)

              q_x_k_avg = wgtfac(i,j,k) * ( rvd_m_o*qv(i,j,k)   - qc(i,j,k)   )  +  &
                           one_m_wgtfac * ( rvd_m_o*qv(i,j,k-1) - qc(i,j,k-1) )

              buoy =  g * ( p0_p_k_avg * T0_inv_k_avg * Tp_k_avg         &
                            - p_inv_k_avg * pp_k_avg                     &
                            + p0_p_k_avg * T_T0_k_avg * q_x_k_avg  )

              zpa = p0(i,j,k) - p0(i,j,k-1)

              piter(i,j,k-1) = piter(i,j,k) - zpa + buoy / ( rho_inv_k_avg * sqrtg(i,j,k) )

            END IF

          ENDDO
        ENDDO

      ENDDO

      ! Catch a badly diverged iteration, which can happen in case
      !   of initialization with very stable N-const profiles (itype_anaprof_tqv = 3):
      IF ( ANY(piter < 0.0_wp .OR. t < 0.0_wp .OR. t > 1000.0_wp) ) THEN
        !.. For meaningful error message, print first erroneous point:
        DO j = 1,nj
          DO i = 1,ni
            IF ( ANY( piter(i,j,:) < 0.0_wp .OR. t(i,j,:) < 0.0_wp .OR. t(i,j,:) > 1000.0_wp ) ) THEN

              WRITE (*,'(a)') 'ERROR: Subroutine calc_p_hydrostat_psts() failed during pressure iteration'
!!$              WRITE (*,'(a,i4,1x,i4)') '    at location (i,j) ', &
!!$                   isubpos(my_cart_id, 1)-nboundlines-1+i, &
!!$                   isubpos(my_cart_id, 2)-nboundlines-1+j
              IF (ltheta_ini) THEN
                WRITE (*,'(a)') '   k   zml(k) theta(k)    t(k) relhum(k)         p(k)        '// &
                     'qv(k)        qc(k)'
                DO k=1,nk
                  WRITE (*,'(i4,1x,f8.1,1x,f8.1,1x,f8.1,1x,f8.5,1x,f12.2,2(1x,es12.5))') &
                       k,zml(i,j,k),theta(i,j,k),t(i,j,k),relhum(i,j,k),piter(i,j,k),qv(i,j,k),qc(i,j,k)
                END DO
                ierror = 10081
                errmsg = 'ERROR utilities.f90, calc_p_hydrostat_psts(): Problem in iteration of '// &
                     'hydrostatic initialisation of pressure field! '// &
                     'Check namelist parameters for stability (N) and/or try to reduce the model top height!'
              ELSE
                WRITE (*,'(a)') '   k   zml(k)    t(k) relhum(k)           p(k)        '// &
                     'qv(k)        qc(k)'
                DO k=1,nk
                  WRITE (*,'(i4,1x,f8.1,1x,f8.1,1x,f8.5,1x,f12.2,2(1x,es12.5))') &
                       k,zml(i,j,k),t(i,j,k),relhum(i,j,k),piter(i,j,k),qv(i,j,k),qc(i,j,k)
                END DO
                ierror = 10082
                errmsg = 'ERROR utilities.f90, calc_p_hydrostat_psts(): Problem in iteration of '// &
                     'hydrostatic initialisation of pressure field! '// &
                     'Initial T profile seems to be problematic!'
              END IF

              RETURN

            END IF
          END DO
        END DO
      END IF

    ENDDO   ! of the iteration

    !.. If necessary, re-calculate T from Theta and iterated pressure:
    IF (ltheta_ini) THEN
      DO k = 1,nk
        DO j = 1,nj
          DO i = 1,ni
            ! "moist" r_d:
            zrdm     = rd_moist(qv(i,j,k),qc(i,j,k))
            ! COSMO-approximation of cp:
            zcpm     = cp_moist_cosmo(qv(i,j,k),qc(i,j,k),0.0_wp)
            t(i,j,k) = theta(i,j,k)*(piter(i,j,k)/pt00)**(zrdm/zcpm)
          END DO
        END DO
      END DO
    END IF

    !.. Debug output of the iterated pressure profile:
    IF (my_cart_id == 0 .AND. ldebug) THEN
      IF (ltheta_ini) THEN
        WRITE (*,'(a)') 'Subroutine calc_p_hydrostat_psts() after '// &
             'pressure iteration at point (1,1):'
        WRITE (*,'(a)') 'k     zml(k) theta(k) relhum(k)     t(k)  piter(k)      '// &
             'qv(k)        qc(k) relhum_out(k)'
        DO k=1,nk
          WRITE (*,'(i4,1x,f8.1,1x,f8.1,1x,f8.5,1x,f8.1,1x,f12.2,2(1x,es12.5),1x,f8.5)') &
               k,zml(1,1,k),theta(1,1,k),relhum(1,1,k),t(1,1,k), &
               piter(1,1,k),qv(1,1,k),qc(1,1,k), &
               rh_Tpqv(piter(1,1,k),t(1,1,k),qv(1,1,k),qc(1,1,k))
        END DO

      ELSE
        WRITE (*,'(a)') 'Subroutine calc_p_hydrostat_psts() after '// &
             'pressure iteration at point (1,1):'
        WRITE (*,'(a)') 'k     zml(k)     t(k) relhum(k)     p(k)      '// &
             'qv(k)        qc(k) relhum_out(k)'
        DO k=1,nk
          WRITE (*,'(i4,1x,f8.1,1x,f8.1,1x,f8.5,1x,f12.2,2(1x,es12.5),1x,f8.5)') &
               k,zml(1,1,k),t(1,1,k),relhum(1,1,k),piter(1,1,k),qv(1,1,k),qc(1,1,k), &
               rh_Tpqv(piter(1,1,k),t(1,1,k),qv(1,1,k),qc(1,1,k))
        END DO
      END IF
    END IF

    ! Convergence check: 
    convergence_loop: DO j = 1,nj
      DO i = 1,ni
        IF ( ANY( ABS(piter(i,j,:) - piterold(i,j,:)) > eps_pp ) ) THEN
          WRITE (*,'(a)') 'WARNING: in calc_p_hydrostat_psts(), utilities.f90: '//&
               'convergence not fully reached in iteration of hydrostatic initialisation!'
!!$          WRITE (*,'(a,i4,1x,i4,a,f12.4,a,f14.7)') 'at location (i,j) ', &
!!$               isubpos(my_cart_id, 1)-nboundlines-1+i, &
!!$               isubpos(my_cart_id, 2)-nboundlines-1+j, &
!!$               '    psurf(i,j) = ', psurf(i,j), '   dp_last_max = ', &
!!$               MAXVAL(ABS(piterold(i,j,:)-piter(i,j,:)))
          IF (ltheta_ini) THEN
            WRITE (*,'(a)') 'k     zml(k) theta(k) relhum(k)     t(k) piter(k)      '// &
                 'qv(k)        qc(k) relhum_out(k)'
            DO k=1,nk
              WRITE (*,'(i4,1x,f8.1,1x,f8.1,1x,f8.5,1x,f8.1,1x,f12.2,2(1x,es12.5),1x,f8.5)') &
                   k,zml(i,j,k),theta(i,j,k),relhum(i,j,k),t(i,j,k),&
                   piter(i,j,k),qv(i,j,k),qc(i,j,k), &
                   rh_Tpqv(piter(i,j,k),t(i,j,k),qv(i,j,k),qc(i,j,k))
            END DO
          ELSE
            WRITE (*,'(a)') 'k     zml(k)     t(k) relhum(k) piter(k)      '// &
                 'qv(k)        qc(k) relhum_out(k)'
            DO k=1,nk
              WRITE (*,'(i4,1x,f8.1,1x,f8.1,1x,f8.5,1x,f12.2,2(1x,es12.5),1x,f8.5)') &
                   k,zml(i,j,k),t(i,j,k),relhum(i,j,k),piter(i,j,k),qv(i,j,k),qc(i,j,k), &
                   rh_Tpqv(piter(i,j,k),t(i,j,k),qv(i,j,k),qc(i,j,k))
            END DO
          END IF
!!$          ierror = 10008
!!$          errmsg = 'ERROR utilities.f90, calc_p_hydrostat_psts(): convergence not fully reached in iteration of '// &
!!$                   'hydrostatic initialisation of pressure field!'
          EXIT convergence_loop
        END IF
      END DO
    END DO convergence_loop

    !.. Issue a warning message if the relat. humid. has been altered above:
    IF (ANY(relhum_lim(:,:,:) /= relhum(:,:,:))) THEN
      WRITE (*,'(a)') REPEAT('*',70)
      WRITE (*,'(a)') 'WARNING: calc_p_hydrostat_psts: Rel. humid. '// &
           'limited to max. allowed VALUE p / E(T) at some grid point(s)'
      WRITE (*,'(a)') REPEAT('*',70)
    END IF

  END SUBROUTINE calc_p_hydrostat_psts

!==============================================================================
!==============================================================================
!
! Routine overtaken from COSMO 5.3 src_artifdata.f90, 2016/02/24, and interface modified
!
! Subroutine similar to calc_p_hydrostat_psts() above, 
! but calc_p_hydrostat_lf() leads
! to a solution which is exactly compatible with the
! Leapfrog-dynamics of the model instead of RK dynamics.
!
!==============================================================================
!==============================================================================

  SUBROUTINE calc_p_hydrostat_lf(ni,nj,nk,niter, &
       zml, hsurf, psurf, t, relhum, pstart, t0, p0, dp0, rho0, &
       piter, qv, qc, zmaxqv, r_d, rvd_m_o, lcond, ldebug, my_cart_id, ierror, errmsg, &
       theta)

    IMPLICIT NONE

    !.. Input/output variables:
    INTEGER,           INTENT(in) :: ni, nj, nk, niter, my_cart_id
    REAL(KIND=wp),     INTENT(in) :: zml(ni,nj,nk), hsurf(ni,nj), psurf(ni,nj), &
         relhum(ni,nj,nk), pstart(ni,nj,nk), t0(ni,nj,nk), p0(ni,nj,nk), dp0(ni,nj,nk), rho0(ni,nj,nk)
    REAL(KIND=wp),     INTENT(out) :: qv(ni,nj,nk), qc(ni,nj,nk), piter(ni,nj,nk)
    REAL(KIND=wp),     INTENT(in) :: zmaxqv, r_d, rvd_m_o
    REAL(KIND=wp),     INTENT(inout) :: t(ni,nj,nk)
    LOGICAL,           INTENT(in) :: lcond, ldebug
    INTEGER,           INTENT(out) :: ierror
    CHARACTER(len=250), INTENT(out) :: errmsg
    REAL(KIND=wp),     INTENT(in), OPTIONAL :: theta(ni,nj,nk)

    !.. Local variables:
    REAL(KIND=wp)     :: piterold(ni,nj,nk), relhum_lim(ni,nj,nk), &
         ztvdt(ni,nj,2), zt0dp0t(ni,nj,2)
    REAL(KIND=wp)     :: eps_pp, zpa, ztvw, zesat, zsqv, zleft, zrhs, zrdm, zcpm
    INTEGER           ::  i, j, k, iter, klow, kup
    LOGICAL :: ltheta_ini


    ierror = 0
    errmsg(:) = ' '

    IF (PRESENT(theta)) THEN
      ltheta_ini = .TRUE.
      ! Initialize qv and qc with their "dry" values so that zrdm and zcpm
      ! have a defined value in the first iteration:
      qv(:,:,:) = 0.0_wp
      qc(:,:,:) = 0.0_wp
    ELSE
      ltheta_ini = .FALSE.
      ! Initialize qv and qc with their "dry" values so that qv_Tprelhum()
      ! gets defined values in the first "moist" iteration:
      qv(:,:,:) = 0.0_wp
      qc(:,:,:) = 0.0_wp
    END IF

    ! Instead of iteration until convergence into some max. absolute residuum
    ! we choose to do a fixed number of iterations, since this produces
    ! reproducible results on vector machines.
    ! However, after the iteration it is checked whether the iteration
    ! has converged to the specified absolute error bounds resp.
    ! iteration increment on all gridpoints.

    eps_pp = 1.0E-4_wp  ! required absolute accuracy of the pressure iteration, [Pa]

    ! initial pp at the surface, will be iteratively corrected below:
    piter(:,:,:)  = pstart(:,:,:)
    piter(:,:,nk) = psurf(:,:)
    

    DO iter = 1, niter

      ! organizational indices
      kup  = 2
      klow = 1

      ! Store the initial pp at the beginning of the iteration step:
      piterold(:,:,:) = piter(:,:,:)

      ! New variable for limited relhum to max. allowed value p / E(T):
      ! Re-initialize it to relhum for each iteration
      ! to avoid drifts of relhum_lim during the iteration:
      relhum_lim(:,:,:) = relhum(:,:,:)

      ! pressure deviation on the lowest full level
      ! and other initializations
      DO j = 1,nj
        DO i = 1,ni
          ! decomposition of the relative humidity into qv, qc using the 
          ! momentary pressure zpa = p0+pp, depending on the settings of lcond:
          zpa          = piter(i,j,nk)
          IF (ltheta_ini) THEN
            ! "moist" r_d:
            zrdm      = rd_moist(qv(i,j,nk),qc(i,j,nk))
            ! COSMO-approximation of cp
            zcpm      = cp_moist_cosmo(qv(i,j,nk),qc(i,j,nk),0.0_wp)
            t(i,j,nk) = theta(i,j,nk)*(zpa/pt00)**(zrdm/zcpm)
          END IF
!!$          IF (t(i,j,nk) > 233.16) THEN
            zesat       = esat_w(t(i,j,nk))
!!$          ELSE
!!$            zesat       = esat_i(t(i,j,nk))
!!$          ENDIF
          ! Limit relhum to its maximum possible value p / E(T):
          relhum_lim(i,j,nk) = MIN( zpa/zesat , relhum(i,j,nk) )
          ! Compute actual Qv:
          qv(i,j,nk) = qv_Tprelhum( zpa, t(i,j,nk), relhum_lim(i,j,nk), qc(i,j,nk) )
          IF (lcond .AND. relhum_lim(i,j,1) > 1.0_wp) THEN
            ! condensation is allowed and physically can happen
            ! and relhum > 1.0, so convert qv -> qc to limit relhum to 1.0:
            zsqv = qvsat_w( zpa, t(i,j,nk) )
            qc(i,j,nk) = MAX ( 0.0_wp ,  MIN(qv(i,j,nk), zmaxqv) - zsqv )
            qv(i,j,nk) = MIN ( zsqv       ,  MIN(qv(i,j,nk), zmaxqv) )
          ELSE
            ! condensation is not allowed or cannot happen physically at 
            ! that pressure and temperature, so just impose the limit zmaxqv:
            qc(i,j,nk) = 0.0_wp
            qv(i,j,nk) = MIN(qv(i,j,nk), zmaxqv)
          END IF

          ! pressure on the full level nk by isothermal extrapolation from the ground:
          ztvw         = t(i,j,nk) &
               * (1.0_wp + rvd_m_o*qv(i,j,nk) - qc(i,j,nk))
          piter(i,j,nk) = psurf(i,j) * EXP((hsurf(i,j)-zml(i,j,nk))*g/(ztvw*r_d))

          ! contribution of the virtual temperature to the buoyancy term
          ztvdt(i,j,klow)   = (ztvw - t0(i,j,nk)) / t(i,j,nk)
          
          ! coefficient of the pressure contribution to the buoyancy term
          zt0dp0t(i,j,klow) = 0.5_wp / ( r_d * rho0(i,j,nk) * t(i,j,nk) )

        ENDDO
      ENDDO

      ! pressure deviation on the full level k-1
      DO k = nk,2, -1

        DO j = 1,nj
          DO i = 1,ni

            ! decomposition of the relative humidity into qv, qc using the 
            ! momentary pressure zpa = p0+pp
            zpa           = piter(i,j,k-1)
            IF (ltheta_ini) THEN
              ! "moist" r_d:
              zrdm       = rd_moist(qv(i,j,k-1),qc(i,j,k-1))
              ! COSMO-approximation of cp:
              zcpm       = cp_moist_cosmo(qv(i,j,k-1),qc(i,j,k-1),0.0_wp)
              t(i,j,k-1) = theta(i,j,k-1)*(zpa/pt00)**(zrdm/zcpm)
            END IF
!!$            IF (t(i,j,k-1) > 233.16) THEN
              zesat       = esat_w(t(i,j,k-1))
!!$            ELSE
!!$              zesat       = esat_i(t(i,j,k-1))
!!$            ENDIF
            ! Limit relhum to its maximum possible value p / E(T):
            relhum_lim(i,j,k-1) = MIN( zpa/zesat , relhum(i,j,k-1) )
            ! Compute actual Qv:
            qv(i,j,k-1) = qv_Tprelhum( zpa, t(i,j,k-1), relhum_lim(i,j,k-1), qc(i,j,k-1) )
            IF (lcond .AND. relhum_lim(i,j,k-1) > 1.0_wp) THEN
              ! condensation is allowed and physically can happen
              ! and relhum > 1.0, so convert qv -> qc to limit relhum to 1.0:
              zsqv = qvsat_w( zpa, t(i,j,k-1) )
              qc(i,j,k-1) = MAX ( 0.0_wp ,  MIN(qv(i,j,k-1), zmaxqv) - zsqv )
              qv(i,j,k-1) = MIN ( zsqv       ,  MIN(qv(i,j,k-1), zmaxqv) )
            ELSE
              ! condensation is not allowed, just set the limit to zmaxqv:
              qc(i,j,k-1) = 0.0_wp
              qv(i,j,k-1) = MIN(qv(i,j,k-1), zmaxqv)
             END IF

            ! virtual temperature at levels k and k-1
            ztvw = t(i,j,k-1)*(1.0_wp + rvd_m_o*qv(i,j,k-1) - qc(i,j,k-1))
            ztvdt(i,j,kup) = (ztvw - t0(i,j,k-1)) / t(i,j,k-1)

            ! coefficient of the pressure contribution to the buoyancy term
            zt0dp0t(i,j,kup) = 0.5_wp / ( r_d * rho0(i,j,k-1) * t(i,j,k-1) )

            ! pressure deviation on the full level k-1
            zpa   = piter(i,j,k) - p0(i,j,k)
            zleft         = 1.0_wp + zt0dp0t(i,j,kup)*dp0(i,j,k)
            zrhs  = zpa*( 1.0_wp - zt0dp0t(i,j,klow)*dp0(i,j,k-1) ) &
                 + 0.5_wp*( ztvdt(i,j,klow)*dp0(i,j,k-1)  &
                        +ztvdt(i,j,kup )*dp0(i,j,k  ) )
            piter(i,j,k-1) = p0(i,j,k-1) + zrhs / zleft

          ENDDO
        ENDDO

        ! changing the organizational indices
        klow = 3 - klow
        kup  = 3 - kup

      ENDDO

      ! Catch a badly diverged iteration, which can easily happen in case
      !   of initialization with N-const profiles (itype_anaprof_tqv = 3):
      IF ( ANY(piter < 0.0_wp .OR. t < 0.0_wp .OR. t > 1000.0_wp) ) THEN
        !.. For meaningful error message, print first erroneous point:
        DO j = 1,nj
          DO i = 1,ni
            IF ( ANY( piter(i,j,:) < 0.0_wp .OR. t(i,j,:) < 0.0_wp .OR. t(i,j,:) > 1000.0_wp ) ) THEN

              WRITE (*,'(a)') 'ERROR: Subroutine calc_p_hydrostat_lf() failed during pressure iteration'
!!$              WRITE (*,'(a,i4,1x,i4)') '    at location (i,j) ', &
!!$                   isubpos(my_cart_id, 1)-nboundlines-1+i, &
!!$                   isubpos(my_cart_id, 2)-nboundlines-1+j
              IF (ltheta_ini) THEN
                WRITE (*,'(a)') '   k   zml(k) theta(k)    t(k) relhum(k)         p(k)        '// &
                     'qv(k)        qc(k)'
                DO k=1,nk
                  WRITE (*,'(i4,1x,f8.1,1x,f8.1,1x,f8.1,1x,f8.5,1x,f12.2,2(1x,es12.5))') &
                       k,zml(i,j,k),theta(i,j,k),t(i,j,k),relhum(i,j,k),piter(i,j,k),qv(i,j,k),qc(i,j,k)
                END DO
                ierror = 10083
                errmsg = 'ERROR utilities.f90, calc_p_hydrostat_lf(): Problem in iteration of '// &
                     'hydrostatic initialisation of pressure field! '// &
                     'Check namelist parameters for stability (N) and/or try to reduce the model top height!'
              ELSE
                WRITE (*,'(a)') '   k   zml(k)    t(k) relhum(k)           p(k)        '// &
                     'qv(k)        qc(k)'
                DO k=1,nk
                  WRITE (*,'(i4,1x,f8.1,1x,f8.1,1x,f8.5,1x,f12.2,2(1x,es12.5))') &
                       k,zml(i,j,k),t(i,j,k),relhum(i,j,k),piter(i,j,k),qv(i,j,k),qc(i,j,k)
                END DO
                ierror = 10084
                errmsg = 'ERROR utilities.f90, calc_p_hydrostat_lf(): Problem in iteration of '// &
                     'hydrostatic initialisation of pressure field! '// &
                     'Initial T profile seems to be problematic!'
              END IF

              RETURN

            END IF
          END DO
        END DO
      END IF

    ENDDO   ! of the iteration

    !.. If necessary, re-calculate T from Theta and iterated pressure:
    IF (ltheta_ini) THEN
      DO k = 1,nk
        DO j = 1,nj
          DO i = 1,ni
            ! "moist" r_d:
            zrdm     = rd_moist(qv(i,j,k),qc(i,j,k))
            ! COSMO-approximation of cp:
            zcpm     = cp_moist_cosmo(qv(i,j,k),qc(i,j,k),0.0_wp)
            t(i,j,k) = theta(i,j,k)*(piter(i,j,k)/pt00)**(zrdm/zcpm)
          END DO
        END DO
      END DO
    END IF

    !.. Debug output of the iterated pressure profile:
    IF (my_cart_id == 0 .AND. ldebug ) THEN
      IF (ltheta_ini) THEN
        WRITE (*,'(a)') 'Subroutine calc_p_hydrostat_lf() after pressure '// &
             'iteration at point (1,1):'
        WRITE (*,'(a)') 'k     zml(k) theta(k) relhum(k)     t(k)  piter(k)      '// &
             'qv(k)        qc(k) relhum_out(k)'
        DO k=1,nk
          WRITE (*,'(i4,1x,f8.1,1x,f8.1,1x,f8.5,1x,f8.1,1x,f12.2,2(1x,es12.5),1x,f8.5)') &
               k,zml(1,1,k),theta(1,1,k),relhum(1,1,k),t(1,1,k), &
               piter(1,1,k),qv(1,1,k),qc(1,1,k), &
               rh_Tpqv(piter(1,1,k),t(1,1,k),qv(1,1,k),qc(1,1,k))
        END DO

      ELSE
        WRITE (*,'(a)') 'Subroutine calc_p_hydrostat_lf() after pressure '// &
             'iteration at point (1,1):'
        WRITE (*,'(a)') 'k     zml(k)     t(k) relhum(k)     p(k)      '// &
             'qv(k)        qc(k) relhum_out(k)'
        DO k=1,nk
          WRITE (*,'(i4,1x,f8.1,1x,f8.1,1x,f8.5,1x,f12.2,2(1x,es12.5),1x,f8.5)') &
               k,zml(1,1,k),t(1,1,k),relhum(1,1,k),piter(1,1,k),qv(1,1,k),qc(1,1,k), &
               rh_Tpqv(piter(1,1,k),t(1,1,k),qv(1,1,k),qc(1,1,k))
        END DO
      END IF
    END IF

    ! Convergence check:
    convergence_loop: DO j = 1,nj
      DO i = 1,ni
        IF ( ANY( ABS(piter(i,j,:) - piterold(i,j,:)) > eps_pp ) ) THEN
          WRITE (*,'(a)') 'WARNING: in calc_p_hydrostat_lf(), utilities.f90: '//&
               'no convergence in iteration of hydrostatic initialisation!'
!!$          WRITE (*,'(a,i4,1x,i4,a,f12.4,a,f14.7)') 'at location (i,j) ', &
!!$               isubpos(my_cart_id, 1)-nboundlines-1+i, &
!!$               isubpos(my_cart_id, 2)-nboundlines-1+j, &
!!$               '    psurf(i,j) = ', psurf(i,j), '   dp_last_max = ', &
!!$               MAXVAL(ABS(piterold(i,j,:)-piter(i,j,:)))
          IF (ltheta_ini) THEN
            WRITE (*,'(a)') 'k     zml(k) theta(k) relhum(k)     t(k) piter(k)      '// &
                 'qv(k)        qc(k) relhum_out(k)'
            DO k=1,nk
              WRITE (*,'(i4,1x,f8.1,1x,f8.1,1x,f8.5,1x,f8.1,1x,f12.2,2(1x,es12.5),1x,f8.5)') &
                   k,zml(i,j,k),theta(i,j,k),relhum(i,j,k),t(i,j,k),&
                   piter(i,j,k),qv(i,j,k),qc(i,j,k), &
                   rh_Tpqv(piter(i,j,k),t(i,j,k),qv(i,j,k),qc(i,j,k))
            END DO
          ELSE
            WRITE (*,'(a)') 'k     zml(k)     t(k) relhum(k) piter(k)      '// &
                 'qv(k)        qc(k) relhum_out(k)'
            DO k=1,nk
              WRITE (*,'(i4,1x,f8.1,1x,f8.1,1x,f8.5,1x,f12.2,2(1x,es12.5),1x,f8.5)') &
                   k,zml(i,j,k),t(i,j,k),relhum(i,j,k),piter(i,j,k),qv(i,j,k),qc(i,j,k), &
                   rh_Tpqv(piter(i,j,k),t(i,j,k),qv(i,j,k),qc(i,j,k))
            END DO
          END IF
!!$          ierror = 10009
!!$          errmsg = 'ERROR utilities.f90, calc_p_hydrostat_lf(): No convergence in iteration of '// &
!!$                   'hydrostatic initialisation of pressure field!'
!!$          RETURN
          EXIT convergence_loop
        END IF
      END DO
    END DO convergence_loop
    
    !.. Issue a warning message if the relat. humid. has been altered above:
    IF (ANY(relhum_lim(:,:,:) /= relhum(:,:,:))) THEN
      WRITE (*,'(a)') REPEAT('*',70)
      WRITE (*,'(a)') 'WARNING: calc_p_hydrostat_lf: Rel. humid. limited to '// &
           'max. allowed value p / E(T)'
      WRITE (*,'(a)') REPEAT('*',70)
    END IF

  END SUBROUTINE calc_p_hydrostat_lf


!=====================================================================================
!=====================================================================================
!
! Routine overtaken from COSMO 5.3 src_artifdata.f90, 2016/02/24, and interface modified
!
! Subroutine for computing the analytic hydrostatic pressure profile
! for a given temperature t (or pot. temperature theta) profile.
! The discrete points in the t- (or theta-) profile are
! interpreted as a linear spline (polygone) w.r.t. t, so that t in the layer
! between two points is treated as a polytrope layer (linear
! dependence on height).
!
! The resulting solution for the pressure profile is
! perhaps the most accurate analytic solution, but is not
! necessarily equal to the numeric representation of 
! the hydrostatic balance used in the model dynamics!
! IN CONTRAST, the SR calc_p_hydrostat_psts() leads
! to a solution which is exactly compatible with the
! p'T'-dynamics of the model, and calc_p_hydrostat_lf()
! is compatible with leapfrog dynamics.
!
! - psurf is the pressure at the lowest height level zml(:,:,1)
!   and is the base for upwards pressure integration.
!
! - a separate pstart is not needed because it is computed
!   for a dry atmosphere below from ps.
!
! - If theta (optional argument) is provided on input,
!   then this is used as the basis for the temperature
!   profile rather than directly using t, and t is
!   calculated and given back to the calling routine.  
!
! - The pressure integration takes into account moisture and
!   perhaps cloud droplets if relhum > 1 at some voxels.
! 
! - At the same time, relhum (and consequently Qv)  is 
!   limited to its upper bound of p / E(T).
!
! - Requires monotonically increasing height levels !!!
!
!
!=====================================================================================
!=====================================================================================

  SUBROUTINE calc_p_hydrostat_ana(ni, nj, nk, niter, &
       zml, psurf, t, relhum, &
       piter, qv, qc, zmaxqv, r_d, rvd_m_o, lcond, ldebug, my_cart_id, ierror, errmsg, &
       theta)

    IMPLICIT NONE

    !.. Input/output variables:
    INTEGER,           INTENT(in) :: ni, nj, nk, niter, my_cart_id
    REAL(KIND=wp),     INTENT(in) :: zml(ni,nj,nk), psurf(ni,nj), relhum(ni,nj,nk)
    REAL(KIND=wp),     INTENT(out) :: qv(ni,nj,nk), qc(ni,nj,nk), piter(ni,nj,nk)
    REAL(KIND=wp),     INTENT(in) :: zmaxqv, r_d, rvd_m_o
    REAL(KIND=wp),     INTENT(inout) :: t(ni,nj,nk)
    LOGICAL,           INTENT(in) :: lcond, ldebug
    INTEGER,           INTENT(out) :: ierror
    CHARACTER(len=250), INTENT(out) :: errmsg
    REAL(KIND=wp),     INTENT(in), OPTIONAL :: theta(ni,nj,nk)

    !.. Local variables:
    REAL(KIND=wp)     :: piterold(ni,nj,nk), relhum_lim(ni,nj,nk)
    REAL(KIND=wp)     :: eps_pp, zpa, ztv1, ztv2, zesat, zsqv, zgamma, zrdm, zcpm
    INTEGER ::  i, j, k, iter
    LOGICAL :: ltheta_ini

    ierror = 0
    errmsg(:) = ' '

    eps_pp = 1.0E-4_wp     ! Pa, required abs. accuracy of the below pressure iteration

    IF (PRESENT(theta)) THEN
      ltheta_ini = .TRUE.
      ! Initialize qv and qc with their "dry" values so that zrdm and zcpm
      ! have a defined value in the first "moist" iteration:
      qv(:,:,:) = 0.0_wp
      qc(:,:,:) = 0.0_wp
    ELSE
      ltheta_ini = .FALSE.
      ! Initialize qv and qc with their "dry" values so that qv_Tprelhum()
      ! gets defined values in the first "moist" iteration:
      qv(:,:,:) = 0.0_wp
      qc(:,:,:) = 0.0_wp
    END IF

    !==========================================================================
    !.. First: Integrate atmospheric pressure assuming dry air. 
    !   This will be the starting point for
    !   a fixpoint iteration to include also moisture and condensation 
    !   in supersaturated voxels.
    !==========================================================================

    !   In case of ltheta_ini = .true., the temperature profile is not known a priori,
    !   because we would need the pressure to compute it from the theta-profile.
    !   As a starting point, the temperature will simply be that of the ICAO 
    !   polytrope atmosphere with a constant temperature lapse rate of 0.0065 K/m 
    !   up to 11 km height and a base temperature of 293.16 K. Then, the
    !   pressure estimate for the dry base will be that of the ICAO standard
    !   atmosphere. The below iteration will compute the correct temperature-
    !   and pressure profile afterwards.
    !    
    IF (ltheta_ini) THEN
      t(:,:,:)  = 293.16_wp - 0.0065_wp * MIN(zml(:,:,:), 11000.0_wp)
    END IF

    ! Pressure at the lowest level:
    piter(:,:,1) = psurf

    ! The other levels are polytrope layers assuming const. temp. gradient:
    DO k = 2, nk
      DO j=1,nj
        DO i=1,ni

          ztv1 = t(i,j,k-1)
          ztv2 = t(i,j,k)
          IF (ABS(ztv2-ztv1) > 1.0E-6_wp) THEN
            zgamma = (ztv1-ztv2) / (zml(i,j,k)-zml(i,j,k-1))
            piter(i,j,k) = piter(i,j,k-1) * &
                 (1.0_wp-(zml(i,j,k)-zml(i,j,k-1))*zgamma/ztv1)**(g/(r_d*zgamma))
          ELSE
            piter(i,j,k) = piter(i,j,k-1) * EXP(-g*(zml(i,j,k)-zml(i,j,k-1))/(r_d*ztv1))
          END IF

        END DO
      END DO
    END DO

    !.. Debug output of the iterated dry pressure profile:
    IF (my_cart_id == 0 .AND. ldebug ) THEN
      WRITE (*,*) 'Subroutine calc_p_hydrostat_ana() after dry '// &
           'pressure iteration at point (1,1):'
      WRITE (*,*) 'k     zml(k)     p(k) for the dry atmosphere'
      DO k=1,nk
        WRITE (*,'(i4,1x,f8.1,1x,f12.2)') k,zml(1,1,k),piter(1,1,k)
      END DO
    END IF

    !==========================================================================
    ! Now humidity and clouds come into play:
    !
    ! The total density depends on qv, qc and therefore also on piter (through qv),
    ! but piter itself depends on qv via the hydrostatic approximation --> 
    ! iterative solution of this implicit equation for piter necessary!
    ! For this, each layer is again assumed to be a polytrope layer,
    ! this time with a constant virtual temperature gradient:
    !
    ! For the sake of reproducible results, we do a fixed number of iterations
    ! instead of iterating until convergence to a certain accuracy.
    !==========================================================================

    DO iter = 1, niter

      ! New variable for limited relhum to max. allowed value p / E(T):
      ! Re-initialize it to relhum for each iteration
      ! to avoid drifts of relhum_lim during the iteration:
      relhum_lim(:,:,:) = relhum(:,:,:)

      piterold(:,:,:) = piter(:,:,:)

      DO j=1,nj
        DO i=1,ni

          ! Compute t, qv, qc for the lowest level:

          ! decomposition of the relative humidity into qv, qc using the 
          ! momentary pressure zpa
          zpa          = piter(i,j,1)
          ! saturation specific vapor content (Spezifische Feuchte bei Saettigung):
          IF (ltheta_ini) THEN
            ! "moist" r_d:
            zrdm     = rd_moist(qv(i,j,1),qc(i,j,1))
            ! "moist" cp:
!!$            zcpm = cp_moist(qv(i,j,1),qc(i,j,1),0.0_wp)
            ! COSMO-approximation of "moist" cp:
            zcpm     = cp_moist_cosmo(qv(i,j,1),qc(i,j,1),0.0_wp)
            t(i,j,1) = theta(i,j,1)*(zpa/pt00)**(zrdm/zcpm)
          END IF
!!$          IF (t(i,j,1) > 233.16) THEN
          zesat       = esat_w(t(i,j,1))
!!$          ELSE
!!$            zesat       = esat_i(t(i,j,1))
!!$          ENDIF
          ! Limit relhum to its maximum possible value p / E(T):
          relhum_lim(i,j,1) = MIN( zpa/zesat , relhum(i,j,1) )
          ! Compute actual Qv:
          qv(i,j,1) = qv_Tprelhum( zpa, t(i,j,1), relhum_lim(i,j,1), qc(i,j,1) )
          IF (lcond .AND. relhum_lim(i,j,1) > 1.0_wp) THEN
            ! condensation is allowed and physically can happen
            ! and relhum > 1.0, so convert qv -> qc to limit relhum to 1.0:
            zsqv = qvsat_w( zpa, t(i,j,1) )
            qc(i,j,1) = MAX ( 0.0_wp ,  MIN(qv(i,j,1), zmaxqv) - zsqv )
            qv(i,j,1) = MIN ( zsqv       ,  MIN(qv(i,j,1), zmaxqv) )
          ELSE
            ! condensation is not allowed or cannot happen physically at 
            ! that pressure and temperature, so just impose the limit zmaxqv:
            qc(i,j,1) = 0.0_wp
            qv(i,j,1) = MIN(qv(i,j,1), zmaxqv)
          END IF

        END DO
      END DO

      ! Again, the other levels are polytrope layers assuming const. virt. temp. gradient:
      DO k = 2, nk

        DO j=1,nj
          DO i=1,ni

            !.. virtual temperature ztv1 at the bottom of the layer:
            ztv1 = t(i,j,k-1) * (1.0_wp + rvd_m_o*qv(i,j,k-1) - qc(i,j,k-1))

            !.. virtual temperature ztv2 at the top of the layer:
            zpa          = piter(i,j,k)
            IF (ltheta_ini) THEN
              ! "moist" r_d:
              zrdm     = rd_moist(qv(i,j,k),qc(i,j,k))
              ! "moist" cp:
!!$              zcpm = cp_moist(qv(i,j,k),qc(i,j,k),0.0_wp)
              ! COSMO-approximation o "moist" cp:
              zcpm     = cp_moist_cosmo(qv(i,j,k),qc(i,j,k),0.0_wp)
              t(i,j,k) = theta(i,j,k)*(zpa/pt00)**(zrdm/zcpm)
            END IF
!!$            IF (t(i,j,k) > 233.16) THEN
            zesat       = esat_w(t(i,j,k))
!!$            ELSE
!!$              zesat       = esat_i(t(i,j,k))
!!$            ENDIF
            ! Limit relhum to its maximum possible value p / E(T):
            relhum_lim(i,j,k) = MIN( zpa/zesat , relhum(i,j,k) )
            ! Compute actual Qv:
            qv(i,j,k) = qv_Tprelhum( zpa, t(i,j,k), relhum_lim(i,j,k), qc(i,j,k) )

            IF (lcond .AND. relhum_lim(i,j,k) > 1.0_wp) THEN
              ! condensation is allowed and physically can happen
              ! and relhum > 1.0, so convert qv -> qc to limit relhum to 1.0:
              zsqv = qvsat_w( zpa, t(i,j,k) )
              qc(i,j,k) = MAX ( 0.0_wp ,  MIN(qv(i,j,k), zmaxqv) - zsqv )
              qv(i,j,k) = MIN ( zsqv       ,  MIN(qv(i,j,k), zmaxqv) )
            ELSE
              ! condensation is not allowed, just set the limit to zmaxqv:
              qc(i,j,k) = 0.0_wp
              qv(i,j,k) = MIN(qv(i,j,k), zmaxqv)
            END IF

            ztv2   = t(i,j,k) * (1.0_wp + rvd_m_o*qv(i,j,k) - qc(i,j,k))

            !.. pressure at the top of the polytrope layer:
            IF (ABS(ztv2-ztv1) > 1.0E-6_wp) THEN
              zgamma = (ztv1-ztv2) / (zml(i,j,k)-zml(i,j,k-1))
              piter(i,j,k) = piter(i,j,k-1) * &
                   (1.0_wp-(zml(i,j,k)-zml(i,j,k-1))*zgamma/ztv1)**(g/(r_d*zgamma))
            ELSE
              piter(i,j,k) = piter(i,j,k-1) * EXP(-g*(zml(i,j,k)-zml(i,j,k-1))/(r_d*ztv1))
            END IF

          END DO
        END DO

      END DO

      ! Catch a badly diverged iteration, which can easily happen in case
      !   of initialization with N-const profiles (itype_anaprof_tqv = 3):
      IF ( ANY(piter < 0.0_wp .OR. t < 0.0_wp .OR. t > 1000.0_wp) ) THEN
        !.. For meaningful error message, print first erroneous point:
        DO j = 1,nj
          DO i = 1,ni
            IF ( ANY( piter(i,j,:) < 0.0_wp .OR. t(i,j,:) < 0.0_wp .OR. t(i,j,:) > 1000.0_wp ) ) THEN

              WRITE (*,'(a)') 'ERROR: Subroutine calc_p_hydrostat_ana() failed during pressure iteration'
!!$              WRITE (*,'(a,i4,1x,i4)') '    at location (i,j) ', &
!!$                   isubpos(my_cart_id, 1)-nboundlines-1+i, &
!!$                   isubpos(my_cart_id, 2)-nboundlines-1+j
              IF (ltheta_ini) THEN
                WRITE (*,'(a)') '   k   zml(k) theta(k)    t(k) relhum(k)         p(k)        '// &
                     'qv(k)        qc(k)'
                DO k=1,nk
                  WRITE (*,'(i4,1x,f8.1,1x,f8.1,1x,f8.1,1x,f8.5,1x,f12.2,2(1x,es12.5))') &
                       k,zml(i,j,k),theta(i,j,k),t(i,j,k),relhum(i,j,k),piter(i,j,k),qv(i,j,k),qc(i,j,k)
                END DO
                ierror = 10085
                errmsg = 'ERROR utilities.f90, calc_p_hydrostat_ana(): Problem in iteration of '// &
                     'hydrostatic initialisation of pressure field! '// &
                     'Check namelist parameters for stability (N) and/or try to reduce the model top height!'
              ELSE
                WRITE (*,'(a)') '   k   zml(k)    t(k) relhum(k)           p(k)        '// &
                     'qv(k)        qc(k)'
                DO k=1,nk
                  WRITE (*,'(i4,1x,f8.1,1x,f8.1,1x,f8.5,1x,f12.2,2(1x,es12.5))') &
                       k,zml(i,j,k),t(i,j,k),relhum(i,j,k),piter(i,j,k),qv(i,j,k),qc(i,j,k)
                END DO
                ierror = 10086
                errmsg = 'ERROR utilities.f90, calc_p_hydrostat_ana(): Problem in iteration of '// &
                     'hydrostatic initialisation of pressure field! '// &
                     'Initial T profile seems to be problematic!'
              END IF

              RETURN

            END IF
          END DO
        END DO
      END IF

    END DO

    !.. If necessary, re-calculate T from Theta and iterated pressure:
    IF (ltheta_ini) THEN
      DO k = 1,nk
        DO j = 1,nj
          DO i = 1,ni
            ! "moist" r_d:
            zrdm     = rd_moist(qv(i,j,k),qc(i,j,k))
            ! COSMO-approximation of cp:
            zcpm     = cp_moist_cosmo(qv(i,j,k),qc(i,j,k),0.0_wp)
            t(i,j,k) = theta(i,j,k)*(piter(i,j,k)/pt00)**(zrdm/zcpm)
          END DO
        END DO
      END DO
    END IF

    !.. Debug output of the iterated pressure profile:
    IF (my_cart_id == 0 .AND. ldebug ) THEN
      IF (ltheta_ini) THEN
        WRITE (*,'(a)') 'Subroutine calc_p_hydrostat_ana() after pressure '// &
             'iteration at point (1,1):'
        WRITE (*,'(a)') 'k     zml(k) theta(k) relhum(k)     t(k)  piter(k)      '// &
             'qv(k)        qc(k) relhum_out(k)'
        DO k=1,nk
          WRITE (*,'(i4,1x,f8.1,1x,f8.1,1x,f8.5,1x,f8.1,1x,f12.2,2(1x,es12.5),1x,f8.5)') &
               k,zml(1,1,k),theta(1,1,k),relhum(1,1,k),t(1,1,k), &
               piter(1,1,k),qv(1,1,k),qc(1,1,k), &
               rh_Tpqv(piter(1,1,k),t(1,1,k),qv(1,1,k),qc(1,1,k))
        END DO

      ELSE
        WRITE (*,'(a)') 'Subroutine calc_p_hydrostat_ana() after pressure '// &
             'iteration at point (1,1):'
        WRITE (*,'(a)') 'k     zml(k)     t(k) relhum(k)     p(k)      '// &
             'qv(k)        qc(k) relhum_out(k)'
        DO k=1,nk
          WRITE (*,'(i4,1x,f8.1,1x,f8.1,1x,f8.5,1x,f12.2,2(1x,es12.5),1x,f8.5)') &
               k,zml(1,1,k),t(1,1,k),relhum(1,1,k),piter(1,1,k),qv(1,1,k),qc(1,1,k), &
               rh_Tpqv(piter(1,1,k),t(1,1,k),qv(1,1,k),qc(1,1,k))
        END DO
      END IF
    END IF

    ! Convergence check:
    convergence_loop: DO j = 1,nj
      DO i = 1,ni
        IF ( ANY( ABS(piter(i,j,:) - piterold(i,j,:)) > eps_pp ) ) THEN
          WRITE (*,'(a)') 'WARNING: in calc_p_hydrostat_ana(), utilities.f90: '//&
               'no convergence in iteration of hydrostatic initialisation!'
!!$          WRITE (*,'(a,i4,1x,i4,a,f12.4,a,f14.7)') 'at location (i,j) ', &
!!$               isubpos(my_cart_id, 1)-nboundlines-1+i, &
!!$               isubpos(my_cart_id, 2)-nboundlines-1+j, &
!!$          '    psurf(i,j) = ', psurf(i,j), '   dp_last_max = ', &
!!$               MAXVAL(ABS(piterold(i,j,:)-piter(i,j,:)))
          IF (ltheta_ini) THEN
            WRITE (*,'(a)') 'k     zml(k) theta(k) relhum(k)     t(k) piter(k)      '// &
                 'qv(k)        qc(k) relhum_out(k)'
            DO k=1,nk
              WRITE (*,'(i4,1x,f8.1,1x,f8.1,1x,f8.5,1x,f8.1,1x,f12.2,2(1x,es12.5),1x,f8.5)') &
                   k,zml(i,j,k),theta(i,j,k),relhum(i,j,k),t(i,j,k), &
                   piter(i,j,k),qv(i,j,k),qc(i,j,k), &
                   rh_Tpqv(piter(i,j,k),t(i,j,k),qv(i,j,k),qc(i,j,k))
            END DO
          ELSE
            WRITE (*,'(a)') 'k     zml(k)     t(k) relhum(k) piter(k)      '// &
                 'qv(k)        qc(k) relhum_out(k)'
            DO k=1,nk
              WRITE (*,'(i4,1x,f8.1,1x,f8.1,1x,f8.5,1x,f12.2,2(1x,es12.5),1x,f8.5)') &
                   k,zml(i,j,k),t(i,j,k),relhum(i,j,k),piter(i,j,k),qv(i,j,k),qc(i,j,k), &
                   rh_Tpqv(piter(i,j,k),t(i,j,k),qv(i,j,k),qc(i,j,k))
            END DO
          END IF

!!$          ierror = 10010
!!$          errmsg = 'ERROR utilities.f90, calc_p_hydrostat_ana(): No convergence in iteration of '// &
!!$               'hydrostatic initialisation of pressure field!'
!!$
!!$          RETURN
          EXIT convergence_loop
        END IF
      END DO
    END DO convergence_loop

    !.. Issue a warning message if the relat. humid. has been altered above:
    IF (ANY(relhum_lim(:,:,:) /= relhum(:,:,:))) THEN
      WRITE (*,'(a)') REPEAT('*',70)
      WRITE (*,'(a)') 'WARNING: calc_p_hydrostat_ana: Rel. humid. limited '// &
           'to max. allowed value p / E(T)'
      WRITE (*,'(a)') REPEAT('*',70)
    END IF

  END SUBROUTINE calc_p_hydrostat_ana

!=====================================================================================
!=====================================================================================

!=====================================================================================
!
! Following routines overtaken from COSMO 5.3 src_artifdata.f90, 2016/02/24
!
! Functions for computing moisture quantities:
!
!=====================================================================================

  ! saturation vapor pressure w.r.t. plain water surface (scalar version):
  REAL(KIND=wp) ELEMENTAL FUNCTION esat_w(temp)
    IMPLICIT NONE
    REAL(KIND=wp),     INTENT(in) :: temp
    esat_w = b1 * EXP( b2w * (temp-b3)/(temp-b4w) )
  END FUNCTION esat_w

  ! saturation vapor pressure w.r.t. plain ice surface (scalar version):
  REAL(KIND=wp) ELEMENTAL FUNCTION esat_i(temp)
    IMPLICIT NONE
    REAL(KIND=wp),     INTENT(in) :: temp
    esat_i = b1 * EXP( b2i * (temp-b3)/(temp-b4i) )
  END FUNCTION esat_i

  ! saturation specific humidity w.r.t. plain water surface (scalar version):
  ! RETURNS -999.99, IF THE SATURATION VAPOR PRESSURE IS > TOTAL PRESSURE!
  !   (IN THIS CASE, QVSAT IS NO LONGER A MEANINGFUL QUANTITY,
  !    BECAUSE SATURATION CANNOT OCCUR AT THAT PRESSURE AND TEMPERATURE)
  REAL(KIND=wp) ELEMENTAL FUNCTION qvsat_w(p, temp)
    IMPLICIT NONE
    REAL(KIND=wp),     INTENT(in) :: p, temp
    REAL(KIND=wp)     :: zesat_w
    zesat_w  = b1 * EXP( b2w * (temp-b3)/(temp-b4w) )
    IF (zesat_w <= p) THEN
      qvsat_w = rdv * zesat_w / ( p - o_m_rdv * zesat_w )
    ELSE
      qvsat_w = -999.99_wp
    END IF
  END FUNCTION qvsat_w

  ! saturation specific humidity w.r.t. plain ice surface (scalar version):
  ! RETURNS -999.99, IF THE SATURATION VAPOR PRESSURE IS > TOTAL PRESSURE!
  !   (IN THIS CASE, QVSAT IS NO LONGER A MEANINGFUL QUANTITY,
  !    BECAUSE SATURATION CANNOT OCCUR AT THAT PRESSURE AND TEMPERATURE)
  REAL(KIND=wp) ELEMENTAL FUNCTION qvsat_i(p, temp)
    IMPLICIT NONE
    REAL(KIND=wp),     INTENT(in) :: p, temp
    REAL(KIND=wp)     :: zesat_i
    zesat_i  = b1 * EXP( b2i * (temp-b3)/(temp-b4i) )
    IF (zesat_i <= p) THEN
      qvsat_i = rdv * zesat_i / ( p - o_m_rdv * zesat_i )
    ELSE
      qvsat_i = -999.99_wp
    END IF
  END FUNCTION qvsat_i

  ! Specific humidity as function of T, p, and relhum 
  !   (and qcrs = sum of all hydrometeor contents):
  ! NOTE: on input, relhum has to be smaller than p / E(T)!
  REAL(KIND=wp) ELEMENTAL FUNCTION qv_Tprelhum(p, temp, relhum, qcrs)
    IMPLICIT NONE
    REAL(KIND=wp),     INTENT(in) :: p, temp, relhum, qcrs
    REAL(KIND=wp)     :: zesat_w, coeff
    zesat_w  = b1 * EXP( b2w * (temp-b3)/(temp-b4w) )
    coeff = relhum * zesat_w * rdv / p
    qv_Tprelhum = coeff * (1.0_wp - qcrs) / (1.0_wp - rvd_m_o*coeff)
  END FUNCTION qv_Tprelhum

  ! Specific humidity as function of T, p, and rho_v
  !   (and qcrs = sum of all hydrometeor contents):
  REAL(KIND=wp) ELEMENTAL FUNCTION qv_Tprhov(p, temp, rhov, qcrs)
    IMPLICIT NONE
    REAL(KIND=wp),     INTENT(in) :: p, temp, rhov, qcrs
    REAL(KIND=wp)     :: zesat_w, coeff
    zesat_w  = b1 * EXP( b2w * (temp-b3)/(temp-b4w) )
    coeff = rhov * r_d * temp / p
    qv_Tprhov = coeff * (1.0_wp - qcrs) / (1.0_wp - rvd_m_o*coeff)
  END FUNCTION qv_Tprhov

  ! Rel. humidity as function of T, p, and qv
  !   (and qcrs = sum of all hydrometeor contents):
  REAL(KIND=wp) ELEMENTAL FUNCTION rh_Tpqv(p, temp, qv, qcrs)
    IMPLICIT NONE
    REAL(KIND=wp),     INTENT(in) :: p, temp, qv, qcrs
    REAL(KIND=wp)     :: zesat_w
    zesat_w  = b1 * EXP( b2w * (temp-b3)/(temp-b4w) )
    rh_Tpqv = p * qv / (rdv * zesat_w * (1.0_wp+rvd_m_o*qv-qcrs) )
  END FUNCTION rh_Tpqv


  ! Gas constant of moist air containing hydrometeors (qcrs is the sum of
  ! the specific hydrometeor contents):
  REAL(KIND=wp) ELEMENTAL FUNCTION rd_moist(qv,qcrs)
    IMPLICIT NONE
    REAL(KIND=wp),     INTENT(in) :: qv, qcrs

    rd_moist = r_d * (1.0_wp + rvd_m_o*qv - qcrs)

  END FUNCTION rd_moist

  ! Cp of moist air containing hydrometeors (ql is the sum of
  ! the liquid specific hydrometeor contents, qi the sum of the specific ice
  ! hydrometeor contents):
  REAL(KIND=wp) ELEMENTAL FUNCTION cp_moist(qv,ql,qi)
    IMPLICIT NONE
    REAL(KIND=wp),     INTENT(in) :: qv, ql, qi
    REAL(KIND=wp)                 :: qd

    ! Dry air content:
    qd = 1.0_wp - qv - ql -qi

    ! cp:
!    cp_moist = qd*cp_d + qv*cp_v + ql*cp_l + qi*cp_i
    cp_moist = qd*cp_d + qv*(cp_d*(1.0_wp+rcpv)) + ql*(cp_d*(1.0_wp+rcpl)) + qi*2060.0_wp

  END FUNCTION cp_moist

  ! COSMO-APPROXIMATION: CP IS APPROXIMATED TO BE THAT OF DRY AIR
  REAL(KIND=wp) ELEMENTAL FUNCTION cp_moist_cosmo(qv,ql,qi)
    IMPLICIT NONE
    REAL(KIND=wp),     INTENT(in) :: qv, ql, qi
    REAL(KIND=wp)                 :: qd

    ! Dry air content:
    qd = 1.0_wp - qv - ql -qi

    ! cp:
    cp_moist_cosmo = qd*cp_d + qv*cp_d + ql*cp_d + qi*cp_d

  END FUNCTION cp_moist_cosmo

!=================================================================================
!=================================================================================

  SUBROUTINE calc_p_hydrostat_ana_qv (ni, nj, nk, &
       z, p0, t, qv, qc, r_d, rvd_m_o, p)

    !=================================================================================
    !
    ! Subroutine for computing the analytic hydrostatic pressure profile
    ! for given t, qv, qc-profiles at discrete heights z, starting from
    ! a pressure p0 at the first height level.
    ! The integration of the hydrostatic equation assumes a linear spline
    ! with respect to the virtual temperature tv = t * ( 1 + 0.61*qv - qc).
    ! No iteration is necessary because qv is input directly, so that
    ! the humidity quantity does not depend on pressure itself.
    !
    !=================================================================================

    IMPLICIT NONE

    !.. Input/output variables:
    INTEGER,           INTENT(in) :: ni, nj, nk
    REAL(KIND=wp),     INTENT(in) :: z(ni,nj,nk), p0(ni,nj)
    REAL(KIND=wp),     INTENT(in) :: t(ni,nj,nk), qv(ni,nj,nk), qc(ni,nj,nk)
    REAL(KIND=wp),     INTENT(in) :: r_d, rvd_m_o
    REAL(KIND=wp),     INTENT(out):: p(ni,nj,nk)

    !.. Local variables:
    REAL(KIND=wp)     :: ztv1, ztv2, zgamma
    INTEGER           ::  i, j, k
 
    ! Pressure at the first level:
    p(:,:,1) = p0

    ! The other levels are polytrope layers assuming const. temp. gradient:
    DO k = 2, nk
      DO j=1,nj
        DO i=1,ni

          ztv1 = t(i,j,k-1) * (1.0_wp + rvd_m_o*qv(i,j,k-1) - qc(i,j,k-1))
          ztv2 = t(i,j,k)   * (1.0_wp + rvd_m_o*qv(i,j,k  ) - qc(i,j,k  ))
          IF (ABS(ztv2-ztv1) > 1.0E-6_wp) THEN
            zgamma = (ztv1-ztv2) / (z(i,j,k)-z(i,j,k-1))
            p(i,j,k) = p(i,j,k-1) * &
                 (1.0_wp-(z(i,j,k)-z(i,j,k-1))*zgamma/ztv1)**(g/(r_d*zgamma))
          ELSE
            p(i,j,k) = p(i,j,k-1) * EXP(-g*(z(i,j,k)-z(i,j,k-1))/(r_d*ztv1))
          END IF

        END DO
      END DO
    END DO

  END SUBROUTINE calc_p_hydrostat_ana_qv

!=================================================================================
#endif
!=================================================================================

END MODULE utilities
